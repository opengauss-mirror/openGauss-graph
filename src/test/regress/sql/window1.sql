--
-- WINDOW FUNCTIONS
--

CREATE TABLE EMPSALARY (DEPNAME VARCHAR, EMPNO BIGINT, SALARY INT, ENROLL_DATE DATE) ;
CREATE TABLE CLONE_TENK1   AS SELECT * FROM TENK1;

INSERT INTO EMPSALARY VALUES
('develop', 10, 5200, '2007-08-01'),
('sales', 1, 5000, '2006-10-01'),
('personnel', 5, 3500, '2007-12-10'),
('sales', 4, 4800, '2007-08-08'),
('personnel', 2, 3900, '2006-12-23'),
('develop', 7, 4200, '2008-01-01'),
('develop', 9, 4500, '2008-01-01'),
('sales', 3, 4800, '2007-08-01'),
('develop', 8, 6000, '2006-10-01'),
('develop', 11, 5200, '2007-08-15');

SELECT DEPNAME, EMPNO, SALARY, SUM(SALARY) OVER (PARTITION BY DEPNAME) FROM EMPSALARY ORDER BY 1, 2, 3, 4;

SELECT DEPNAME, EMPNO, SALARY, RANK() OVER (PARTITION BY DEPNAME ORDER BY SALARY) FROM EMPSALARY ORDER BY 1, 2, 3, 4;

-- WITH GROUP BY
SELECT FOUR, TEN, SUM(SUM(FOUR)) OVER (PARTITION BY FOUR), AVG(TEN) FROM CLONE_TENK1
GROUP BY FOUR, TEN ORDER BY FOUR, TEN;

SELECT DEPNAME, EMPNO, SALARY, SUM(SALARY) OVER W FROM EMPSALARY WINDOW W AS (PARTITION BY DEPNAME) ORDER BY EMPNO,SALARY;

SELECT DEPNAME, EMPNO, SALARY, RANK() OVER W FROM EMPSALARY WINDOW W AS (PARTITION BY DEPNAME ORDER BY SALARY) ORDER BY RANK() OVER W,EMPNO;

-- EMPTY WINDOW SPECIFICATION
SELECT COUNT(*) OVER () FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1;

SELECT COUNT(*) OVER W FROM CLONE_TENK1 WHERE UNIQUE2 < 10 WINDOW W AS () ORDER BY 1;

-- NO WINDOW OPERATION
SELECT FOUR FROM CLONE_TENK1 WHERE FALSE WINDOW W AS (PARTITION BY TEN);

-- CUMULATIVE AGGREGATE
SELECT SUM(FOUR) OVER (PARTITION BY TEN ORDER BY UNIQUE2) AS SUM_1, TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT ROW_NUMBER() OVER (ORDER BY UNIQUE2) FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1;

SELECT RANK() OVER (PARTITION BY FOUR ORDER BY TEN) AS RANK_1, TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT DENSE_RANK() OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT PERCENT_RANK() OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT CUME_DIST() OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT NTILE(3) OVER (ORDER BY TEN, FOUR), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT NTILE(NULL) OVER (ORDER BY TEN, FOUR), TEN, FOUR FROM CLONE_TENK1 LIMIT 2;

SELECT LAG(TEN) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LAG(TEN, FOUR) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LAG(TEN, FOUR, 0) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LEAD(TEN) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LEAD(TEN * 2, 1) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LEAD(TEN * 2, 1, -1) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT FIRST_VALUE(TEN) OVER (PARTITION BY FOUR ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

-- LAST_VALUE RETURNS THE LAST ROW OF THE FRAME, WHICH IS CURRENT ROW IN ORDER BY WINDOW.
SELECT LAST_VALUE(FOUR) OVER (ORDER BY TEN, FOUR), TEN, FOUR FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1, 2, 3;

SELECT LAST_VALUE(TEN) OVER (PARTITION BY FOUR), TEN, FOUR FROM
(SELECT * FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY FOUR, TEN)S
ORDER BY FOUR, TEN;

SELECT NTH_VALUE(TEN, FOUR + 1) OVER (PARTITION BY FOUR), TEN, FOUR
FROM (SELECT * FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY FOUR, TEN)S
ORDER BY FOUR, TEN;

SELECT TEN, TWO, SUM(HUNDRED) AS GSUM, SUM(SUM(HUNDRED)) OVER (PARTITION BY TWO ORDER BY TEN) AS WSUM 
FROM CLONE_TENK1 GROUP BY TEN, TWO
ORDER BY TEN, TWO;

SELECT COUNT(*) OVER (PARTITION BY FOUR), FOUR FROM (SELECT * FROM CLONE_TENK1 WHERE TWO = 1)S WHERE UNIQUE2 < 10 ORDER BY 1, 2;

SELECT (COUNT(*) OVER (PARTITION BY FOUR ORDER BY TEN) + 
  SUM(HUNDRED) OVER (PARTITION BY FOUR ORDER BY TEN))::VARCHAR AS CNTSUM 
  FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1;

-- OPEXPR WITH DIFFERENT WINDOWS EVALUATION.
SELECT * FROM(
  SELECT COUNT(*) OVER (PARTITION BY FOUR ORDER BY TEN) +
    SUM(HUNDRED) OVER (PARTITION BY TWO ORDER BY TEN) AS TOTAL,
    COUNT(*) OVER (PARTITION BY FOUR ORDER BY TEN) AS FOURCOUNT,
    SUM(HUNDRED) OVER (PARTITION BY TWO ORDER BY TEN) AS TWOSUM
    FROM CLONE_TENK1
)SUB
WHERE TOTAL <> FOURCOUNT + TWOSUM;

SELECT AVG(FOUR) OVER (PARTITION BY FOUR ORDER BY THOUSAND / 100) FROM CLONE_TENK1 WHERE UNIQUE2 < 10 ORDER BY 1;

SELECT TEN, TWO, SUM(HUNDRED) AS GSUM, SUM(SUM(HUNDRED)) OVER WIN AS WSUM 
FROM CLONE_TENK1 GROUP BY TEN, TWO WINDOW WIN AS (PARTITION BY TWO ORDER BY TEN) ORDER BY 1, 2, 3, 4;

-- MORE THAN ONE WINDOW WITH GROUP BY
SELECT SUM(SALARY),
	ROW_NUMBER() OVER (ORDER BY DEPNAME),
	SUM(SUM(SALARY)) OVER (ORDER BY DEPNAME DESC)
FROM EMPSALARY GROUP BY DEPNAME;

-- IDENTICAL WINDOWS WITH DIFFERENT NAMES
SELECT SUM(SALARY) OVER W1, COUNT(*) OVER W2
FROM EMPSALARY WINDOW W1 AS (ORDER BY SALARY), W2 AS (ORDER BY SALARY) ORDER BY 1, 2;

-- SUBPLAN
SELECT LEAD(TEN, (SELECT TWO FROM CLONE_TENK1 WHERE S.UNIQUE2 = UNIQUE2)) OVER (PARTITION BY FOUR ORDER BY TEN)
FROM CLONE_TENK1 S WHERE UNIQUE2 < 10 ORDER BY 1;

-- EMPTY TABLE
SELECT COUNT(*) OVER (PARTITION BY FOUR) FROM (SELECT * FROM CLONE_TENK1 WHERE FALSE)S;

-- MIXTURE OF AGG/WFUNC IN THE SAME WINDOW
SELECT SUM(SALARY) OVER W, RANK() OVER W FROM EMPSALARY WINDOW W AS (PARTITION BY DEPNAME ORDER BY SALARY DESC) ORDER BY 1, 2;

-- STRICT AGGS
SELECT EMPNO, DEPNAME, SALARY, BONUS, DEPADJ, MIN(BONUS) OVER (ORDER BY EMPNO), MAX(DEPADJ) OVER () FROM(
	SELECT *,
		CASE WHEN ENROLL_DATE < '2008-01-01' THEN 2008 - EXTRACT(YEAR FROM ENROLL_DATE) END * 500 AS BONUS,
		CASE WHEN
			AVG(SALARY) OVER (PARTITION BY DEPNAME) < SALARY
		THEN 200 END AS DEPADJ FROM EMPSALARY
)S ORDER BY EMPNO;

-- WINDOW FUNCTION OVER UNGROUPED AGG OVER EMPTY ROW SET (BUG BEFORE 9.1)
SELECT SUM(COUNT(F1)) OVER () FROM INT4_TBL WHERE F1=42;

-- WINDOW FUNCTION WITH ORDER BY AN EXPRESSION INVOLVING AGGREGATES (9.1 BUG)
SELECT TEN, SUM(UNIQUE1) + SUM(UNIQUE2) AS RES, RANK() OVER (ORDER BY SUM(UNIQUE1) + SUM(UNIQUE2)) AS RANK
FROM CLONE_TENK1
GROUP BY TEN ORDER BY TEN;

-- WINDOW AND AGGREGATE WITH GROUP BY EXPRESSION (9.2 BUG)
EXPLAIN (COSTS OFF, NODES OFF)
SELECT FIRST_VALUE(MAX(X)) OVER (), Y
FROM (SELECT UNIQUE1 AS X, TEN+FOUR AS Y FROM CLONE_TENK1) SS
GROUP BY Y;

-- TEST NON-DEFAULT FRAME SPECIFICATIONS
SELECT FOUR, TEN, SUM(TEN) OVER (PARTITION BY FOUR ORDER BY TEN), LAST_VALUE(TEN) OVER (PARTITION BY FOUR ORDER BY TEN)
FROM (SELECT DISTINCT TEN, FOUR FROM CLONE_TENK1) SS ORDER BY 1, 2, 3, 4;

SELECT FOUR, TEN, SUM(TEN) OVER (PARTITION BY FOUR ORDER BY TEN RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), LAST_VALUE(TEN) OVER (PARTITION BY FOUR ORDER BY TEN RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM (SELECT DISTINCT TEN, FOUR FROM CLONE_TENK1) SS ORDER BY 1, 2, 3, 4;

SELECT FOUR, TEN, SUM(TEN) OVER (PARTITION BY FOUR ORDER BY TEN RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING), LAST_VALUE(TEN) OVER (PARTITION BY FOUR ORDER BY TEN RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
FROM (SELECT DISTINCT TEN, FOUR FROM CLONE_TENK1) SS ORDER BY 1, 2, 3, 4;

SELECT FOUR, TEN/4 AS TWO,SUM(TEN/4) OVER (PARTITION BY FOUR ORDER BY TEN/4 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),LAST_VALUE(TEN/4) OVER (PARTITION BY FOUR ORDER BY TEN/4 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM (SELECT DISTINCT TEN, FOUR FROM CLONE_TENK1) SS ORDER BY 1, 2, 3, 4;

SELECT FOUR, TEN/4 AS TWO, SUM(TEN/4) OVER (PARTITION BY FOUR ORDER BY TEN/4 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW), LAST_VALUE(TEN/4) OVER (PARTITION BY FOUR ORDER BY TEN/4 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW)
FROM (SELECT DISTINCT TEN, FOUR FROM CLONE_TENK1) SS ORDER BY 1, 2, 3, 4;

SELECT SUM(UNIQUE1) OVER (ORDER BY FOUR, UNIQUE1 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING),
	UNIQUE1, FOUR
FROM CLONE_TENK1 WHERE UNIQUE1 < 10;

SELECT SUM(UNIQUE1) OVER (ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), UNIQUE1, FOUR
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1 ORDER BY 1, 2, 3;

SELECT SUM(UNIQUE1) OVER (ROWS BETWEEN 2 PRECEDING AND 2 FOLLOWING), UNIQUE1, FOUR
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1 ORDER BY 1, 2, 3;

SELECT SUM(UNIQUE1) OVER (ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING), UNIQUE1, FOUR
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1 ORDER BY 1, 2, 3;

SELECT SUM(UNIQUE1) OVER (ROWS BETWEEN 1 FOLLOWING AND 3 FOLLOWING), UNIQUE1, FOUR
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1 ORDER BY 1, 2, 3;

SELECT SUM(UNIQUE1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING), UNIQUE1, FOUR
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1 ORDER BY 1, 2, 3;

SELECT SUM(UNIQUE1) OVER (W RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING), UNIQUE1, FOUR
FROM CLONE_TENK1 WHERE UNIQUE1 < 10 WINDOW W AS (ORDER BY FOUR, UNIQUE1);

-- FAIL: NOT IMPLEMENTED YET
SELECT SUM(UNIQUE1) OVER (ORDER BY FOUR, TEN, UNIQUE1 RANGE BETWEEN 2::INT8 PRECEDING AND 1::INT2 PRECEDING), UNIQUE1, FOUR
FROM CLONE_TENK1 WHERE UNIQUE1 < 10;

SELECT FIRST_VALUE(UNIQUE1) OVER W, NTH_VALUE(UNIQUE1, 2) OVER W AS NTH_2, LAST_VALUE(UNIQUE1) OVER W, UNIQUE1, FOUR
FROM CLONE_TENK1 WHERE UNIQUE1 < 10
WINDOW W AS (ORDER BY FOUR, TEN, UNIQUE1 RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING);

SELECT SUM(UNIQUE1) OVER (ORDER BY UNIQUE1 ROWS (SELECT UNIQUE1 FROM CLONE_TENK1 ORDER BY UNIQUE1 LIMIT 1) + 1 PRECEDING), UNIQUE1
FROM (SELECT UNIQUE1, FOUR FROM CLONE_TENK1 WHERE UNIQUE1 < 10 ORDER BY 1, 2) STENK1;

CREATE VIEW V_WINDOW AS SELECT I, SUM(I) OVER (ORDER BY I ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS SUM_ROWS FROM GENERATE_SERIES(1, 10) I;

SELECT * FROM V_WINDOW;

SELECT PG_GET_VIEWDEF('V_WINDOW');

-- WITH UNION
SELECT COUNT(*) OVER (PARTITION BY FOUR) FROM (SELECT * FROM CLONE_TENK1 UNION ALL SELECT * FROM TENK2)S LIMIT 0;

-- ORDERING BY A NON-INTEGER CONSTANT IS ALLOWED
SELECT RANK() OVER (ORDER BY LENGTH('ABC'));

-- CAN'T ORDER BY ANOTHER WINDOW FUNCTION
SELECT RANK() OVER (ORDER BY RANK() OVER (ORDER BY RANDOM()));

-- SOME OTHER ERRORS
SELECT * FROM EMPSALARY WHERE ROW_NUMBER() OVER (ORDER BY SALARY) < 10;

SELECT * FROM EMPSALARY INNER JOIN CLONE_TENK1 ON ROW_NUMBER() OVER (ORDER BY SALARY) < 10;

SELECT RANK() OVER (ORDER BY 1), COUNT(*) FROM EMPSALARY GROUP BY 1;

SELECT * FROM RANK() OVER (ORDER BY RANDOM());

DELETE FROM EMPSALARY WHERE (RANK() OVER (ORDER BY RANDOM())) > 10;

DELETE FROM EMPSALARY RETURNING RANK() OVER (ORDER BY RANDOM());

SELECT COUNT(*) OVER W FROM CLONE_TENK1 WINDOW W AS (ORDER BY UNIQUE1), W AS (ORDER BY UNIQUE1);

SELECT RANK() OVER (PARTITION BY FOUR, ORDER BY TEN) FROM CLONE_TENK1;

SELECT COUNT() OVER () FROM CLONE_TENK1;

SELECT GENERATE_SERIES(1, 100) OVER () FROM EMPSALARY;

SELECT NTILE(0) OVER (ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1;

SELECT NTH_VALUE(FOUR, 0) OVER (ORDER BY TEN), TEN, FOUR FROM CLONE_TENK1;

EXPLAIN (COSTS OFF, VERBOSE ON)
select empno, row_number() over(partition by substr(depname,1,3)  order by salary) from empsalary order by empno;

-- CLEANUP
DROP TABLE EMPSALARY;
DROP TABLE CLONE_TENK1;
DROP VIEW V_WINDOW;

CREATE TABLE EMPSALARY (DEPNAME VARCHAR, EMPNO BIGINT, SALARY INT, ENROLL_DATE DATE) ;

INSERT INTO EMPSALARY VALUES
('develop', 10, 5200, '2007-08-01'),
('sales', 1, 5000, '2006-10-01'),
('personnel', 5, 3500, '2007-12-10'),
('sales', 4, 4800, '2007-08-08'),
('personnel', 2, 3900, '2006-12-23'),
('develop', 7, 4200, '2008-01-01'),
('develop', 9, 4500, '2008-01-01'),
('sales', 3, 4800, '2007-08-01'),
('develop', 8, 6000, '2006-10-01'),
('develop', 11, 5200, '2007-08-15');

EXPLAIN (COSTS OFF, VERBOSE ON)
select empno, row_number() over(partition by substr(depname,1,3)  order by salary, empno) from empsalary order by empno;

select empno, row_number() over(partition by substr(depname,1,3)  order by salary, empno) from empsalary order by empno;

DROP TABLE EMPSALARY;

CREATE TABLE REPLICATION_WINDOW_T1(A INT, B INT, C INT, D INT)  ;
INSERT INTO REPLICATION_WINDOW_T1 VALUES (GENERATE_SERIES(1, 2), GENERATE_SERIES(1, 3), GENERATE_SERIES(1, 5), GENERATE_SERIES(1, 7));

EXPLAIN (COSTS OFF, VERBOSE ON)
SELECT 
RANK() OVER (PARTITION BY A ORDER BY B, C, D), 
A, B, C, D,
SUM(A) OVER (PARTITION BY A ORDER BY B, C, D), 
SUM(B) OVER (PARTITION BY B ORDER BY A, C, D),
SUM(C) OVER (PARTITION BY C ORDER BY A, B, D),
SUM(D) OVER (PARTITION BY D ORDER BY A, B, C)
FROM REPLICATION_WINDOW_T1 ORDER BY 1, 2, 3, 4, 5;

SELECT 
RANK() OVER (PARTITION BY A ORDER BY B, C, D), 
A, B, C, D,
SUM(A) OVER (PARTITION BY A ORDER BY B, C, D), 
SUM(B) OVER (PARTITION BY B ORDER BY A, C, D),
SUM(C) OVER (PARTITION BY C ORDER BY A, B, D),
SUM(D) OVER (PARTITION BY D ORDER BY A, B, C)
FROM REPLICATION_WINDOW_T1 ORDER BY 1, 2, 3, 4, 5;

DROP TABLE REPLICATION_WINDOW_T1;

CREATE TABLE REPLICATION_WINDOW_T1(ID INT ,NAME VARCHAR(20),ZIP VARCHAR(20))  ;
CREATE TABLE REPLICATION_WINDOW_T2(ID INT,STREET VARCHAR(20),ZIP VARCHAR(20),C_D_ID INT,C_ID INT)  ;
CREATE TABLE REPLICATION_WINDOW_T3(C_ID INT,STREET VARCHAR(20),ZIP VARCHAR(20) ,C_D_ID INT,ID INT)  ;
CREATE TABLE REPLICATION_WINDOW_T4 (ID INTEGER,STREET VARCHAR(20),ZIP CHAR(9),C_D_ID INTEGER,C_W_ID INTEGER) ;

EXPLAIN (COSTS OFF, VERBOSE ON)
SELECT MAX(DT1.ID) OVER W 
FROM
(
	SELECT REPLICATION_WINDOW_T1.ID, REPLICATION_WINDOW_T1.NAME, REPLICATION_WINDOW_T1.ZIP
	FROM REPLICATION_WINDOW_T1
	WHERE (REPLICATION_WINDOW_T1.ID IN ( SELECT A.ID FROM REPLICATION_WINDOW_T4 A WHERE NOT (EXISTS ( SELECT B.C_ID, B.STREET, B.ZIP, B.C_D_ID, B.ID FROM REPLICATION_WINDOW_T2 B WHERE B.C_ID = A.ID)))) ORDER BY REPLICATION_WINDOW_T1.ID, REPLICATION_WINDOW_T1.NAME, REPLICATION_WINDOW_T1.ZIP LIMIT 7
) DT1 LEFT JOIN 
(
	SELECT A.ID, A.STREET, A.ZIP, A.C_D_ID, A.C_ID 
	FROM REPLICATION_WINDOW_T3 A 
	RIGHT JOIN REPLICATION_WINDOW_T4 B ON A.ID = B.ID::NUMERIC AND A.C_D_ID = B.C_D_ID  
	WHERE A.ID IS NOT NULL
)EXPLICIT_JOIN_02 ON DT1.ID=EXPLICIT_JOIN_02.ID 
WHERE DT1.ID>=1 
WINDOW W AS (PARTITION BY DT1.ZIP ORDER BY DT1.ID DESC)
ORDER BY 1;

SELECT MAX(DT1.ID) OVER W 
FROM
(
	SELECT REPLICATION_WINDOW_T1.ID, REPLICATION_WINDOW_T1.NAME, REPLICATION_WINDOW_T1.ZIP
	FROM REPLICATION_WINDOW_T1
	WHERE (REPLICATION_WINDOW_T1.ID IN ( SELECT A.ID FROM REPLICATION_WINDOW_T4 A WHERE NOT (EXISTS ( SELECT B.C_ID, B.STREET, B.ZIP, B.C_D_ID, B.ID FROM REPLICATION_WINDOW_T2 B WHERE B.C_ID = A.ID)))) ORDER BY REPLICATION_WINDOW_T1.ID, REPLICATION_WINDOW_T1.NAME, REPLICATION_WINDOW_T1.ZIP LIMIT 7
) DT1 LEFT JOIN 
(
	SELECT A.ID, A.STREET, A.ZIP, A.C_D_ID, A.C_ID 
	FROM REPLICATION_WINDOW_T3 A 
	RIGHT JOIN REPLICATION_WINDOW_T4 B ON A.ID = B.ID::NUMERIC AND A.C_D_ID = B.C_D_ID  
	WHERE A.ID IS NOT NULL
)EXPLICIT_JOIN_02 ON DT1.ID=EXPLICIT_JOIN_02.ID 
WHERE DT1.ID>=1 
WINDOW W AS (PARTITION BY DT1.ZIP ORDER BY DT1.ID DESC)
ORDER BY 1;

DROP TABLE REPLICATION_WINDOW_T1;
DROP TABLE REPLICATION_WINDOW_T2;
DROP TABLE REPLICATION_WINDOW_T3;
DROP TABLE REPLICATION_WINDOW_T4;

create table window_test(a int, b int, c int, d int) ;
insert into window_test values(1, 11, generate_series(1, 30) % 5,  generate_series(1, 30) % 6);
insert into window_test select * from window_test;
insert into window_test select * from window_test;
insert into window_test select * from window_test;
insert into window_test select * from window_test;
analyze window_test;
explain (verbose on, costs off) select c, d, ROW_NUMBER() OVER(PARTITION BY c, d) AS QUA_ROW_NUM_1 from window_test;
explain (verbose on, costs off)select * from (select c, d, ROW_NUMBER() OVER(PARTITION BY c, d) AS QUA_ROW_NUM_1 from window_test) AA 
where QUA_ROW_NUM_1 = 1 order by 1, 2;
select * from (select c, d, ROW_NUMBER() OVER(PARTITION BY c, d) AS QUA_ROW_NUM_1 from window_test) AA where QUA_ROW_NUM_1 = 1 order by 1, 2;
explain (verbose on, costs off) select c, ((lead(c) over w - d))/5 as result from window_test window w as(partition by c, d order by c);
drop table window_test;

create table WINFUNC_TAB_HASH
 ( c_id  integer ,
  c_d_id  integer ,
  c_w_id  integer  ,
  c_first varchar(16),
  c_middle    char(2)  ,
  c_last  varchar(16)  ,
  c_street_1  varchar(20),
  c_street_2  varchar(20) ,
  c_city  varchar(20)  ,
  c_state char(2)  ,
  c_zip   char(9)  ,
  c_phone char(16)  ,
  c_since timestamp without time zone,
  c_credit    char(2),
  c_credit_lim  numeric(12,2),
  c_discount  numeric(4,4) ,
  c_balance  numeric(12,2)   ,
  c_ytd_payment numeric(12,2) ,
  c_payment_cnt  integer  ,
  c_delivery_cnt integer ,
  c_data  varchar(500),
  e      regproc)
  ;

explain (verbose on, costs off)
SELECT * FROM  (SELECT  e, C_ID AS ID1, LEAD(C_ID<10) OVER W AS ID2,  C_SINCE AS DATE1, 
 LEAD(substr(C_SINCE,1,10) ) OVER W AS DATE2  FROM WINFUNC_TAB_HASH
 WINDOW W AS (PARTITION BY e ORDER BY e, C_ID , C_D_ID , C_SINCE ,C_FIRST ,
 C_MIDDLE ,C_LAST,C_CITY,C_STREET_1,C_STREET_2)) 
AS TEMP WHERE e is not null and id1 is not null ORDER BY 1,2,3,4,5;

drop table WINFUNC_TAB_HASH;

--test cost of stream 
create table stream_cost_table(a int, b int, c regproc);
insert into stream_cost_table select generate_series(1, 1000), generate_series(1, 1000) % 50, 'sin';
analyze stream_cost_table;
--window function for redistribute and broadcast
explain (verbose on, costs off) select avg(a::numeric(7, 2)) over(partition by b) from stream_cost_table; 
explain (verbose on, costs off) select avg(a::numeric(7, 2)) over(partition by c) from stream_cost_table;
--group stream for redistribute and broadcast
set enable_hashagg=off; 
explain (verbose on, costs off) select a from stream_cost_table union (select b from stream_cost_table t group by t.b);
explain (verbose on, costs off) select a from stream_cost_table union (select c from stream_cost_table t group by t.c);
--distinct stream for redistribute and broadcast
explain (verbose on, costs off) select a from stream_cost_table union (select distinct(b) from stream_cost_table);
explain (verbose on, costs off) select a from stream_cost_table union (select distinct(c) from stream_cost_table);
--agg stream for redistribute and broadcast
set enable_hashagg=on; 
explain (verbose on, costs off) select sum(x) from (select 1, sum(a) x from stream_cost_table group by 1);
explain (verbose on, costs off) select sum(b) from stream_cost_table union (select sum(b) from stream_cost_table);  

drop table stream_cost_table;

--test expression and windowagg
set enable_hashagg=off;
create table t_window(a int primary key, b int);
explain (verbose on, costs off) select a, sum(b)*b, rank() over (partition by a) from t_window group by 1;
explain (verbose on, costs off) select b, sum(a)*coalesce(a,0), rank() over (partition by b+1) from t_window group by 1, coalesce(a,0);
drop table t_window;
