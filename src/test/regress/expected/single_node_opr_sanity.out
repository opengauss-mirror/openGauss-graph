--
-- OPR_SANITY
-- Sanity checks for common errors in making operator/procedure system tables:
-- pg_operator, pg_proc, pg_cast, pg_aggregate, pg_am,
-- pg_amop, pg_amproc, pg_opclass, pg_opfamily.
--
-- None of the SELECTs here should ever find any matching entries,
-- so the expected output is easy to maintain ;-).
-- A test failure indicates someone messed up an entry in the system tables.
--
-- NB: we assume the oidjoins test will have caught any dangling links,
-- that is OID or REGPROC fields that are not zero and do not match some
-- row in the linked-to table.  However, if we want to enforce that a link
-- field can't be 0, we have to check it here.
--
-- NB: run this test earlier than the create_operator test, because
-- that test creates some bogus operators...
-- Helper functions to deal with cases where binary-coercible matches are
-- allowed.
-- This should match IsBinaryCoercible() in parse_coerce.c.
create function binary_coercible(oid, oid) returns bool as $$
SELECT ($1 = $2) OR
 EXISTS(select 1 from pg_catalog.pg_cast where
        castsource = $1 and casttarget = $2 and
        castmethod = 'b' and castcontext = 'i') OR
 ($2 = 'pg_catalog.anyarray'::pg_catalog.regtype AND
  EXISTS(select 1 from pg_catalog.pg_type where
         oid = $1 and typelem != 0 and typlen = -1))
$$ language sql strict stable;
create function binary_coercible_3(oid, oid) returns bool as $$
SELECT ($1 = $2) OR
 EXISTS(select 1 from pg_catalog.pg_cast where
        castsource = $1 and casttarget = $2 and
        castmethod = 'b' and castcontext = 'i') OR
 ($2 = 'pg_catalog.any'::pg_catalog.regtype) OR
 ($2 = 'pg_catalog.anyarray'::pg_catalog.regtype AND
  EXISTS(select 1 from pg_catalog.pg_type where
         oid = $1 and typelem != 0 and typlen = -1)) OR
 ($2 = 'pg_catalog.anyrange'::pg_catalog.regtype AND
  (select typtype from pg_catalog.pg_type where oid = $1) = 'r')
$$ language sql strict stable;
-- This one ignores castcontext, so it considers only physical equivalence
-- and not whether the coercion can be invoked implicitly.
create function physically_coercible(oid, oid) returns bool as $$
SELECT ($1 = $2) OR
 EXISTS(select 1 from pg_catalog.pg_cast where
        castsource = $1 and casttarget = $2 and
        castmethod = 'b') OR
 ($2 = 'pg_catalog.anyarray'::pg_catalog.regtype AND
  EXISTS(select 1 from pg_catalog.pg_type where
         oid = $1 and typelem != 0 and typlen = -1))
$$ language sql strict stable;
create function physically_coercible_2(oid, oid) returns bool as $$
SELECT ($1 = $2) OR
 EXISTS(select 1 from pg_catalog.pg_cast where
        castsource = $1 and casttarget = $2 and
        castmethod = 'b') OR
 ($2 = 'pg_catalog.any'::pg_catalog.regtype) OR
 ($2 = 'pg_catalog.anyarray'::pg_catalog.regtype AND
  EXISTS(select 1 from pg_catalog.pg_type where
         oid = $1 and typelem != 0 and typlen = -1)) OR
 ($2 = 'pg_catalog.anyrange'::pg_catalog.regtype AND
  (select typtype from pg_catalog.pg_type where oid = $1) = 'r')
$$ language sql strict stable;
-- **************** pg_proc ****************
-- Look for illegal values in pg_proc fields.
SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE p1.prolang = 0 OR p1.prorettype = 0 OR
       p1.pronargs < 0 OR
       p1.pronargdefaults < 0 OR
       p1.pronargdefaults > p1.pronargs OR
       array_lower(p1.proargtypes, 1) != 0 OR
       array_upper(p1.proargtypes, 1) != p1.pronargs-1 OR
       0::oid = ANY (p1.proargtypes) OR
       procost <= 0 OR
       CASE WHEN proretset THEN prorows <= 0 ELSE prorows != 0 END
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- prosrc should never be null or empty
SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE prosrc IS NULL OR prosrc = '' OR prosrc = '-'
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- proiswindow shouldn't be set together with proisagg or proretset
SELECT p1.oid, p1.proname
FROM pg_proc AS p1
WHERE proiswindow AND (proisagg OR proretset)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- pronargdefaults should be 0 iff proargdefaults is null
SELECT p1.oid, p1.proname
FROM pg_proc AS p1
WHERE (pronargdefaults <> 0) != (proargdefaults IS NOT NULL)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- probin should be non-empty for C functions, null everywhere else
SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE prolang = 13 AND (probin IS NULL OR probin = '' OR probin = '-')
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE prolang != 13 AND probin IS NOT NULL
ORDER BY p1.oid;
 oid  |     proname     
------+-----------------
 3167 | instr
 3168 | instr
 3169 | instr
 3172 | numtodsinterval
 3189 | numtoday
 3190 | numtoday
 3191 | numtoday
 3205 | substrb
 3206 | substrb
 3842 | numtoday
(10 rows)

-- Look for conflicting proc definitions (same names and input datatypes).
-- (This test should be dead code now that we have the unique index
-- pg_proc_proname_args_nsp_index, but I'll leave it in anyway.)
SELECT p1.oid, p1.proname, p2.oid, p2.proname
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.proname = p2.proname AND
    p1.pronargs = p2.pronargs AND
    p1.proargtypes = p2.proargtypes
ORDER by 1, 2, 3;
  oid  |        proname         |  oid  |        proname         
-------+------------------------+-------+------------------------
 15303 | format_write           | 15364 | format_write
 15316 | sql_set_sql            | 15397 | sql_set_sql
 15317 | sql_run                | 15400 | sql_run
 15318 | sql_unregister_context | 15401 | sql_unregister_context
 15357 | close                  | 15469 | close
 15364 | format_write           | 15303 | format_write
 15385 | substr                 | 15481 | substr
 15386 | substr                 | 15482 | substr
 15397 | sql_set_sql            | 15316 | sql_set_sql
 15400 | sql_run                | 15317 | sql_run
 15401 | sql_unregister_context | 15318 | sql_unregister_context
 15469 | close                  | 15357 | close
 15481 | substr                 | 15385 | substr
 15482 | substr                 | 15386 | substr
(14 rows)

-- Considering only built-in procs (prolang = 12), look for multiple uses
-- of the same internal function (ie, matching prosrc fields).  It's OK to
-- have several entries with different pronames for the same internal function,
-- but conflicts in the number of arguments and other critical items should
-- be complained of.  (We don't check data types here; see next query.)
-- Note: ignore aggregate functions here, since they all point to the same
-- dummy built-in function.
SELECT p1.oid, p1.proname, p2.oid, p2.proname
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid < p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    (p1.proisagg = false OR p2.proisagg = false) AND
    (p1.prolang != p2.prolang OR
     p1.proisagg != p2.proisagg OR
     p1.prosecdef != p2.prosecdef OR
     p1.proisstrict != p2.proisstrict OR
     p1.proretset != p2.proretset OR
     p1.provolatile != p2.provolatile OR
     p1.pronargs != p2.pronargs)
ORDER by 1, 2, 3;
 oid  |    proname     | oid  |    proname     
------+----------------+------+----------------
 3780 | pg_query_audit | 3782 | pg_query_audit
(1 row)

-- Look for uses of different type OIDs in the argument/result type fields
-- for different aliases of the same built-in function.
-- This indicates that the types are being presumed to be binary-equivalent,
-- or that the built-in function is prepared to deal with different types.
-- That's not wrong, necessarily, but we make lists of all the types being
-- so treated.  Note that the expected output of this part of the test will
-- need to be modified whenever new pairs of types are made binary-equivalent,
-- or when new polymorphic built-in functions are added!
-- Note: ignore aggregate functions here, since they all point to the same
-- dummy built-in function.  Likewise, ignore range constructor functions.
SELECT DISTINCT p1.prorettype, p2.prorettype
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    p1.prosrc NOT LIKE E'range\\_constructor_' AND
    p2.prosrc NOT LIKE E'range\\_constructor_' AND
    (p1.prorettype < p2.prorettype)
ORDER BY 1, 2;
 prorettype | prorettype 
------------+------------
         17 |         86
         25 |       1043
       1114 |       1184
(3 rows)

SELECT DISTINCT p1.proargtypes[0], p2.proargtypes[0]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    p1.prosrc NOT LIKE E'range\\_constructor_' AND
    p2.prosrc NOT LIKE E'range\\_constructor_' AND
    (p1.proargtypes[0] < p2.proargtypes[0])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
          17 |          25
          17 |          86
          17 |        4402
          25 |        1042
          25 |        1043
          25 |        4402
        1114 |        1184
        1560 |        1562
        2277 |        2283
(9 rows)

SELECT DISTINCT p1.proargtypes[1], p2.proargtypes[1]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    p1.prosrc NOT LIKE E'range\\_constructor_' AND
    p2.prosrc NOT LIKE E'range\\_constructor_' AND
    (p1.proargtypes[1] < p2.proargtypes[1])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
          20 |          28
          23 |          31
        1114 |        1184
        1560 |        1562
        2277 |        2283
(5 rows)

SELECT DISTINCT p1.proargtypes[2], p2.proargtypes[2]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[2] < p2.proargtypes[2])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
        1114 |        1184
(1 row)

SELECT DISTINCT p1.proargtypes[3], p2.proargtypes[3]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[3] < p2.proargtypes[3])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
        1114 |        1184
(1 row)

SELECT DISTINCT p1.proargtypes[4], p2.proargtypes[4]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[4] < p2.proargtypes[4])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
(0 rows)

SELECT DISTINCT p1.proargtypes[5], p2.proargtypes[5]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[5] < p2.proargtypes[5])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
(0 rows)

SELECT DISTINCT p1.proargtypes[6], p2.proargtypes[6]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[6] < p2.proargtypes[6])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
(0 rows)

SELECT DISTINCT p1.proargtypes[7], p2.proargtypes[7]
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid != p2.oid AND
    p1.prosrc = p2.prosrc AND
    p1.prolang = 12 AND p2.prolang = 12 AND
    NOT p1.proisagg AND NOT p2.proisagg AND
    (p1.proargtypes[7] < p2.proargtypes[7])
ORDER BY 1, 2;
 proargtypes | proargtypes 
-------------+-------------
(0 rows)

-- Look for functions that return type "internal" and do not have any
-- "internal" argument.  Such a function would be a security hole since
-- it might be used to call an internal function from an SQL command.
-- As of 7.3 this query should find only internal_in.
SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE p1.prorettype = 'internal'::regtype AND NOT
    'internal'::regtype = ANY (p1.proargtypes)
ORDER by 1, 2;
 oid  |   proname   
------+-------------
 2304 | internal_in
(1 row)

-- Check for length inconsistencies between the various argument-info arrays.
SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proallargtypes IS NOT NULL AND
    array_length(proallargtypes,1) < array_length(proargtypes,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proargmodes IS NOT NULL AND
    array_length(proargmodes,1) < array_length(proargtypes,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proargnames IS NOT NULL AND
    array_length(proargnames,1) < array_length(proargtypes,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proallargtypes IS NOT NULL AND proargmodes IS NOT NULL AND
    array_length(proallargtypes,1) <> array_length(proargmodes,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proallargtypes IS NOT NULL AND proargnames IS NOT NULL AND
    array_length(proallargtypes,1) <> array_length(proargnames,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

SELECT p1.oid, p1.proname
FROM pg_proc as p1
WHERE proargmodes IS NOT NULL AND proargnames IS NOT NULL AND
    array_length(proargmodes,1) <> array_length(proargnames,1)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- Check for protransform functions with the wrong signature
SELECT p1.oid, p1.proname, p2.oid, p2.proname
FROM pg_proc AS p1, pg_proc AS p2
WHERE p2.oid = p1.protransform AND
    (p2.prorettype != 'internal'::regtype OR p2.proretset OR p2.pronargs != 1
     OR p2.proargtypes[0] != 'internal'::regtype)
ORDER by 1, 2, 3;
 oid | proname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Insist that all built-in pg_proc entries have descriptions
SELECT p1.oid, p1.proname
FROM pg_proc as p1 LEFT JOIN pg_description as d
     ON p1.tableoid = d.classoid and p1.oid = d.objoid and d.objsubid = 0
WHERE d.classoid IS NULL AND p1.oid <= 9999 order by 1;
 oid  |                    proname                    
------+-----------------------------------------------
   58 | xidin4
   59 | xidout4
   78 | char
   89 | version
   90 | opengauss_version
   91 | oidvectorin_extend
   92 | oidvectorout_extend
  195 | pg_node_tree_in
  196 | pg_node_tree_out
  197 | pg_node_tree_recv
  198 | pg_node_tree_send
  240 | abstimein
  241 | abstimeout
  242 | reltimein
  243 | reltimeout
  246 | tintervalin
  247 | tintervalout
  249 | tintervalrel
  250 | timenow
  273 | tintervalend
  275 | isfinite
  276 | btcanreturn
  316 | float8
  320 | width_bucket
  325 | ginbuildempty
  326 | gistbuildempty
  327 | hashbuildempty
  328 | btbuildempty
  330 | btgettuple
  331 | btinsert
  332 | btbulkdelete
  333 | btbeginscan
  334 | btrescan
  335 | btendscan
  336 | btmarkpos
  337 | btrestrpos
  338 | btbuild
  357 | btabstimecmp
  380 | btreltimecmp
  381 | bttintervalcmp
  398 | hashint2vector
  425 | hashvacuumcleanup
  438 | hashcostestimate
  440 | hashgettuple
  441 | hashinsert
  442 | hashbulkdelete
  443 | hashbeginscan
  444 | hashrescan
  445 | hashendscan
  446 | hashmarkpos
  447 | hashrestrpos
  448 | hashbuild
  454 | hashchar
  636 | btgetbitmap
  637 | hashgetbitmap
  638 | gistgetbitmap
  710 | getpgusername
  715 | lo_create
  756 | complex_array_in
  760 | smgrin
  761 | smgrout
  762 | smgreq
  763 | smgrne
  764 | lo_import
  765 | lo_export
  767 | lo_import
  772 | gistcostestimate
  774 | gistgettuple
  775 | gistinsert
  776 | gistbulkdelete
  777 | gistbeginscan
  778 | gistrescan
  779 | gistendscan
  780 | gistmarkpos
  781 | gistrestrpos
  782 | gistbuild
  868 | strpos
  877 | substr
  879 | lpad
  880 | rpad
  883 | substr
  936 | substring
  937 | substring
  940 | mod
  941 | mod
  947 | mod
  952 | lo_open
  953 | lo_close
  954 | loread
  955 | lowrite
  956 | lo_lseek
  957 | lo_creat
  958 | lo_tell
  964 | lo_unlink
  972 | btvacuumcleanup
 1004 | lo_truncate
 1067 | generate_series
 1078 | bpcharcmp
 1085 | date_out
 1092 | date_cmp
 1138 | date_larger
 1139 | date_smaller
 1158 | to_timestamp
 1160 | interval_in
 1173 | timestamptz
 1176 | timestamptz
 1177 | interval
 1179 | date
 1180 | abstime
 1191 | generate_subscripts
 1194 | reltime
 1199 | age
 1268 | btcostestimate
 1344 | sqrt
 1359 | timestamptz
 1364 | time
 1374 | octet_length
 1382 | date_part
 1383 | date_part
 1406 | isvertical
 1407 | ishorizontal
 1408 | isparallel
 1409 | isperp
 1410 | isvertical
 1411 | ishorizontal
 1412 | isparallel
 1413 | isperp
 1414 | isvertical
 1415 | ishorizontal
 1481 | tinterval
 1491 | line_out
 1493 | line
 1500 | turn_off
 1501 | turn_on
 1502 | next
 1503 | abort
 1504 | attach
 1505 | info_locals
 1506 | continue
 1507 | add_breakpoint
 1508 | delete_breakpoint
 1509 | info_breakpoints
 1510 | backtrace
 1511 | info_code
 1512 | step
 1513 | local_debug_server_info
 1515 | print_var
 1516 | enable_breakpoint
 1517 | disable_breakpoint
 1518 | finish
 1519 | set_var
 1520 | info_locals
 1521 | print_var
 1570 | notlike
 1644 | RI_FKey_check_ins
 1645 | RI_FKey_check_upd
 1646 | RI_FKey_cascade_del
 1647 | RI_FKey_cascade_upd
 1648 | RI_FKey_restrict_del
 1649 | RI_FKey_restrict_upd
 1650 | RI_FKey_setnull_del
 1651 | RI_FKey_setnull_upd
 1652 | RI_FKey_setdefault_del
 1653 | RI_FKey_setdefault_upd
 1654 | RI_FKey_noaction_del
 1655 | RI_FKey_noaction_upd
 1705 | abs
 1706 | sign
 1716 | pg_get_expr
 1751 | trunc
 1752 | trunc
 1753 | trunc
 1818 | regexeqsel
 1982 | comm_check_connection_status
 1983 | pg_log_comm_status
 1984 | pg_comm_recv_stream
 1985 | pg_comm_send_stream
 1986 | pg_comm_status
 1987 | pg_comm_delay
 1988 | global_comm_get_recv_stream
 1989 | global_comm_get_send_stream
 1990 | global_comm_get_status
 1991 | comm_client_info
 1992 | global_comm_get_client_info
 1995 | gs_comm_proxy_thread_status
 1998 | pg_get_running_xacts
 1999 | pg_check_xidlimit
 2000 | pg_get_xidlimit
 2007 | like
 2008 | notlike
 2023 | timestamp
 2024 | timestamp
 2025 | timestamp
 2030 | abstime
 2074 | substring
 2085 | substr
 2086 | substr
 2095 | pgxc_gtm_snapshot_status
 2097 | pg_get_variable_info
 2099 | pg_terminate_session
 2173 | pg_stop_backup
 2187 | replace
 2200 | gs_roach_stop_backup
 2201 | gs_roach_enable_delay_ddl_recycle
 2202 | gs_roach_disable_delay_ddl_recycle
 2203 | gs_roach_switch_xlog
 2306 | opaque_in
 2307 | opaque_out
 2310 | sign
 2325 | pg_relation_size
 2344 | date_cmp_timestamp
 2357 | date_cmp_timestamptz
 2370 | timestamp_cmp_date
 2383 | timestamptz_cmp_date
 2412 | bytearecv
 2413 | byteasend
 2428 | point_recv
 2448 | regoperrecv
 2462 | abstimerecv
 2463 | abstimesend
 2464 | reltimerecv
 2465 | reltimesend
 2466 | tintervalrecv
 2467 | tintervalsend
 2469 | date_send
 2487 | poly_send
 2488 | line_recv
 2489 | line_send
 2509 | pg_get_expr
 2561 | gistvacuumcleanup
 2579 | gist_box_compress
 2580 | gist_box_decompress
 2600 | int2vectorin_extend
 2601 | int2vectorout_extend
 2602 | int2vectorrecv_extend
 2603 | int2vectorsend_extend
 2614 | xmlexists
 2731 | gingetbitmap
 2732 | gininsert
 2733 | ginbeginscan
 2734 | ginrescan
 2735 | ginendscan
 2736 | ginmarkpos
 2737 | ginrestrpos
 2738 | ginbuild
 2739 | ginbulkdelete
 2740 | ginvacuumcleanup
 2741 | gincostestimate
 2746 | int8_avg_accum
 2779 | xidrecv4
 2780 | xidsend4
 2785 | btoptions
 2786 | hashoptions
 2787 | gistoptions
 2788 | ginoptions
 2846 | pg_stat_get_mem_mbytes_reserved
 2847 | gs_total_nodegroup_memory_detail
 2848 | pg_switch_xlog
 2849 | pg_current_xlog_location
 2850 | pg_xlogfile_name_offset
 2851 | pg_xlogfile_name
 2852 | pg_current_xlog_insert_location
 2853 | pg_stat_get_backend_waiting
 2860 | gs_current_xlog_insert_end_location
 2861 | gs_stat_wal_entrytable
 2862 | gs_walwriter_flush_position
 2863 | gs_walwriter_flush_stat
 2893 | xml_in
 2894 | xml_out
 2895 | xmlcomment
 2896 | xml
 2897 | xmlvalidate
 2898 | xml_recv
 2899 | xml_send
 2900 | xmlconcat2
 2901 | xmlagg
 2922 | text
 2939 | txid_snapshot_in
 2940 | txid_snapshot_out
 2941 | txid_snapshot_recv
 2942 | txid_snapshot_send
 2943 | txid_current
 2944 | txid_current_snapshot
 2945 | txid_snapshot_xmin
 2946 | txid_snapshot_xmax
 2947 | txid_snapshot_xip
 2948 | txid_visible_in_snapshot
 2949 | pgxc_snapshot_status
 2964 | numeric_avg_collect
 2965 | int8_avg_collect
 2966 | float8_collect
 2967 | interval_collect
 2968 | numeric_collect
 2995 | float8_regr_collect
 2996 | int8_sum_to_int8
 3050 | xpath_exists
 3051 | xml_is_well_formed
 3052 | xml_is_well_formed_document
 3053 | xml_is_well_formed_content
 3071 | pg_xlog_replay_pause
 3072 | pg_xlog_replay_resume
 3073 | pg_is_xlog_replay_paused
 3080 | pg_sequence_last_value
 3097 | varchar_transform
 3122 | oidvectorrecv_extend
 3123 | oidvectorsend_extend
 3124 | json_agg
 3125 | json_agg_finalfn
 3126 | json_agg_transfn
 3127 | json_array_elements_text
 3128 | json_array_length
 3157 | numeric_transform
 3158 | varbit_transform
 3164 | pg_sync_cstore_delta
 3165 | pg_xlog_location_diff
 3167 | instr
 3168 | instr
 3169 | instr
 3170 | multiply
 3171 | multiply
 3172 | numtodsinterval
 3176 | lengthb
 3177 | int8_bool
 3178 | bool_int8
 3179 | array_extend
 3180 | int2_bool
 3181 | bool_int2
 3184 | btmerge
 3185 | hashmerge
 3186 | ginmerge
 3187 | gistmerge
 3188 | spgmerge
 3189 | numtoday
 3190 | numtoday
 3191 | numtoday
 3192 | int4_bpchar
 3193 | pg_partition_size
 3194 | pg_partition_size
 3195 | pg_partition_indexes_size
 3196 | pg_partition_indexes_size
 3197 | pg_partition_filenode
 3198 | convert_to_nocase
 3199 | get_prepared_pending_xid
 3200 | pgxc_pool_check
 3201 | pgxc_pool_reload
 3202 | pgxc_node_str
 3203 | pgxc_is_committed
 3204 | pgxc_lock_for_backup
 3205 | substrb
 3206 | substrb
 3207 | to_timestamp
 3210 | pg_relation_with_compression
 3211 | pg_relation_compression_ratio
 3212 | pg_parse_clog
 3213 | pg_cancel_invalid_query
 3214 | bigint_tid
 3215 | cstore_tid_out
 3216 | definer_current_user
 3217 | cupointer_bigint
 3218 | pg_stat_bad_block
 3219 | pg_stat_bad_block_clear
 3220 | pg_partition_filepath
 3221 | pg_stat_get_tuples_changed
 3222 | pg_total_autovac_tuples
 3223 | pg_autovac_status
 3226 | timestamp_diff
 3227 | timestamp_diff
 3228 | pg_check_authid
 3238 | json_build_array
 3239 | json_build_array
 3250 | local_recovery_status
 3258 | json_each
 3259 | json_each_text
 3260 | json_build_object
 3261 | json_build_object
 3262 | json_extract_path
 3264 | json_extract_path_text
 3265 | pg_current_userid
 3266 | pg_current_sessionid
 3267 | pg_current_sessid
 3270 | json_typeof
 3299 | local_rto_stat
 3316 | pg_get_flush_lsn
 3317 | pg_get_sync_flush_lsn
 3332 | get_local_prepared_xact
 3333 | get_remote_prepared_xacts
 3334 | global_clean_prepared_xacts
 3401 | json_object
 3402 | json_object
 3403 | json_object_agg
 3404 | json_object_agg_finalfn
 3405 | json_object_agg_transfn
 3407 | json_object_keys
 3408 | json_populate_record
 3409 | json_populate_recordset
 3410 | json_to_record
 3411 | json_to_recordset
 3414 | jsonb_array_elements
 3415 | jsonb_array_elements_text
 3416 | jsonb_array_length
 3417 | jsonb_cmp
 3419 | jsonb_each
 3420 | jsonb_each_text
 3425 | jsonb_extract_path
 3426 | jsonb_extract_path_text
 3430 | jsonb_hash
 3435 | jsonb_object_keys
 3436 | jsonb_out
 3437 | jsonb_populate_record
 3438 | jsonb_populate_recordset
 3443 | jsonb_recv
 3444 | jsonb_send
 3445 | jsonb_typeof
 3446 | to_json
 3464 | gs_encrypt_aes128
 3465 | gs_decrypt_aes128
 3466 | check_engine_status
 3467 | encode_plan_node
 3468 | track_model_train_opt
 3469 | gs_password_deadline
 3470 | gs_password_notifytime
 3471 | pg_pool_validate
 3472 | pg_pool_ping
 3475 | rawcmp
 3478 | rawcat
 3480 | pg_stat_get_cu_mem_hit
 3481 | model_train_opt
 3482 | gin_extract_jsonb
 3483 | pg_stat_get_cu_hdd_sync
 3484 | pg_stat_get_cu_hdd_asyn
 3485 | pg_stat_get_db_cu_mem_hit
 3486 | gin_extract_jsonb_query_hash
 3487 | gin_consistent_jsonb_hash
 3488 | pg_stat_get_db_cu_hdd_sync
 3489 | pg_stat_get_db_cu_hdd_asyn
 3492 | gin_extract_jsonb_hash
 3493 | gin_extract_jsonb_query
 3494 | gin_triconsistent_jsonb
 3495 | gin_triconsistent_jsonb_hash
 3497 | gin_consistent_jsonb
 3498 | gin_compare_jsonb
 3499 | pg_stat_get_stream_replications
 3500 | pg_stat_get_realtime_info_internal
 3501 | pg_stat_get_wlm_statistics
 3502 | pg_stat_get_session_wlmstat
 3503 | pg_wlm_jump_queue
 3534 | pg_sync_cstore_delta
 3549 | json_array_elements
 3550 | list_agg_transfn
 3551 | list_agg_finalfn
 3553 | list_agg_noarg2_transfn
 3555 | int2_list_agg_transfn
 3557 | int2_list_agg_noarg2_transfn
 3559 | int4_list_agg_transfn
 3561 | int4_list_agg_noarg2_transfn
 3563 | int8_list_agg_transfn
 3565 | int8_list_agg_noarg2_transfn
 3567 | float4_list_agg_transfn
 3569 | float4_list_agg_noarg2_transfn
 3571 | float8_list_agg_transfn
 3573 | float8_list_agg_noarg2_transfn
 3575 | numeric_list_agg_transfn
 3577 | numeric_list_agg_noarg2_transfn
 3579 | date_list_agg_transfn
 3581 | date_list_agg_noarg2_transfn
 3583 | timestamp_list_agg_transfn
 3585 | timestamp_list_agg_noarg2_transfn
 3587 | timestamptz_list_agg_transfn
 3589 | timestamptz_list_agg_noarg2_transfn
 3591 | pgxc_get_thread_wait_status
 3596 | pg_get_gtt_relstats
 3597 | pg_get_gtt_statistics
 3598 | pg_gtt_attached_pid
 3599 | pg_list_gtt_relfrozenxids
 3696 | gtsquery_decompress
 3780 | pg_query_audit
 3781 | pg_delete_audit
 3782 | pg_query_audit
 3785 | pg_stat_get_data_senders
 3786 | ngram_start
 3787 | ngram_nexttoken
 3788 | ngram_end
 3789 | ngram_lextype
 3790 | pg_create_physical_replication_slot_extern
 3792 | zhprs_start
 3793 | zhprs_getlexeme
 3794 | zhprs_end
 3795 | zhprs_lextype
 3798 | pound_start
 3799 | pound_nexttoken
 3800 | pound_end
 3801 | pound_lextype
 3803 | gs_stat_get_hotkeys_info
 3805 | gs_stat_clean_hotkeys
 3806 | jsonb_in
 3808 | to_char
 3813 | to_char
 3814 | empty_blob
 3820 | pg_last_xlog_receive_location
 3821 | pg_last_xlog_replay_location
 3842 | numtoday
 3843 | pg_control_group_config
 3877 | range_gist_compress
 3878 | range_gist_decompress
 3900 | global_stat_clean_hotkeys
 3903 | global_stat_get_hotkeys_info
 3917 | timestamp_transform
 3918 | interval_transform
 3925 | daterange_subdiff
 3941 | daterange
 3942 | daterange
 3944 | time_transform
 3947 | pg_stat_get_sql_count
 3950 | node_oid_name
 3951 | pg_systimestamp
 3952 | tablespace_oid_name
 3953 | get_schema_oid
 3954 | pgxc_pool_connection_status
 3955 | pg_stat_get_pooler_status
 3956 | threadpool_status
 3957 | plancache_status
 3958 | plancache_clean
 3959 | prepare_statement_status
 3960 | pgxc_get_csn
 3961 | nvarchar2
 3962 | nvarchar2in
 3963 | nvarchar2out
 3964 | nvarchar2typmodin
 3965 | nvarchar2typmodout
 3966 | nvarchar2recv
 3967 | nvarchar2send
 3968 | pv_thread_memory_detail
 3969 | pv_instance_time
 3970 | pv_os_run_info
 3971 | pv_session_memory_detail
 3972 | pv_session_time
 3973 | pg_stat_get_redo_stat
 3974 | pv_session_stat
 3975 | pg_stat_get_file_stat
 3976 | total_cpu
 3977 | get_hostname
 3978 | sessionid2pid
 3979 | total_memory
 3980 | pg_stat_get_status
 3981 | pg_stat_get_thread
 3982 | pg_stat_get_env
 3983 | pv_session_memctx_detail
 3984 | pv_session_memory
 3985 | pv_total_memory_detail
 3986 | pg_shared_memory_detail
 3987 | pg_shared_memctx_detail
 3988 | track_memory_context
 3990 | track_memory_context_detail
 3991 | pg_cancel_session
 3998 | update_pgjob
 3999 | pg_tde_info
 4000 | gs_fault_inject
 4001 | spggettuple
 4002 | spggetbitmap
 4003 | spginsert
 4004 | spgbeginscan
 4005 | spgrescan
 4006 | spgendscan
 4007 | spgmarkpos
 4008 | spgrestrpos
 4009 | spgbuild
 4010 | spgbuildempty
 4011 | spgbulkdelete
 4012 | spgvacuumcleanup
 4013 | spgcostestimate
 4014 | spgoptions
 4032 | spgcanreturn
 4035 | rawin
 4036 | rawout
 4037 | rawtohex
 4038 | hextoraw
 4040 | psortbuild
 4041 | psortoptions
 4042 | psortgettuple
 4043 | psortgetbitmap
 4044 | psortcostestimate
 4045 | psortcanreturn
 4046 | getbucket
 4047 | getdistributekey
 4048 | table_data_skewness
 4049 | gs_switch_relfilenode
 4065 | int1_varchar
 4066 | int1_nvarchar2
 4067 | int1_bpchar
 4068 | int2_bpchar
 4069 | int8_bpchar
 4070 | float4_bpchar
 4071 | float8_bpchar
 4072 | numeric_bpchar
 4073 | text_timestamp
 4074 | add_months
 4075 | last_day
 4076 | next_day
 4077 | next_day
 4080 | pg_autovac_timeout
 4081 | pg_autovac_coordinator
 4086 | pg_stat_get_partition_tuples_changed
 4087 | pg_stat_get_partition_dead_tuples
 4088 | pg_stat_get_partition_tuples_inserted
 4089 | pg_stat_get_partition_tuples_updated
 4090 | pg_stat_get_partition_tuples_deleted
 4091 | pg_stat_get_partition_tuples_hot_updated
 4092 | pg_stat_get_partition_live_tuples
 4093 | pg_stat_get_xact_partition_tuples_deleted
 4094 | pg_stat_get_xact_partition_tuples_inserted
 4095 | pg_stat_get_xact_partition_tuples_updated
 4096 | pg_stat_get_xact_partition_tuples_hot_updated
 4100 | getbucket
 4101 | bucketint4
 4102 | getbucket
 4103 | bucketint2
 4104 | getbucket
 4105 | bucketint8
 4106 | getbucket
 4107 | bucketbpchar
 4108 | getbucket
 4109 | bucketchar
 4110 | getbucket
 4111 | bucketvarchar
 4112 | getbucket
 4113 | bucketdate
 4114 | getbucket
 4115 | buckettime
 4116 | getbucket
 4117 | buckettimestamp
 4118 | getbucket
 4119 | buckettimetz
 4120 | getbucket
 4121 | bucketinterval
 4122 | getbucket
 4123 | buckettimestamptz
 4124 | getbucket
 4125 | bucketint1
 4126 | getbucket
 4127 | bucketsmalldatetime
 4128 | getbucket
 4129 | bucketnvarchar2
 4130 | pg_buffercache_pages
 4131 | getbucket
 4132 | bucketnumeric
 4133 | getbucket
 4134 | bucketoid
 4135 | getbucket
 4136 | bucketabstime
 4137 | getbucket
 4138 | bucketreltime
 4139 | getbucket
 4140 | bucketcash
 4141 | getbucket
 4142 | bucketbytea
 4143 | getbucket
 4144 | bucketraw
 4145 | getbucket
 4146 | bucketbool
 4147 | getbucket
 4148 | bucketname
 4149 | getbucket
 4150 | bucketint2vector
 4151 | getbucket
 4152 | buckettext
 4153 | getbucket
 4154 | bucketoidvector
 4155 | getbucket
 4156 | bucketfloat4
 4157 | getbucket
 4158 | bucketfloat8
 4159 | date_text
 4160 | date_bpchar
 4161 | date_varchar
 4162 | varchar_date
 4163 | bpchar_date
 4164 | text_date
 4165 | int1_text
 4166 | int2_text
 4167 | int4_text
 4168 | int8_text
 4169 | float4_text
 4170 | float8_text
 4171 | numeric_text
 4172 | bpchar_numeric
 4173 | varchar_numeric
 4174 | varchar_int4
 4175 | bpchar_int4
 4176 | varchar_int8
 4177 | timestampzone_text
 4178 | timestamp_text
 4179 | timestamp_varchar
 4180 | int2_varchar
 4181 | int4_varchar
 4182 | int8_varchar
 4183 | numeric_varchar
 4184 | float4_varchar
 4185 | float8_varchar
 4186 | varchar_timestamp
 4187 | bpchar_timestamp
 4188 | text_int1
 4189 | text_int2
 4190 | text_int4
 4191 | text_int8
 4192 | text_float4
 4193 | text_float8
 4194 | text_numeric
 4195 | bpchar_int8
 4196 | bpchar_float4
 4197 | bpchar_float8
 4198 | varchar_float4
 4199 | varchar_float8
 4200 | plan_seed
 4201 | has_nodegroup_privilege
 4202 | has_nodegroup_privilege
 4203 | has_nodegroup_privilege
 4204 | has_nodegroup_privilege
 4205 | has_nodegroup_privilege
 4206 | has_nodegroup_privilege
 4207 | fenced_udf_process
 4208 | get_db_source_datasize
 4209 | pg_clean_region_info
 4210 | gs_extend_library
 4212 | pg_stat_get_activity_with_conninfo
 4213 | pg_stat_get_activity_for_temptable
 4221 | disable_conn
 4222 | read_disable_conn_file
 4229 | float8_interval
 4240 | cbtreebuild
 4241 | cbtreeoptions
 4242 | cbtreegettuple
 4243 | cbtreecostestimate
 4244 | exec_on_extension
 4245 | cbtreecanreturn
 4246 | cbtreegetbitmap
 4255 | exec_hadoop_sql
 4300 | pv_compute_pool_workload
 4305 | hll_in
 4306 | hll_out
 4307 | hll_recv
 4308 | hll_send
 4309 | hll_typmod_in
 4310 | hll_typmod_out
 4311 | hll
 4312 | hll_hashval_in
 4313 | hll_hashval_out
 4316 | hll_hashval
 4317 | hll_hashval_int4
 4324 | hll_print
 4325 | hll_empty
 4326 | hll_empty
 4327 | hll_empty
 4328 | hll_empty
 4329 | hll_empty
 4330 | hll_schema_version
 4331 | hll_type
 4332 | hll_log2m
 4333 | hll_regwidth
 4334 | hll_expthresh
 4335 | hll_sparseon
 4336 | hll_add_trans1
 4337 | hll_add_trans2
 4338 | hll_add_trans3
 4339 | hll_hash_boolean
 4340 | hll_hash_smallint
 4341 | hll_hash_integer
 4342 | hll_hash_bigint
 4343 | hll_hash_bytea
 4344 | hll_hash_text
 4345 | hll_hash_any
 4346 | hll_union_trans
 4348 | hll_union_collect
 4350 | hll_duplicatecheck
 4351 | hll_add_trans0
 4352 | hll_pack
 4353 | hll_hash_boolean
 4354 | hll_hash_smallint
 4355 | hll_hash_integer
 4356 | hll_hash_bigint
 4357 | hll_hash_bytea
 4358 | hll_hash_text
 4359 | hll_hash_any
 4360 | hll_add_trans4
 4361 | local_pagewriter_stat
 4362 | hll_trans_recv
 4363 | hll_trans_send
 4364 | hll_trans_in
 4365 | hll_trans_out
 4368 | remote_pagewriter_stat
 4369 | hll_hash_byteawithoutorderwithequalcol
 4371 | local_ckpt_stat
 4372 | remote_ckpt_stat
 4373 | local_bgwriter_stat
 4374 | remote_bgwriter_stat
 4375 | local_single_flush_dw_stat
 4376 | remote_single_flush_dw_stat
 4377 | local_candidate_stat
 4378 | hll_log2explicit
 4379 | hll_log2sparse
 4384 | local_double_write_stat
 4385 | remote_double_write_stat
 4386 | remote_candidate_stat
 4388 | local_redo_stat
 4389 | remote_redo_stat
 4396 | pg_export_snapshot_and_csn
 4400 | cginbuild
 4401 | cgingetbitmap
 4410 | pgxc_stat_dirty_tables
 4411 | pgxc_stat_dirty_tables
 4418 | byteawithoutorderwithequalcolcmp
 4423 | byteawithoutordercolin
 4424 | byteawithoutordercolrecv
 4425 | byteawithoutordercolsend
 4428 | byteawithoutordercolout
 4430 | gs_undo_meta
 4431 | gs_undo_translot
 4434 | gs_stat_undo
 4435 | gs_upload_obs_file
 4436 | gs_download_obs_file
 4440 | byteawithoutorderwithequalcolin
 4441 | table_distribution
 4442 | table_distribution
 4443 | pg_get_tabledef
 4444 | byteawithoutorderwithequalcolrecv
 4445 | pg_resume_bkp_flag
 4446 | byteawithoutorderwithequalcolout
 4449 | byteawithoutorderwithequalcoltypmodin
 4450 | byteawithoutorderwithequalcoltypmodout
 4451 | byteawithoutorderwithequalcolsend
 4456 | byteawithoutorderwithequalcolcmpbytear
 4463 | byteawithoutorderwithequalcolcmpbyteal
 4500 | gs_control_group_info
 4501 | gs_respool_exception_info
 4502 | gs_all_control_group_info
 4503 | gs_cgroup_map_ng_conf
 4504 | gs_all_nodegroup_control_group_info
 4505 | interval_list_agg_transfn
 4507 | interval_list_agg_noarg2_transfn
 4520 | gs_stat_activity_timeout
 4579 | gs_get_active_archiving_standby
 4580 | gs_pitr_archive_slot_force_advance
 4581 | gs_pitr_clean_history_global_barriers
 4582 | gs_pitr_get_warning_for_xlog_force_recycle
 4601 | checksumtext_agg_transfn
 4650 | gs_paxos_stat_replication
 4651 | pg_cbm_tracked_location
 4652 | pg_cbm_get_merged_file
 4653 | pg_cbm_get_changed_block
 4654 | pg_cbm_recycle_file
 4655 | pg_cbm_force_track
 4656 | pg_enable_delay_ddl_recycle
 4657 | pg_disable_delay_ddl_recycle
 4658 | pg_enable_delay_xlog_recycle
 4659 | pg_disable_delay_xlog_recycle
 4660 | pg_cbm_rotate_file
 4700 | has_directory_privilege
 4701 | has_directory_privilege
 4702 | has_directory_privilege
 4703 | has_directory_privilege
 4704 | has_directory_privilege
 4705 | has_directory_privilege
 4750 | ubtinsert
 4751 | ubtbeginscan
 4752 | ubtgettuple
 4753 | ubtgetbitmap
 4754 | ubtrescan
 4755 | ubtendscan
 4756 | ubtmarkpos
 4757 | ubtrestrpos
 4758 | ubtmerge
 4759 | ubtbuild
 4760 | ubtbuildempty
 4761 | ubtbulkdelete
 4762 | ubtvacuumcleanup
 4763 | ubtcanreturn
 4764 | ubtoptions
 4765 | ubtcostestimate
 4767 | gs_read_block_from_remote
 4768 | gs_read_block_from_remote
 4789 | remote_rto_stat
 4800 | job_cancel
 4801 | job_finish
 4802 | job_submit
 4803 | job_update
 4805 | delta
 4888 | gs_index_advise
 4889 | hypopg_create_index
 4890 | hypopg_display_index
 4891 | hypopg_drop_index
 4892 | hypopg_estimate_size
 4893 | hypopg_reset_index
 4895 | gs_is_recycle_object
 4999 | remote_recovery_status
 5000 | get_instr_workload_info
 5001 | pg_stat_get_wlm_session_info_internal
 5002 | pg_stat_get_wlm_session_info
 5003 | pg_stat_get_wlm_realtime_session_info
 5004 | gs_wlm_get_resource_pool_info
 5005 | gs_wlm_switch_cgroup
 5006 | gs_wlm_rebuild_user_resource_pool
 5007 | gs_wlm_get_user_info
 5008 | pg_stat_get_cgroup_info
 5009 | gs_wlm_get_session_info
 5010 | pg_stat_get_role_name
 5011 | gs_wlm_readjust_user_space
 5012 | gs_wlm_user_resource_info
 5013 | pg_user_iostat
 5014 | pg_stat_get_wlm_session_iostat_info
 5015 | get_nodename
 5016 | gs_wlm_node_clean
 5017 | gs_wlm_node_recover
 5018 | gs_wlm_get_workload_records
 5019 | pg_stat_get_wlm_node_resource_info
 5020 | gs_wlm_get_user_session_info
 5021 | gs_wlm_session_respool
 5022 | pg_stat_get_wlm_realtime_operator_info
 5023 | pg_stat_get_wlm_operator_info
 5024 | pg_stat_get_wlm_ec_operator_info
 5025 | pg_stat_get_wlm_realtime_ec_operator_info
 5026 | pg_stat_get_workload_struct_info
 5027 | gs_get_nodegroup_tablecount
 5028 | pgxc_max_datanode_size
 5029 | gs_wlm_readjust_user_space_with_reset_flag
 5030 | gs_wlm_readjust_user_space_through_username
 5031 | pg_stat_get_wlm_instance_info
 5032 | pg_stat_get_wlm_instance_info_with_cleanup
 5033 | gs_stat_get_wlm_plan_operator_info
 5034 | gs_io_wait_status
 5035 | pg_get_indexdef
 5077 | gs_hadr_local_rto_and_rpo_stat
 5078 | gs_hadr_remote_rto_and_rpo_stat
 5128 | gs_get_obs_file_context
 5129 | gs_set_obs_file_context
 5130 | gs_get_hadr_key_cn
 5255 | pg_shared_memctx_view
 5256 | pg_thread_memctx_view
 5345 | pv_builtin_functions
 5519 | int1cmp
 5520 | hashint1
 5521 | int1_numeric
 5522 | numeric_int1
 5523 | i1toi2
 5524 | i2toi1
 5525 | i1toi4
 5526 | i4toi1
 5527 | i1toi8
 5528 | i8toi1
 5529 | i1tof4
 5530 | f4toi1
 5531 | i1tof8
 5532 | f8toi1
 5533 | int1_bool
 5534 | bool_int1
 5541 | int1in
 5542 | int1out
 5543 | int1recv
 5544 | int1send
 5548 | int1_avg_accum
 5549 | pg_stat_get_activity_ng
 5557 | median_float8_finalfn
 5558 | median_interval_finalfn
 5559 | median_transfn
 5560 | to_date
 5586 | smalldatetime_cmp
 5587 | smalldatetime_hash
 5600 | pg_stat_get_last_data_changed_time
 5601 | pg_stat_set_last_data_changed_time
 5681 | get_dn_hist_relhash
 5682 | ledger_gchain_check
 5683 | ledger_hist_archive
 5684 | ledger_gchain_archive
 5685 | ledger_hist_repair
 5686 | ledger_gchain_repair
 5702 | get_instr_unique_sql
 5703 | generate_wdr_report
 5705 | get_instr_wait_event
 5706 | get_instr_user_login
 5708 | get_local_rel_iostat
 5711 | create_wdr_snapshot
 5712 | get_instr_rt_percentile
 5713 | wdr_xdb_query
 5714 | kill_snapshot
 5716 | reset_unique_sql
 5717 | submit_on_nodes
 5718 | isubmit_on_nodes
 5719 | capture_view_to_json
 5720 | get_node_stat_reset_time
 5721 | get_local_active_session
 5722 | ledger_hist_check
 5723 | get_wait_event_info
 5730 | locktag_decode
 5731 | working_version_num
 5732 | statement_detail_decode
 5733 | dynamic_func_control
 5812 | hash16in
 5813 | hash16out
 5814 | hash32in
 5815 | hash32out
 5997 | gs_mark_indisvalid
 5998 | gs_deployment
 5999 | get_gtm_lite_status
 6000 | getbucket
 6001 | bucketuuid
 6003 | pg_get_replication_slot_name
 6009 | array_exists
 6010 | array_next
 6011 | array_prior
 6012 | array_delete
 6013 | array_trim
 6014 | array_extendnull
 6015 | array_deleteidx
 6101 | int1and
 6102 | int1or
 6103 | int1xor
 6104 | int1not
 6105 | int1shl
 6106 | int1shr
 6107 | int1up
 6108 | int1um
 6109 | int1pl
 6110 | int1mi
 6111 | int1mul
 6112 | int1div
 6113 | int1abs
 6114 | int1mod
 6115 | int1larger
 6116 | int1smaller
 6117 | int1inc
 6118 | set_hashbucket_info
 6200 | mot_session_memory_detail
 6201 | mot_global_memory_detail
 6202 | mot_local_memory_detail
 6203 | pg_start_backup
 6204 | pg_stop_backup
 6224 | gs_get_next_xid_csn
 6321 | pg_stat_file_recursive
 6322 | gs_decrypt
 6323 | gs_encrypt
 6401 | int16in
 6402 | int16out
 6403 | int16recv
 6404 | int16send
 6405 | int16
 6406 | i16toi1
 6407 | int16
 6408 | int2
 6409 | int16
 6410 | int4
 6411 | int16
 6412 | int8
 6413 | int16
 6414 | float8
 6415 | int16
 6416 | float4
 6417 | int16
 6418 | oid
 6419 | int16
 6420 | int16_bool
 6421 | int16
 6422 | numeric
 6433 | numeric
 6434 | numeric_bool
 6555 | array_remove
 6556 | array_replace
 6558 | first_transition
 6559 | last_transition
 6560 | first
 6561 | last
 6666 | network_larger
 6667 | network_smaller
 6668 | max
 6669 | min
 7001 | pg_stat_segment_extent_usage
 7002 | gs_space_shrink
 7003 | pg_stat_remain_segment_info
 7004 | pg_free_remain_segment
 7005 | local_segment_space_info
 7006 | local_space_shrink
 7007 | remote_segment_space_info
 7008 | global_space_shrink
 7101 | db4ai_predict_by_bool
 7102 | db4ai_predict_by_int32
 7103 | db4ai_predict_by_int64
 7105 | db4ai_predict_by_float4
 7106 | db4ai_predict_by_float8
 7107 | db4ai_predict_by_numeric
 7108 | db4ai_predict_by_text
 7109 | db4ai_predict_by_float8_array
 7777 | sysdate
 7800 | init
 7801 | analyze_query
 7802 | get_analyzed_result
 7803 | run
 7804 | clean
 7805 | assign_table_type
 7806 | clean_workload
 7807 | get_distribution_key
 7808 | set_weight_params
 7809 | set_cost_params
 7810 | start_collect_workload
 7811 | end_collect_workload
 7812 | analyze_workload
 7881 | array_varchar_next
 7882 | array_varchar_exists
 7883 | array_varchar_prior
 7886 | array_varchar_deleteidx
 7893 | gs_stat_ustore
 7998 | set_working_grand_version_num_manually
 8001 | get_paxos_replication_info
 8050 | datalength
 8413 | pg_read_binary_file_blocks
 8642 | gs_txid_oldestxmin
 8700 | array_cat_distinct
 8701 | array_intersect
 8702 | array_intersect_distinct
 8703 | array_except
 8704 | array_except_distinct
 9004 | smalldatetime_in
 9006 | smalldatetime_out
 9007 | smalldatetime_recv
 9008 | smalldatetime_send
 9011 | smalldatetime_smaller
 9012 | smalldatetime_larger
 9014 | pgxc_lock_for_sp_database
 9015 | pg_advisory_unlock
 9016 | pg_advisory_lock
 9017 | pgxc_unlock_for_sp_database
 9018 | pgxc_lock_for_transfer
 9019 | pgxc_unlock_for_transfer
 9024 | has_cmk_privilege
 9025 | has_cmk_privilege
 9026 | has_cmk_privilege
 9027 | has_cmk_privilege
 9028 | has_cmk_privilege
 9029 | has_cmk_privilege
 9031 | gs_set_obs_delete_location
 9032 | gs_get_global_barrier_status
 9033 | gs_get_local_barrier_status
 9034 | gs_get_global_barriers_status
 9035 | gs_set_obs_delete_location_with_slotname
 9037 | gs_set_standby_cluster_target_barrier_id
 9038 | gs_query_standby_cluster_barrier_id_exist
 9039 | gs_get_standby_cluster_barrier_status
 9036 | gs_gsc_clean
 9037 | gs_gsc_dbstat_info
 9130 | has_cek_privilege
 9131 | has_cek_privilege
 9132 | has_cek_privilege
 9133 | has_cek_privilege
 9134 | has_cek_privilege
 9135 | has_cek_privilege
 9136 | gs_hadr_do_switchover
 9137 | gs_hadr_has_barrier_creator
 9138 | gs_hadr_in_recovery
 9139 | gs_streaming_dr_get_switchover_barrier
 9140 | gs_streaming_dr_in_switchover
 9141 | gs_streaming_dr_service_truncation_check
 9350 | sys_connect_by_path
 9351 | connect_by_root
 9982 | tdigest_mergep
 9983 | tdigest_in
 9984 | tdigest_out
 9985 | calculate_value_at
 9986 | value_of_percentile
 9987 | calculate_quantile_of
 9988 | tdigest_merge_to_one
 9989 | tdigest_merge
 9990 | percentile_of_value
 9999 | pg_test_err_contain_err
--?.*

-- **************** pg_cast ****************
-- Catch bogus values in pg_cast columns (other than cases detected by
-- oidjoins test).
SELECT *
FROM pg_cast c
WHERE castsource = 0 OR casttarget = 0 OR castcontext NOT IN ('e', 'a', 'i')
    OR castmethod NOT IN ('f', 'b' ,'i')
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

-- Check that castfunc is nonzero only for cast methods that need a function,
-- and zero otherwise
SELECT *
FROM pg_cast c
WHERE (castmethod = 'f' AND castfunc = 0)
   OR (castmethod IN ('b', 'i') AND castfunc <> 0)
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

-- Look for casts to/from the same type that aren't length coercion functions.
-- (We assume they are length coercions if they take multiple arguments.)
-- Such entries are not necessarily harmful, but they are useless.
SELECT *
FROM pg_cast c
WHERE castsource = casttarget AND castfunc = 0
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

SELECT c.*
FROM pg_cast c, pg_proc p
WHERE c.castfunc = p.oid AND p.pronargs < 2 AND castsource = casttarget
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

-- Look for cast functions that don't have the right signature.  The
-- argument and result types in pg_proc must be the same as, or binary
-- compatible with, what it says in pg_cast.
-- As a special case, we allow casts from CHAR(n) that use functions
-- declared to take TEXT.  This does not pass the binary-coercibility test
-- because CHAR(n)-to-TEXT normally invokes rtrim().  However, the results
-- are the same, so long as the function is one that ignores trailing blanks.
SELECT c.*
FROM pg_cast c, pg_proc p
WHERE c.castfunc = p.oid AND
    (p.pronargs < 1 OR p.pronargs > 3
     OR NOT (binary_coercible(c.castsource, p.proargtypes[0])
             OR (c.castsource = 'character'::regtype AND
                 p.proargtypes[0] = 'text'::regtype))
     OR NOT binary_coercible(p.prorettype, c.casttarget))
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

SELECT c.*
FROM pg_cast c, pg_proc p
WHERE c.castfunc = p.oid AND
    ((p.pronargs > 1 AND p.proargtypes[1] != 'int4'::regtype) OR
     (p.pronargs > 2 AND p.proargtypes[2] != 'bool'::regtype))
ORDER by 1, 2, 3;
 castsource | casttarget | castfunc | castcontext | castmethod | castowner 
------------+------------+----------+-------------+------------+-----------
(0 rows)

-- Look for binary compatible casts that do not have the reverse
-- direction registered as well, or where the reverse direction is not
-- also binary compatible.  This is legal, but usually not intended.
-- As of 7.4, this finds the casts from text and varchar to bpchar, because
-- those are binary-compatible while the reverse way goes through rtrim().
-- As of 8.2, this finds the cast from cidr to inet, because that is a
-- trivial binary coercion while the other way goes through inet_to_cidr().
-- As of 8.3, this finds the casts from xml to text, varchar, and bpchar,
-- because those are binary-compatible while the reverse goes through
-- texttoxml(), which does an XML syntax check.
-- As of 9.1, this finds the cast from pg_node_tree to text, which we
-- intentionally do not provide a reverse pathway for.
SELECT castsource::regtype, casttarget::regtype, castfunc, castcontext
FROM pg_cast c
WHERE c.castmethod = 'b' AND
    NOT EXISTS (SELECT 1 FROM pg_cast k
                WHERE k.castmethod = 'b' AND
                    k.castsource = c.casttarget AND
                    k.casttarget = c.castsource)
ORDER by 1, 2, 3;
          castsource           |    casttarget     | castfunc | castcontext 
-------------------------------+-------------------+----------+-------------
 bytea                         | hll               |        0 | e
 bigint                        | hll_hashval       |        0 | e
 text                          | character         |        0 | i
 clob                          | character         |        0 | i
 xml                           | text              |        0 | a
 xml                           | clob              |        0 | a
 xml                           | character         |        0 | a
 xml                           | character varying |        0 | a
 xml                           | nvarchar2         |        0 | a
 pg_node_tree                  | text              |        0 | i
 pg_node_tree                  | clob              |        0 | i
 cidr                          | inet              |        0 | i
 character varying             | character         |        0 | i
 nvarchar2                     | character         |        0 | i
 byteawithoutorderwithequalcol | hll               |        0 | e
(15 rows)

-- **************** pg_operator ****************
-- Look for illegal values in pg_operator fields.
SELECT p1.oid, p1.oprname
FROM pg_operator as p1
WHERE (p1.oprkind != 'b' AND p1.oprkind != 'l' AND p1.oprkind != 'r') OR
    p1.oprresult = 0 OR p1.oprcode = 0
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- Look for missing or unwanted operand types
SELECT p1.oid, p1.oprname
FROM pg_operator as p1
WHERE (p1.oprleft = 0 and p1.oprkind != 'l') OR
    (p1.oprleft != 0 and p1.oprkind = 'l') OR
    (p1.oprright = 0 and p1.oprkind != 'r') OR
    (p1.oprright != 0 and p1.oprkind = 'r')
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- Look for conflicting operator definitions (same names and input datatypes).
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
FROM pg_operator AS p1, pg_operator AS p2
WHERE p1.oid != p2.oid AND
    p1.oprname = p2.oprname AND
    p1.oprkind = p2.oprkind AND
    p1.oprleft = p2.oprleft AND
    p1.oprright = p2.oprright
ORDER by 1, 2, 3;
 oid | oprcode | oid | oprcode 
-----+---------+-----+---------
(0 rows)

-- Look for commutative operators that don't commute.
-- DEFINITIONAL NOTE: If A.oprcom = B, then x A y has the same result as y B x.
-- We expect that B will always say that B.oprcom = A as well; that's not
-- inherently essential, but it would be inefficient not to mark it so.
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
FROM pg_operator AS p1, pg_operator AS p2
WHERE p1.oprcom = p2.oid AND
    (p1.oprkind != 'b' OR
     p1.oprleft != p2.oprright OR
     p1.oprright != p2.oprleft OR
     p1.oprresult != p2.oprresult OR
     p1.oid != p2.oprcom)
ORDER by 1, 2, 3;
 oid | oprcode | oid | oprcode 
-----+---------+-----+---------
(0 rows)

-- Look for negatory operators that don't agree.
-- DEFINITIONAL NOTE: If A.oprnegate = B, then both A and B must yield
-- boolean results, and (x A y) == ! (x B y), or the equivalent for
-- single-operand operators.
-- We expect that B will always say that B.oprnegate = A as well; that's not
-- inherently essential, but it would be inefficient not to mark it so.
-- Also, A and B had better not be the same operator.
SELECT p1.oid, p1.oprcode, p2.oid, p2.oprcode
FROM pg_operator AS p1, pg_operator AS p2
WHERE p1.oprnegate = p2.oid AND
    (p1.oprkind != p2.oprkind OR
     p1.oprleft != p2.oprleft OR
     p1.oprright != p2.oprright OR
     p1.oprresult != 'bool'::regtype OR
     p2.oprresult != 'bool'::regtype OR
     p1.oid != p2.oprnegate OR
     p1.oid = p2.oid)
ORDER by 1, 2, 3;
 oid | oprcode | oid | oprcode 
-----+---------+-----+---------
(0 rows)

-- A mergejoinable or hashjoinable operator must be binary, must return
-- boolean, and must have a commutator (itself, unless it's a cross-type
-- operator).
SELECT p1.oid, p1.oprname FROM pg_operator AS p1
WHERE (p1.oprcanmerge OR p1.oprcanhash) AND NOT
    (p1.oprkind = 'b' AND p1.oprresult = 'bool'::regtype AND p1.oprcom != 0)
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- What's more, the commutator had better be mergejoinable/hashjoinable too.
SELECT p1.oid, p1.oprname, p2.oid, p2.oprname
FROM pg_operator AS p1, pg_operator AS p2
WHERE p1.oprcom = p2.oid AND
    (p1.oprcanmerge != p2.oprcanmerge OR
     p1.oprcanhash != p2.oprcanhash)
ORDER by 1, 2, 3;
 oid | oprname | oid | oprname 
-----+---------+-----+---------
(0 rows)

-- Mergejoinable operators should appear as equality members of btree index
-- opfamilies.
SELECT p1.oid, p1.oprname
FROM pg_operator AS p1
WHERE p1.oprcanmerge AND NOT EXISTS
  (SELECT 1 FROM pg_amop
   WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND
         amopopr = p1.oid AND amopstrategy = 3)
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- And the converse.
SELECT p1.oid, p1.oprname, p.amopfamily
FROM pg_operator AS p1, pg_amop p
WHERE amopopr = p1.oid
  AND amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')
  AND amopstrategy = 3
  AND NOT p1.oprcanmerge
ORDER by 1, 2, 3;
 oid | oprname | amopfamily 
-----+---------+------------
(0 rows)

-- Hashable operators should appear as members of hash index opfamilies.
SELECT p1.oid, p1.oprname
FROM pg_operator AS p1
WHERE p1.oprcanhash AND NOT EXISTS
  (SELECT 1 FROM pg_amop
   WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash') AND
         amopopr = p1.oid AND amopstrategy = 1)
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- And the converse.
SELECT p1.oid, p1.oprname, p.amopfamily
FROM pg_operator AS p1, pg_amop p
WHERE amopopr = p1.oid
  AND amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash')
  AND NOT p1.oprcanhash
ORDER by 1, 2, 3;
 oid | oprname | amopfamily 
-----+---------+------------
(0 rows)

-- Check that each operator defined in pg_operator matches its oprcode entry
-- in pg_proc.  Easiest to do this separately for each oprkind.
SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprcode = p2.oid AND
    p1.oprkind = 'b' AND
    (p2.pronargs != 2
     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
     OR NOT binary_coercible(p1.oprright, p2.proargtypes[1]))
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprcode = p2.oid AND
    p1.oprkind = 'l' AND
    (p2.pronargs != 1
     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
     OR NOT binary_coercible(p1.oprright, p2.proargtypes[0])
     OR p1.oprleft != 0)
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprcode = p2.oid AND
    p1.oprkind = 'r' AND
    (p2.pronargs != 1
     OR NOT binary_coercible(p2.prorettype, p1.oprresult)
     OR NOT binary_coercible(p1.oprleft, p2.proargtypes[0])
     OR p1.oprright != 0)
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- If the operator is mergejoinable or hashjoinable, its underlying function
-- should not be volatile.
SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprcode = p2.oid AND
    (p1.oprcanmerge OR p1.oprcanhash) AND
    p2.provolatile = 'v'
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- If oprrest is set, the operator must return boolean,
-- and it must link to a proc with the right signature
-- to be a restriction selectivity estimator.
-- The proc signature we want is: float8 proc(internal, oid, internal, int4)
SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprrest = p2.oid AND
    (p1.oprresult != 'bool'::regtype OR
     p2.prorettype != 'float8'::regtype OR p2.proretset OR
     p2.pronargs != 4 OR
     p2.proargtypes[0] != 'internal'::regtype OR
     p2.proargtypes[1] != 'oid'::regtype OR
     p2.proargtypes[2] != 'internal'::regtype OR
     p2.proargtypes[3] != 'int4'::regtype)
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- If oprjoin is set, the operator must be a binary boolean op,
-- and it must link to a proc with the right signature
-- to be a join selectivity estimator.
-- The proc signature we want is: float8 proc(internal, oid, internal, int2, internal)
-- (Note: the old signature with only 4 args is still allowed, but no core
-- estimator should be using it.)
SELECT p1.oid, p1.oprname, p2.oid, p2.proname
FROM pg_operator AS p1, pg_proc AS p2
WHERE p1.oprjoin = p2.oid AND
    (p1.oprkind != 'b' OR p1.oprresult != 'bool'::regtype OR
     p2.prorettype != 'float8'::regtype OR p2.proretset OR
     p2.pronargs != 5 OR
     p2.proargtypes[0] != 'internal'::regtype OR
     p2.proargtypes[1] != 'oid'::regtype OR
     p2.proargtypes[2] != 'internal'::regtype OR
     p2.proargtypes[3] != 'int2'::regtype OR
     p2.proargtypes[4] != 'internal'::regtype)
ORDER by 1, 2, 3;
 oid | oprname | oid | proname 
-----+---------+-----+---------
(0 rows)

-- Insist that all built-in pg_operator entries have descriptions
SELECT p1.oid, p1.oprname
FROM pg_operator as p1 LEFT JOIN pg_description as d
     ON p1.tableoid = d.classoid and p1.oid = d.objoid and d.objsubid = 0
WHERE d.classoid IS NULL AND p1.oid <= 9999
ORDER by 1, 2;
 oid | oprname 
-----+---------
(0 rows)

-- Check that operators' underlying functions have suitable comments,
-- namely 'implementation of XXX operator'.  In some cases involving legacy
-- names for operators, there are multiple operators referencing the same
-- pg_proc entry, so ignore operators whose comments say they are deprecated.
-- We also have a few functions that are both operator support and meant to
-- be called directly; those should have comments matching their operator.
WITH funcdescs AS (
  SELECT p.oid as p_oid, proname, o.oid as o_oid,
    obj_description(p.oid, 'pg_proc') as prodesc,
    'implementation of ' || oprname || ' operator' as expecteddesc,
    obj_description(o.oid, 'pg_operator') as oprdesc
  FROM pg_proc p JOIN pg_operator o ON oprcode = p.oid
  WHERE o.oid <= 9999
)
SELECT * FROM funcdescs
  WHERE prodesc IS DISTINCT FROM expecteddesc
    AND oprdesc NOT LIKE 'deprecated%'
    AND prodesc IS DISTINCT FROM oprdesc
  ORDER by 1, 2, 3;
 p_oid |   proname   | o_oid |       prodesc        |          expecteddesc          |           oprdesc           
-------+-------------+-------+----------------------+--------------------------------+-----------------------------
   987 | path_length |   799 | sum of path segments | implementation of @-@ operator | sum of path segment lengths
  1035 | aclinsert   |   966 | I/O                  | implementation of + operator   | add/update ACL item
  1704 | numeric_abs |  1763 | sign of value        | implementation of @ operator   | absolute value
(3 rows)

-- **************** pg_aggregate ****************
-- Look for illegal values in pg_aggregate fields.
SELECT ctid, aggfnoid::oid
FROM pg_aggregate as p1
WHERE aggfnoid = 0 OR aggtransfn = 0 OR aggtranstype = 0
ORDER by 1, 2;
 ctid | aggfnoid 
------+----------
(0 rows)

-- Make sure the matching pg_proc entry is sensible, too.
SELECT a.aggfnoid::oid, p.proname
FROM pg_aggregate as a, pg_proc as p
WHERE a.aggfnoid = p.oid AND
    (NOT p.proisagg OR p.proretset)
ORDER by 1, 2;
 aggfnoid | proname 
----------+---------
(0 rows)

-- Make sure there are no proisagg pg_proc entries without matches.
SELECT oid, proname
FROM pg_proc as p
WHERE p.proisagg AND
    NOT EXISTS (SELECT 1 FROM pg_aggregate a WHERE a.aggfnoid = p.oid)
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- If there is no finalfn then the output type must be the transtype.
SELECT a.aggfnoid::oid, p.proname
FROM pg_aggregate as a, pg_proc as p
WHERE a.aggfnoid = p.oid AND
    a.aggfinalfn = 0 AND p.prorettype != a.aggtranstype
ORDER by 1, 2;
 aggfnoid | proname 
----------+---------
(0 rows)

-- Cross-check transfn against its entry in pg_proc.
-- NOTE: use physically_coercible_2 here, not binary_coercible_2, because
-- max and min on abstime are implemented using int4larger/int4smaller.
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
WHERE a.aggfnoid = p.oid AND
    a.aggtransfn = ptr.oid AND
    (ptr.proretset
     OR NOT (ptr.pronargs = 
             CASE WHEN a.aggkind = 'n' THEN p.pronargs + 1
             ELSE greatest(p.pronargs - a.aggnumdirectargs, 1) + 1 END)
     OR NOT physically_coercible_2(ptr.prorettype, a.aggtranstype)
     OR NOT physically_coercible_2(a.aggtranstype, ptr.proargtypes[0])
     OR (p.pronargs > 0 AND
         NOT physically_coercible_2(p.proargtypes[0], ptr.proargtypes[1]))
     OR (p.pronargs > 1 AND
         NOT physically_coercible_2(p.proargtypes[1], ptr.proargtypes[2]))
     OR (p.pronargs > 2 AND
         NOT physically_coercible_2(p.proargtypes[2], ptr.proargtypes[3]))
     -- we could carry the check further, but that's enough for now
    )
ORDER by 1, 2, 3;
 aggfnoid | proname | oid | proname 
----------+---------+-----+---------
(0 rows)

-- Cross-check finalfn (if present) against its entry in pg_proc.
SELECT a.aggfnoid::oid, p.proname, pfn.oid, pfn.proname
FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS pfn
WHERE a.aggfnoid = p.oid AND
    a.aggfinalfn = pfn.oid AND
    (pfn.proretset OR
     NOT binary_coercible_3(pfn.prorettype, p.prorettype) OR
     NOT binary_coercible_3(a.aggtranstype, pfn.proargtypes[0]) 
     OR (pfn.pronargs > 1 AND
         NOT binary_coercible_3(p.proargtypes[0], pfn.proargtypes[1]))
     OR (pfn.pronargs > 2 AND
         NOT binary_coercible_3(p.proargtypes[1], pfn.proargtypes[2]))
     OR (pfn.pronargs > 3 AND
         NOT binary_coercible_3(p.proargtypes[2], pfn.proargtypes[3]))
     -- we could carry the check further, but 3 args is enough for now
    )
ORDER by 1, 2, 3;
 aggfnoid | proname | oid | proname 
----------+---------+-----+---------
(0 rows)

-- If transfn is strict then either initval should be non-NULL, or
-- input type should match transtype so that the first non-null input
-- can be assigned as the state value.
SELECT a.aggfnoid::oid, p.proname, ptr.oid, ptr.proname
FROM pg_aggregate AS a, pg_proc AS p, pg_proc AS ptr
WHERE a.aggfnoid = p.oid AND
    a.aggtransfn = ptr.oid AND ptr.proisstrict AND
    a.agginitval IS NULL AND
    NOT binary_coercible(p.proargtypes[0], a.aggtranstype)
ORDER by 1, 2, 3;
 aggfnoid | proname | oid | proname 
----------+---------+-----+---------
(0 rows)

-- Cross-check aggsortop (if present) against pg_operator.
-- We expect to find entries for bool_and, bool_or, every, max, and min.
SELECT DISTINCT proname, oprname
FROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p
WHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid
ORDER BY 1, 2;
 proname  | oprname 
----------+---------
 bool_and | <
 bool_or  | >
 every    | <
 max      | >
 min      | <
(5 rows)

-- Check datatypes match
SELECT a.aggfnoid::oid, o.oid
FROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p
WHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND
    (oprkind != 'b' OR oprresult != 'boolean'::regtype
     OR oprleft != p.proargtypes[0] OR oprright != p.proargtypes[0])
ORDER by 1, 2;
 aggfnoid | oid 
----------+-----
(0 rows)

-- Check operator is a suitable btree opfamily member
SELECT a.aggfnoid::oid, o.oid
FROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p
WHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND
    NOT EXISTS(SELECT 1 FROM pg_amop
               WHERE amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')
                     AND amopopr = o.oid
                     AND amoplefttype = o.oprleft
                     AND amoprighttype = o.oprright)
ORDER by 1, 2;
 aggfnoid | oid 
----------+-----
(0 rows)

-- Check correspondence of btree strategies and names
SELECT DISTINCT proname, oprname, amopstrategy
FROM pg_operator AS o, pg_aggregate AS a, pg_proc AS p,
     pg_amop as ao
WHERE a.aggfnoid = p.oid AND a.aggsortop = o.oid AND
    amopopr = o.oid AND
    amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')
ORDER BY 1, 2;
 proname  | oprname | amopstrategy 
----------+---------+--------------
 bool_and | <       |            1
 bool_or  | >       |            5
 every    | <       |            1
 max      | >       |            5
 min      | <       |            1
(5 rows)

-- Check that there are not aggregates with the same name and different
-- numbers of arguments.  While not technically wrong, we have a project policy
-- to avoid this because it opens the door for confusion in connection with
-- ORDER BY: novices frequently put the ORDER BY in the wrong place.
-- See the fate of the single-argument form of string_agg() for history.
-- The only aggregates that should show up here are count(x) and count(*).
SELECT p1.oid::regprocedure, p2.oid::regprocedure
FROM pg_proc AS p1, pg_proc AS p2
WHERE p1.oid < p2.oid AND p1.proname = p2.proname AND
    p1.proisagg AND p2.proisagg AND
    array_dims(p1.proargtypes) != array_dims(p2.proargtypes) AND
    p1.proname != 'listagg'
ORDER BY 1;
                       oid                       |                           oid                           
-------------------------------------------------+---------------------------------------------------------
 count("any")                                    | count()
 hll_add_agg(hll_hashval)                        | hll_add_agg(hll_hashval,integer,integer,bigint,integer)
 hll_add_agg(hll_hashval)                        | hll_add_agg(hll_hashval,integer,integer,bigint)
 hll_add_agg(hll_hashval)                        | hll_add_agg(hll_hashval,integer,integer)
 hll_add_agg(hll_hashval)                        | hll_add_agg(hll_hashval,integer)
 hll_add_agg(hll_hashval,integer)                | hll_add_agg(hll_hashval,integer,integer,bigint,integer)
 hll_add_agg(hll_hashval,integer)                | hll_add_agg(hll_hashval,integer,integer,bigint)
 hll_add_agg(hll_hashval,integer)                | hll_add_agg(hll_hashval,integer,integer)
 hll_add_agg(hll_hashval,integer,integer)        | hll_add_agg(hll_hashval,integer,integer,bigint,integer)
 hll_add_agg(hll_hashval,integer,integer)        | hll_add_agg(hll_hashval,integer,integer,bigint)
 hll_add_agg(hll_hashval,integer,integer,bigint) | hll_add_agg(hll_hashval,integer,integer,bigint,integer)
(11 rows)

-- For the same reason, aggregates with default arguments are no good.
SELECT oid, proname
FROM pg_proc AS p
WHERE proisagg AND proargdefaults IS NOT NULL
ORDER by 1, 2;
 oid | proname 
-----+---------
(0 rows)

-- **************** pg_opfamily ****************
-- Look for illegal values in pg_opfamily fields
SELECT p1.oid
FROM pg_opfamily as p1
WHERE p1.opfmethod = 0 OR p1.opfnamespace = 0
ORDER by 1;
 oid 
-----
(0 rows)

-- **************** pg_opclass ****************
-- Look for illegal values in pg_opclass fields
SELECT p1.oid
FROM pg_opclass AS p1
WHERE p1.opcmethod = 0 OR p1.opcnamespace = 0 OR p1.opcfamily = 0
    OR p1.opcintype = 0
ORDER by 1;
 oid 
-----
(0 rows)

-- opcmethod must match owning opfamily's opfmethod
SELECT p1.oid, p2.oid
FROM pg_opclass AS p1, pg_opfamily AS p2
WHERE p1.opcfamily = p2.oid AND p1.opcmethod != p2.opfmethod
ORDER by 1, 2;
 oid | oid 
-----+-----
(0 rows)

-- There should not be multiple entries in pg_opclass with opcdefault true
-- and the same opcmethod/opcintype combination.
SELECT p1.oid, p2.oid
FROM pg_opclass AS p1, pg_opclass AS p2
WHERE p1.oid != p2.oid AND
    p1.opcmethod = p2.opcmethod AND p1.opcintype = p2.opcintype AND
    p1.opcdefault AND p2.opcdefault
ORDER by 1, 2;
 oid | oid 
-----+-----
(0 rows)

-- **************** pg_amop ****************
-- Look for illegal values in pg_amop fields
SELECT p1.amopfamily, p1.amopstrategy
FROM pg_amop as p1
WHERE p1.amopfamily = 0 OR p1.amoplefttype = 0 OR p1.amoprighttype = 0
    OR p1.amopopr = 0 OR p1.amopmethod = 0 OR p1.amopstrategy < 1
ORDER by 1, 2;
 amopfamily | amopstrategy 
------------+--------------
(0 rows)

SELECT p1.amopfamily, p1.amopstrategy
FROM pg_amop as p1
WHERE NOT ((p1.amoppurpose = 's' AND p1.amopsortfamily = 0) OR
           (p1.amoppurpose = 'o' AND p1.amopsortfamily <> 0))
ORDER by 1, 2;
 amopfamily | amopstrategy 
------------+--------------
(0 rows)

-- amoplefttype/amoprighttype must match the operator
SELECT p1.oid, p2.oid
FROM pg_amop AS p1, pg_operator AS p2
WHERE p1.amopopr = p2.oid AND NOT
    (p1.amoplefttype = p2.oprleft AND p1.amoprighttype = p2.oprright)
ORDER by 1, 2;
 oid | oid 
-----+-----
(0 rows)

-- amopmethod must match owning opfamily's opfmethod
SELECT p1.oid, p2.oid
FROM pg_amop AS p1, pg_opfamily AS p2
WHERE p1.amopfamily = p2.oid AND p1.amopmethod != p2.opfmethod
ORDER by 1, 2;
 oid | oid 
-----+-----
(0 rows)

-- amopsortfamily, if present, must reference a btree family
SELECT p1.amopfamily, p1.amopstrategy
FROM pg_amop AS p1
WHERE p1.amopsortfamily <> 0 AND NOT EXISTS
    (SELECT 1 from pg_opfamily op WHERE op.oid = p1.amopsortfamily
     AND op.opfmethod = (SELECT oid FROM pg_am WHERE amname = 'btree'))
ORDER by 1, 2;
 amopfamily | amopstrategy 
------------+--------------
(0 rows)

-- check for ordering operators not supported by parent AM
SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.amname
FROM pg_amop AS p1, pg_am AS p2
WHERE p1.amopmethod = p2.oid AND
    p1.amoppurpose = 'o' AND NOT p2.amcanorderbyop
ORDER by 1, 2, 3;
 amopfamily | amopopr | oid | amname 
------------+---------+-----+--------
(0 rows)

-- Cross-check amopstrategy index against parent AM
SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.amname
FROM pg_amop AS p1, pg_am AS p2
WHERE p1.amopmethod = p2.oid AND
    p1.amopstrategy > p2.amstrategies AND p2.amstrategies <> 0
ORDER by 1, 2, 3;
 amopfamily | amopopr | oid | amname 
------------+---------+-----+--------
(0 rows)

-- Detect missing pg_amop entries: should have as many strategy operators
-- as AM expects for each datatype combination supported by the opfamily.
-- We can't check this for AMs with variable strategy sets.
SELECT p1.amname, p2.amoplefttype, p2.amoprighttype
FROM pg_am AS p1, pg_amop AS p2
WHERE p2.amopmethod = p1.oid AND
    p1.amstrategies <> 0 AND
    p1.amstrategies != (SELECT count(*) FROM pg_amop AS p3
                        WHERE p3.amopfamily = p2.amopfamily AND
                              p3.amoplefttype = p2.amoplefttype AND
                              p3.amoprighttype = p2.amoprighttype AND
                              p3.amoppurpose = 's')
ORDER by 1, 2, 3;
 amname | amoplefttype | amoprighttype 
--------+--------------+---------------
 btree  |         4402 |          4402
 ubtree |         4402 |          4402
(2 rows)

-- Currently, none of the AMs with fixed strategy sets support ordering ops.
SELECT p1.amname, p2.amopfamily, p2.amopstrategy
FROM pg_am AS p1, pg_amop AS p2
WHERE p2.amopmethod = p1.oid AND
    p1.amstrategies <> 0 AND p2.amoppurpose <> 's'
ORDER by 1, 2, 3;
 amname | amopfamily | amopstrategy 
--------+------------+--------------
(0 rows)

-- Check that amopopr points at a reasonable-looking operator, ie a binary
-- operator.  If it's a search operator it had better yield boolean,
-- otherwise an input type of its sort opfamily.
SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.oprname
FROM pg_amop AS p1, pg_operator AS p2
WHERE p1.amopopr = p2.oid AND
    p2.oprkind != 'b'
ORDER by 1, 2, 3;
 amopfamily | amopopr | oid | oprname 
------------+---------+-----+---------
(0 rows)

SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.oprname
FROM pg_amop AS p1, pg_operator AS p2
WHERE p1.amopopr = p2.oid AND p1.amoppurpose = 's' AND
    p2.oprresult != 'bool'::regtype
ORDER by 1, 2, 3;
 amopfamily | amopopr | oid | oprname 
------------+---------+-----+---------
(0 rows)

SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.oprname
FROM pg_amop AS p1, pg_operator AS p2
WHERE p1.amopopr = p2.oid AND p1.amoppurpose = 'o' AND NOT EXISTS
    (SELECT 1 FROM pg_opclass op
     WHERE opcfamily = p1.amopsortfamily AND opcintype = p2.oprresult)
ORDER by 1, 2, 3;
 amopfamily | amopopr | oid | oprname 
------------+---------+-----+---------
(0 rows)

-- Make a list of all the distinct operator names being used in particular
-- strategy slots.  This is a bit hokey, since the list might need to change
-- in future releases, but it's an effective way of spotting mistakes such as
-- swapping two operators within a family.
SELECT DISTINCT amopmethod, amopstrategy, oprname
FROM pg_amop p1 LEFT JOIN pg_operator p2 ON amopopr = p2.oid
ORDER BY 1, 2, 3;
 amopmethod | amopstrategy | oprname 
------------+--------------+---------
        403 |            1 | <
        403 |            1 | ~<~
        403 |            2 | <=
        403 |            2 | ~<=~
        403 |            3 | =
        403 |            4 | >=
        403 |            4 | ~>=~
        403 |            5 | >
        403 |            5 | ~>~
        405 |            1 | =
        783 |            1 | <<
        783 |            1 | @@
        783 |            2 | &<
        783 |            3 | &&
        783 |            4 | &>
        783 |            5 | >>
        783 |            6 | -|-
        783 |            6 | ~=
        783 |            7 | @>
        783 |            8 | <@
        783 |            9 | &<|
        783 |           10 | <<|
        783 |           10 | <^
        783 |           11 | >^
        783 |           11 | |>>
        783 |           12 | |&>
        783 |           13 | ~
        783 |           14 | @
        783 |           15 | <->
        783 |           16 | @>
        783 |           18 | =
        783 |           28 | <@
        783 |           48 | <@
        783 |           68 | <@
       2742 |            1 | &&
       2742 |            1 | @@
       2742 |            2 | @>
       2742 |            2 | @@@
       2742 |            3 | <@
       2742 |            4 | =
       2742 |            7 | @>
       2742 |            9 | ?
       2742 |           10 | ?|
       2742 |           11 | ?&
       4000 |            1 | <<
       4000 |            1 | ~<~
       4000 |            2 | ~<=~
       4000 |            3 | =
       4000 |            4 | ~>=~
       4000 |            5 | >>
       4000 |            5 | ~>~
       4000 |            6 | ~=
       4000 |            8 | <@
       4000 |           10 | <^
       4000 |           11 | <
       4000 |           11 | >^
       4000 |           12 | <=
       4000 |           14 | >=
       4000 |           15 | >
       4039 |            1 | <
       4039 |            2 | <=
       4039 |            3 | =
       4039 |            4 | >=
       4039 |            5 | >
       4239 |            1 | <
       4239 |            2 | <=
       4239 |            3 | =
       4239 |            4 | >=
       4239 |            5 | >
       4439 |            1 | <
       4439 |            1 | ~<~
       4439 |            2 | <=
       4439 |            2 | ~<=~
       4439 |            3 | =
       4439 |            4 | >=
       4439 |            4 | ~>=~
       4439 |            5 | >
       4439 |            5 | ~>~
       4444 |            1 | @@
       4444 |            2 | @@@
(80 rows)

-- Check that all opclass search operators have selectivity estimators.
-- This is not absolutely required, but it seems a reasonable thing
-- to insist on for all standard datatypes.
SELECT p1.amopfamily, p1.amopopr, p2.oid, p2.oprname
FROM pg_amop AS p1, pg_operator AS p2
WHERE p1.amopopr = p2.oid AND p1.amoppurpose = 's' AND
    (p2.oprrest = 0 OR p2.oprjoin = 0)
ORDER by 1, 2, 3, 4;
 amopfamily | amopopr | oid | oprname 
------------+---------+-----+---------
(0 rows)

-- Check that each opclass in an opfamily has associated operators, that is
-- ones whose oprleft matches opcintype (possibly by coercion).
SELECT p1.opcname, p1.opcfamily
FROM pg_opclass AS p1
WHERE NOT EXISTS(SELECT 1 FROM pg_amop AS p2
                 WHERE p2.amopfamily = p1.opcfamily
                   AND binary_coercible(p1.opcintype, p2.amoplefttype))
ORDER by 1, 2;
 opcname | opcfamily 
---------+-----------
(0 rows)

-- Check that each operator listed in pg_amop has an associated opclass,
-- that is one whose opcintype matches oprleft (possibly by coercion).
-- Otherwise the operator is useless because it cannot be matched to an index.
-- (In principle it could be useful to list such operators in multiple-datatype
-- btree opfamilies, but in practice you'd expect there to be an opclass for
-- every datatype the family knows about.)
SELECT p1.amopfamily, p1.amopstrategy, p1.amopopr
FROM pg_amop AS p1
WHERE NOT EXISTS(SELECT 1 FROM pg_opclass AS p2
                 WHERE p2.opcfamily = p1.amopfamily
                   AND binary_coercible(p2.opcintype, p1.amoplefttype))
ORDER by 1, 2, 3;
 amopfamily | amopstrategy | amopopr 
------------+--------------+---------
(0 rows)

-- Operators that are primary members of opclasses must be immutable (else
-- it suggests that the index ordering isn't fixed).  Operators that are
-- cross-type members need only be stable, since they are just shorthands
-- for index probe queries.
SELECT p1.amopfamily, p1.amopopr, p2.oprname, p3.prosrc
FROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3
WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND
    p1.amoplefttype = p1.amoprighttype AND
    p3.provolatile != 'i'
ORDER by 1, 2, 3;
 amopfamily | amopopr | oprname | prosrc 
------------+---------+---------+--------
(0 rows)

SELECT p1.amopfamily, p1.amopopr, p2.oprname, p3.prosrc
FROM pg_amop AS p1, pg_operator AS p2, pg_proc AS p3
WHERE p1.amopopr = p2.oid AND p2.oprcode = p3.oid AND
    p1.amoplefttype != p1.amoprighttype AND
    p3.provolatile = 'v'
ORDER by 1, 2, 3;
 amopfamily | amopopr | oprname | prosrc 
------------+---------+---------+--------
(0 rows)

-- Multiple-datatype btree opfamilies should provide closed sets of equality
-- operators; that is if you provide int2 = int4 and int4 = int8 then you
-- should also provide int2 = int8 (and commutators of all these).  This is
-- important because the planner tries to deduce additional qual clauses from
-- transitivity of mergejoinable operators.  If there are clauses
-- int2var = int4var and int4var = int8var, the planner will want to deduce
-- int2var = int8var ... so there should be a way to represent that.  While
-- a missing cross-type operator is now only an efficiency loss rather than
-- an error condition, it still seems reasonable to insist that all built-in
-- opfamilies be complete.
-- check commutative closure
SELECT p1.amoplefttype, p1.amoprighttype
FROM pg_amop AS p1
WHERE p1.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND
    p1.amopstrategy = 3 AND
    p1.amoplefttype != p1.amoprighttype AND
    NOT EXISTS(SELECT 1 FROM pg_amop p2 WHERE
                 p2.amopfamily = p1.amopfamily AND
                 p2.amoplefttype = p1.amoprighttype AND
                 p2.amoprighttype = p1.amoplefttype AND
                 p2.amopstrategy = 3)
ORDER by 1, 2;
 amoplefttype | amoprighttype 
--------------+---------------
(0 rows)

-- check transitive closure
SELECT p1.amoplefttype, p1.amoprighttype, p2.amoprighttype
FROM pg_amop AS p1, pg_amop AS p2
WHERE p1.amopfamily = p2.amopfamily AND
    p1.amoprighttype = p2.amoplefttype AND
    p1.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND
    p2.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'btree') AND
    p1.amopstrategy = 3 AND p2.amopstrategy = 3 AND
    p1.amoplefttype != p1.amoprighttype AND
    p2.amoplefttype != p2.amoprighttype AND
    NOT EXISTS(SELECT 1 FROM pg_amop p3 WHERE
                 p3.amopfamily = p1.amopfamily AND
                 p3.amoplefttype = p1.amoplefttype AND
                 p3.amoprighttype = p2.amoprighttype AND
                 p3.amopstrategy = 3)
ORDER by 1, 2, 3;
 amoplefttype | amoprighttype | amoprighttype 
--------------+---------------+---------------
(0 rows)

-- We also expect that built-in multiple-datatype hash opfamilies provide
-- complete sets of cross-type operators.  Again, this isn't required, but
-- it is reasonable to expect it for built-in opfamilies.
-- if same family has x=x and y=y, it should have x=y
SELECT p1.amoplefttype, p2.amoplefttype
FROM pg_amop AS p1, pg_amop AS p2
WHERE p1.amopfamily = p2.amopfamily AND
    p1.amoplefttype = p1.amoprighttype AND
    p2.amoplefttype = p2.amoprighttype AND
    p1.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash') AND
    p2.amopmethod = (SELECT oid FROM pg_am WHERE amname = 'hash') AND
    p1.amopstrategy = 1 AND p2.amopstrategy = 1 AND
    p1.amoplefttype != p2.amoplefttype AND
    NOT EXISTS(SELECT 1 FROM pg_amop p3 WHERE
                 p3.amopfamily = p1.amopfamily AND
                 p3.amoplefttype = p1.amoplefttype AND
                 p3.amoprighttype = p2.amoplefttype AND
                 p3.amopstrategy = 1)
ORDER by 1, 2;
 amoplefttype | amoplefttype 
--------------+--------------
(0 rows)

-- **************** pg_amproc ****************
-- Look for illegal values in pg_amproc fields
SELECT p1.amprocfamily, p1.amprocnum
FROM pg_amproc as p1
WHERE p1.amprocfamily = 0 OR p1.amproclefttype = 0 OR p1.amprocrighttype = 0
    OR p1.amprocnum < 1 OR p1.amproc = 0
ORDER by 1, 2;
 amprocfamily | amprocnum 
--------------+-----------
(0 rows)

-- Cross-check amprocnum index against parent AM
SELECT p1.amprocfamily, p1.amprocnum, p2.oid, p2.amname
FROM pg_amproc AS p1, pg_am AS p2, pg_opfamily AS p3
WHERE p1.amprocfamily = p3.oid AND p3.opfmethod = p2.oid AND
    p1.amprocnum > p2.amsupport
ORDER by 1, 2, 3;
 amprocfamily | amprocnum | oid | amname 
--------------+-----------+-----+--------
(0 rows)

-- Detect missing pg_amproc entries: should have as many support functions
-- as AM expects for each datatype combination supported by the opfamily.
-- btree/GiST/GIN each allow one optional support function, though.
SELECT p1.amname, p2.opfname, p3.amproclefttype, p3.amprocrighttype
FROM pg_am AS p1, pg_opfamily AS p2, pg_amproc AS p3
WHERE p2.opfmethod = p1.oid AND p3.amprocfamily = p2.oid AND
    (SELECT count(*) FROM pg_amproc AS p4
     WHERE p4.amprocfamily = p2.oid AND
           p4.amproclefttype = p3.amproclefttype AND
           p4.amprocrighttype = p3.amprocrighttype)
    NOT BETWEEN
      (CASE WHEN p1.amname IN ('btree', 'gist', 'gin', 'ubtree') THEN p1.amsupport - 1
            ELSE p1.amsupport END)
      AND p1.amsupport
ORDER by 1, 2, 3;
 amname | opfname | amproclefttype | amprocrighttype 
--------+---------+----------------+-----------------
(0 rows)

-- Also, check if there are any pg_opclass entries that don't seem to have
-- pg_amproc support.  Again, opclasses with an optional support proc have
-- to be checked specially.
SELECT amname, opcname, count(*)
FROM pg_am am JOIN pg_opclass op ON opcmethod = am.oid
     LEFT JOIN pg_amproc p ON amprocfamily = opcfamily AND
         amproclefttype = amprocrighttype AND amproclefttype = opcintype
WHERE am.amname <> 'btree' AND am.amname <> 'gist' AND am.amname <> 'gin' AND am.amname <> 'ubtree'
GROUP BY amname, amsupport, opcname, amprocfamily
HAVING count(*) != amsupport OR amprocfamily IS NULL
ORDER by 1, 2, 3;
 amname | opcname | count 
--------+---------+-------
(0 rows)

SELECT amname, opcname, count(*)
FROM pg_am am JOIN pg_opclass op ON opcmethod = am.oid
     LEFT JOIN pg_amproc p ON amprocfamily = opcfamily AND
         amproclefttype = amprocrighttype AND amproclefttype = opcintype
WHERE am.amname = 'btree' OR am.amname = 'gist' OR am.amname = 'gin' OR am.amname = 'ubtree'
GROUP BY amname, amsupport, opcname, amprocfamily
HAVING (count(*) != amsupport AND count(*) != amsupport - 1)
    OR amprocfamily IS NULL
ORDER by 1, 2, 3;
 amname | opcname | count 
--------+---------+-------
(0 rows)

-- Unfortunately, we can't check the amproc link very well because the
-- signature of the function may be different for different support routines
-- or different base data types.
-- We can check that all the referenced instances of the same support
-- routine number take the same number of parameters, but that's about it
-- for a general check...
SELECT p1.amprocfamily, p1.amprocnum,
	p2.oid, p2.proname,
	p3.opfname,
	p4.amprocfamily, p4.amprocnum,
	p5.oid, p5.proname,
	p6.opfname
FROM pg_amproc AS p1, pg_proc AS p2, pg_opfamily AS p3,
     pg_amproc AS p4, pg_proc AS p5, pg_opfamily AS p6
WHERE p1.amprocfamily = p3.oid AND p4.amprocfamily = p6.oid AND
    p3.opfmethod = p6.opfmethod AND p1.amprocnum = p4.amprocnum AND
    p1.amproc = p2.oid AND p4.amproc = p5.oid AND
    (p2.proretset OR p5.proretset OR p2.pronargs != p5.pronargs)
ORDER by 1, 2, 3;
 amprocfamily | amprocnum | oid | proname | opfname | amprocfamily | amprocnum | oid | proname | opfname 
--------------+-----------+-----+---------+---------+--------------+-----------+-----+---------+---------
(0 rows)

-- For btree, though, we can do better since we know the support routines
-- must be of the form cmp(lefttype, righttype) returns int4
-- or sortsupport(internal) returns void.
SELECT p1.amprocfamily, p1.amprocnum,
	p2.oid, p2.proname,
	p3.opfname
FROM pg_amproc AS p1, pg_proc AS p2, pg_opfamily AS p3
WHERE p3.opfmethod = (SELECT oid FROM pg_am WHERE amname = 'btree')
    AND p1.amprocfamily = p3.oid AND p1.amproc = p2.oid AND
    (CASE WHEN amprocnum = 1
          THEN prorettype != 'int4'::regtype OR proretset OR pronargs != 2
               OR proargtypes[0] != amproclefttype
               OR proargtypes[1] != amprocrighttype
          WHEN amprocnum = 2
          THEN prorettype != 'void'::regtype OR proretset OR pronargs != 1
               OR proargtypes[0] != 'internal'::regtype
          ELSE true END)
ORDER by 1, 2, 3;
 amprocfamily | amprocnum | oid | proname | opfname 
--------------+-----------+-----+---------+---------
(0 rows)

-- For hash we can also do a little better: the support routines must be
-- of the form hash(lefttype) returns int4.  There are several cases where
-- we cheat and use a hash function that is physically compatible with the
-- datatype even though there's no cast, so this check does find a small
-- number of entries.
SELECT p1.amprocfamily, p1.amprocnum, p2.proname, p3.opfname
FROM pg_amproc AS p1, pg_proc AS p2, pg_opfamily AS p3
WHERE p3.opfmethod = (SELECT oid FROM pg_am WHERE amname = 'hash')
    AND p1.amprocfamily = p3.oid AND p1.amproc = p2.oid AND
    (amprocnum != 1
     OR proretset
     OR prorettype != 'int4'::regtype
     OR pronargs != 1
     OR NOT physically_coercible(amproclefttype, proargtypes[0])
     OR amproclefttype != amprocrighttype)
ORDER BY 1, 2;
 amprocfamily | amprocnum |    proname     |              opfname              
--------------+-----------+----------------+-----------------------------------
          435 |         1 | hashint4       | date_ops
         1999 |         1 | timestamp_hash | timestamptz_ops
         2222 |         1 | hashchar       | bool_ops
         2223 |         1 | hashvarlena    | bytea_ops
         2225 |         1 | hashint8       | xid_ops
         2226 |         1 | hashint4       | cid_ops
         2232 |         1 | hashint4       | xid32_ops
         3807 |         1 | hashvarlena    | raw_ops
         4470 |         1 | hashvarlena    | byteawithoutorderwithequalcol_ops
(9 rows)

-- We can also check SP-GiST carefully, since the support routine signatures
-- are independent of the datatype being indexed.
SELECT p1.amprocfamily, p1.amprocnum,
	p2.oid, p2.proname,
	p3.opfname
FROM pg_amproc AS p1, pg_proc AS p2, pg_opfamily AS p3
WHERE p3.opfmethod = (SELECT oid FROM pg_am WHERE amname = 'spgist')
    AND p1.amprocfamily = p3.oid AND p1.amproc = p2.oid AND
    (CASE WHEN amprocnum = 1 OR amprocnum = 2 OR amprocnum = 3 OR amprocnum = 4
          THEN prorettype != 'void'::regtype OR proretset OR pronargs != 2
               OR proargtypes[0] != 'internal'::regtype
               OR proargtypes[1] != 'internal'::regtype
          WHEN amprocnum = 5
          THEN prorettype != 'bool'::regtype OR proretset OR pronargs != 2
               OR proargtypes[0] != 'internal'::regtype
               OR proargtypes[1] != 'internal'::regtype
          ELSE true END)
ORDER by 1, 2, 3;
 amprocfamily | amprocnum | oid | proname | opfname 
--------------+-----------+-----+---------+---------
(0 rows)

-- Support routines that are primary members of opfamilies must be immutable
-- (else it suggests that the index ordering isn't fixed).  But cross-type
-- members need only be stable, since they are just shorthands
-- for index probe queries.
SELECT p1.amprocfamily, p1.amproc, p2.prosrc
FROM pg_amproc AS p1, pg_proc AS p2
WHERE p1.amproc = p2.oid AND
    p1.amproclefttype = p1.amprocrighttype AND
    p2.provolatile != 'i' order by 1, 2, 3;
 amprocfamily | amproc | prosrc 
--------------+--------+--------
(0 rows)

SELECT p1.amprocfamily, p1.amproc, p2.prosrc
FROM pg_amproc AS p1, pg_proc AS p2
WHERE p1.amproc = p2.oid AND
    p1.amproclefttype != p1.amprocrighttype AND
    p2.provolatile = 'v' order by 1, 2, 3;
 amprocfamily | amproc | prosrc 
--------------+--------+--------
(0 rows)

