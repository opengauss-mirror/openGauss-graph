/*
 * This file is used to test the vector engine un-support expressions
 * We support these expressions by rewriting its plan to pull up these expression
 * And use vec_to_row to convert it to use row engine
 */
/************************************************************
Expression Type:
    T_ArrayRef
    T_AlternativeSubPlan
    T_FieldSelect
    T_FieldStore
    T_ArrayCoerceExpr
    T_ConvertRowtypeExpr
    T_ArrayExpr
    T_RowExpr
    T_XmlExpr
    T_CoerceToDomain
    T_CoerceToDomainValue
    T_CurrentOfExpr

Using Type:
    qual
    targetlist
*************************************************************/
create schema vec_unsupport_expression;
set current_schema=vec_unsupport_expression;
create table t1(c1 int, c2 int, c3 int) with (orientation=column) distribute by hash(c1);
insert into t1 select v,v,v from generate_series(1,12) as v;
create table t2(c1 int, c2 int, c3 int) with (orientation=column) distribute by hash(c1);
insert into t2 select v,v,v from generate_series(1,10) as v;
select c2,string_to_array(c2,'a') as arr from t1 where c2=arr[1] order by 1;
 c2 | arr  
----+------
  1 | {1}
  2 | {2}
  3 | {3}
  4 | {4}
  5 | {5}
  6 | {6}
  7 | {7}
  8 | {8}
  9 | {9}
 10 | {10}
 11 | {11}
 12 | {12}
(12 rows)

explain (costs off, verbose on) select c2,string_to_array(c2,'a') as arr from t1 where c2=arr[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c2, (string_to_array((c2)::text, 'a'::text))
   Merge Sort Key: t1.c2
   ->  Sort
         Output: c2, (string_to_array((c2)::text, 'a'::text))
         Sort Key: t1.c2
         ->  Result
               Output: c2, string_to_array((c2)::text, 'a'::text)
               Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: c2
                           Distribute Key: c1
(14 rows)

select c2,string_to_array(c2,'a') as arr from t1 where c2=arr[1]+1 order by 1;
 c2 | arr 
----+-----
(0 rows)

explain (costs off, verbose on) select c2,string_to_array(c2,'a') as arr from t1 where c2=arr[1]+1 order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c2, (string_to_array((c2)::text, 'a'::text))
   Merge Sort Key: t1.c2
   ->  Sort
         Output: c2, (string_to_array((c2)::text, 'a'::text))
         Sort Key: t1.c2
         ->  Result
               Output: c2, string_to_array((c2)::text, 'a'::text)
               Filter: (t1.c2 = (((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint + 1))
               ->  Row Adapter
                     Output: c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: c2
                           Distribute Key: c1
(14 rows)

select c1,c2,string_to_array(c2,'a') as arr from t1 where t1.c2 in (3,4,7) and t1.c2=arr[1] order by 1,2;
 c1 | c2 | arr 
----+----+-----
  3 |  3 | {3}
  4 |  4 | {4}
  7 |  7 | {7}
(3 rows)

explain (costs off, verbose on) select c1,c2,string_to_array(c2,'a') as arr from t1 where t1.c2 in (3,4,7) and t1.c2=arr[1] order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c1, c2, (string_to_array((c2)::text, 'a'::text))
   Merge Sort Key: t1.c1, t1.c2
   ->  Sort
         Output: c1, c2, (string_to_array((c2)::text, 'a'::text))
         Sort Key: t1.c1, t1.c2
         ->  Result
               Output: c1, c2, string_to_array((c2)::text, 'a'::text)
               Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: c1, c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: c1, c2
                           Distribute Key: c1
                           Filter: (t1.c2 = ANY ('{3,4,7}'::integer[]))
(15 rows)

select c1,c3,string_to_array(c2,'a') as arr from t1 where t1.c2 in (3,4,7) and t1.c2=arr[1] order by 1,2;
 c1 | c3 | arr 
----+----+-----
  3 |  3 | {3}
  4 |  4 | {4}
  7 |  7 | {7}
(3 rows)

explain (costs off, verbose on) select c1,c3,string_to_array(c2,'a') as arr from t1 where t1.c2 in (3,4,7) and t1.c2=arr[1] order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c1, c3, (string_to_array((c2)::text, 'a'::text))
   Merge Sort Key: t1.c1, t1.c3
   ->  Sort
         Output: c1, c3, (string_to_array((c2)::text, 'a'::text))
         Sort Key: t1.c1, t1.c3
         ->  Result
               Output: c1, c3, string_to_array((c2)::text, 'a'::text)
               Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: c1, c3, c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: c1, c3, c2
                           Distribute Key: c1
                           Filter: (t1.c2 = ANY ('{3,4,7}'::integer[]))
(15 rows)

select c1,c3,string_to_array(c2,'a') as arr from t1 where t1.c3=arr[1] and c3 in (3,4,7) order by 1;
 c1 | c3 | arr 
----+----+-----
  3 |  3 | {3}
  4 |  4 | {4}
  7 |  7 | {7}
(3 rows)

explain (costs off, verbose on) select c1,c3,string_to_array(c2,'a') as arr from t1 where t1.c3=arr[1] and c3 in (3,4,7) order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c1, c3, (string_to_array((c2)::text, 'a'::text))
   Merge Sort Key: t1.c1
   ->  Sort
         Output: c1, c3, (string_to_array((c2)::text, 'a'::text))
         Sort Key: t1.c1
         ->  Result
               Output: c1, c3, string_to_array((c2)::text, 'a'::text)
               Filter: (t1.c3 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: c1, c3, c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: c1, c3, c2
                           Distribute Key: c1
                           Filter: (t1.c3 = ANY ('{3,4,7}'::integer[]))
(15 rows)

select t1.c1 as c1, t2.c2 as c2,string_to_array(t1.c2,'a') as arr
from t1,t2
where t1.c1 = t2.c1 and t1.c1 in (3,4,5,6) and t1.c1=arr[1]
order by 1,2;
 c1 | c2 | arr 
----+----+-----
  3 |  3 | {3}
  4 |  4 | {4}
  5 |  5 | {5}
  6 |  6 | {6}
(4 rows)

explain (costs off, verbose on) select t1.c1 as c1, t2.c2 as c2,string_to_array(t1.c2,'a') as arr
from t1,t2
where t1.c1 = t2.c1 and t1.c1 in (3,4,5,6) and t1.c1=arr[1]
order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t2.c2, (string_to_array((t1.c2)::text, 'a'::text))
   Merge Sort Key: t1.c1, t2.c2
   ->  Sort
         Output: t1.c1, t2.c2, (string_to_array((t1.c2)::text, 'a'::text))
         Sort Key: t1.c1, t2.c2
         ->  Nested Loop
               Output: t1.c1, t2.c2, string_to_array((t1.c2)::text, 'a'::text)
               Join Filter: (t1.c1 = t2.c1)
               ->  Result
                     Output: t1.c1, t1.c2
                     Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                     ->  Row Adapter
                           Output: t1.c1, t1.c2
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: t1.c1, t1.c2
                                 Distribute Key: t1.c1
                                 Filter: (t1.c1 = ANY ('{3,4,5,6}'::integer[]))
               ->  Row Adapter
                     Output: t2.c2, t2.c1
                     ->  CStore Scan on vec_unsupport_expression.t2
                           Output: t2.c2, t2.c1
                           Distribute Key: t2.c1
                           Filter: (t2.c1 = ANY ('{3,4,5,6}'::integer[]))
(24 rows)

select * from
(
    select t1.c1 as c1, t2.c2 as c2,string_to_array(t1.c2,'a') as arr, count(*) as sum
    from t1,t2
    where t1.c1 = t2.c1
    group by 1,2,t1.c2
) as dt where dt.c1 in (3,4,5,6) or dt.c1=arr[1]
order by 1,2,3;
 c1 | c2 | arr  | sum 
----+----+------+-----
  1 |  1 | {1}  |   1
  2 |  2 | {2}  |   1
  3 |  3 | {3}  |   1
  4 |  4 | {4}  |   1
  5 |  5 | {5}  |   1
  6 |  6 | {6}  |   1
  7 |  7 | {7}  |   1
  8 |  8 | {8}  |   1
  9 |  9 | {9}  |   1
 10 | 10 | {10} |   1
(10 rows)

explain (costs off, verbose on) select * from
(
    select t1.c1 as c1, t2.c2 as c2,string_to_array(t1.c2,'a') as arr, count(*) as sum
    from t1,t2
    where t1.c1 = t2.c1
    group by 1,2,t1.c2
) as dt where dt.c1 in (3,4,5,6) or dt.c1=arr[1]
order by 1,2,3;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: dt.c1, dt.c2, dt.arr, dt.sum
   Merge Sort Key: dt.c1, dt.c2, dt.arr
   ->  Sort
         Output: dt.c1, dt.c2, dt.arr, dt.sum
         Sort Key: dt.c1, dt.c2, dt.arr
         ->  Subquery Scan on dt
               Output: dt.c1, dt.c2, dt.arr, dt.sum
               ->  HashAggregate
                     Output: t1.c1, t2.c2, string_to_array((t1.c2)::text, 'a'::text), count(*), t1.c2
                     Group By Key: t1.c1, t2.c2, t1.c2
                     ->  Nested Loop
                           Output: t1.c1, t1.c2, t2.c2
                           Join Filter: (t1.c1 = t2.c1)
                           ->  Result
                                 Output: t1.c1, t1.c2
                                 Filter: ((t1.c1 = ANY ('{3,4,5,6}'::integer[])) OR (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint))
                                 ->  Row Adapter
                                       Output: t1.c1, t1.c2
                                       ->  CStore Scan on vec_unsupport_expression.t1
                                             Output: t1.c1, t1.c2
                                             Distribute Key: t1.c1
                           ->  Row Adapter
                                 Output: t2.c2, t2.c1
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c2, t2.c1
                                       Distribute Key: t2.c1
(27 rows)

select t1.c2,string_to_array(t1.c2,'a') as arr,count(*) from t1 where t1.c1 in (1,2,3) group by t1.c2 having t1.c2=arr[1] order by 1;
 c2 | arr | count 
----+-----+-------
  1 | {1} |     1
  2 | {2} |     1
  3 | {3} |     1
(3 rows)

explain (costs off, verbose on) select t1.c2,string_to_array(t1.c2,'a') as arr,count(*) from t1 where t1.c1 in (1,2,3) group by t1.c2 having t1.c2=arr[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c2, (string_to_array((c2)::text, 'a'::text)), (count(*))
   Merge Sort Key: t1.c2
   ->  Sort
         Output: c2, (string_to_array((c2)::text, 'a'::text)), (count(*))
         Sort Key: t1.c2
         ->  HashAggregate
               Output: c2, string_to_array((c2)::text, 'a'::text), count(*)
               Group By Key: t1.c2
               ->  Streaming(type: REDISTRIBUTE)
                     Output: c2
                     Distribute Key: c2
                     ->  Result
                           Output: c2
                           Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: c2
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: c2
                                       Distribute Key: c1
                                       Filter: (t1.c1 = ANY ('{1,2,3}'::integer[]))
(21 rows)

select t1.c2,string_to_array(t1.c2,'a') as arr,count(*) from t1 where t1.c1=arr[1] group by t1.c2 having t1.c2=arr[1] order by 1;
 c2 | arr  | count 
----+------+-------
  1 | {1}  |     1
  2 | {2}  |     1
  3 | {3}  |     1
  4 | {4}  |     1
  5 | {5}  |     1
  6 | {6}  |     1
  7 | {7}  |     1
  8 | {8}  |     1
  9 | {9}  |     1
 10 | {10} |     1
 11 | {11} |     1
 12 | {12} |     1
(12 rows)

explain (costs off, verbose on) select t1.c2,string_to_array(t1.c2,'a') as arr,count(*) from t1 where t1.c1=arr[1] group by t1.c2 having t1.c2=arr[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c2, (string_to_array((c2)::text, 'a'::text)), (count(*))
   Merge Sort Key: t1.c2
   ->  GroupAggregate
         Output: c2, string_to_array((c2)::text, 'a'::text), count(*)
         Group By Key: t1.c2
         ->  Sort
               Output: c2
               Sort Key: t1.c2
               ->  Result
                     Output: c2
                     Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                     ->  Row Adapter
                           Output: c2, c1
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: c2, c1
                                 Distribute Key: c1
                                 Filter: (t1.c2 = t1.c1)
(18 rows)

select t1.c3, t1.c2 from t1 where t1.c1 > 1 AND t1.c2 in (select t2.c2 from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) order by 1,2;
 c3 | c2 
----+----
  2 |  2
  3 |  3
  4 |  4
  5 |  5
  6 |  6
  7 |  7
  8 |  8
  9 |  9
 10 | 10
(9 rows)

explain (costs off, verbose on) select t1.c3, t1.c2 from t1 where t1.c1 > 1 AND t1.c2 in (select t2.c2 from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c3, t1.c2
   Merge Sort Key: t1.c3, t1.c2
   ->  Sort
         Output: t1.c3, t1.c2
         Sort Key: t1.c3, t1.c2
         ->  Nested Loop Semi Join
               Output: t1.c3, t1.c2
               Join Filter: (t1.c2 = t2.c2)
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t1.c3, t1.c2
                     Distribute Key: t1.c2
                     ->  Row Adapter
                           Output: t1.c3, t1.c2
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: t1.c3, t1.c2
                                 Distribute Key: t1.c1
                                 Filter: (t1.c1 > 1)
               ->  Materialize
                     Output: t2.c2, t2.c1
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: t2.c2, t2.c1
                           Distribute Key: t2.c2
                           ->  Result
                                 Output: t2.c2, t2.c1
                                 Filter: (t2.c1 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
                                 ->  Row Adapter
                                       Output: t2.c2, t2.c1
                                       ->  CStore Scan on vec_unsupport_expression.t2
                                             Output: t2.c2, t2.c1
                                             Distribute Key: t2.c1
(31 rows)

 
select t1.c2, sum(t1.c3) from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2 order by t1.c2 limit 2;
 c2 | sum 
----+-----
  1 |   1
  2 |   2
(2 rows)

explain (costs off, verbose on) select t1.c2, sum(t1.c3) from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2 order by t1.c2 limit 2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t1.c3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Limit
   Output: c2, (pg_catalog.sum((sum(c3))))
   ->  Sort
         Output: c2, (pg_catalog.sum((sum(c3))))
         Sort Key: t1.c2
         ->  HashAggregate
               Output: c2, pg_catalog.sum((sum(c3)))
               Group By Key: t1.c2
               ->  Streaming (type: GATHER)
                     Output: c2, (sum(c3))
                     ->  HashAggregate
                           Output: c2, sum(c3)
                           Group By Key: t1.c2
                           ->  Result
                                 Output: c2, c3, c1
                                 Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                                 ->  Row Adapter
                                       Output: c2, c3, c1
                                       ->  CStore Scan on vec_unsupport_expression.t1
                                             Output: c2, c3, c1
                                             Distribute Key: c1
(21 rows)

select max(t1.c2) from t1 where t1.c1 < 4 and t1.c1=(string_to_array(t1.c2,'a'))[1];
 max 
-----
   3
(1 row)

explain (costs off, verbose on) select max(t1.c2) from t1 where t1.c1 < 4 and t1.c1=(string_to_array(t1.c2,'a'))[1];
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Aggregate
   Output: max((max(c2)))
   ->  Streaming (type: GATHER)
         Output: (max(c2))
         ->  Aggregate
               Output: max(c2)
               ->  Result
                     Output: c2, c1
                     Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                     ->  Row Adapter
                           Output: c2, c1
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: c2, c1
                                 Distribute Key: c1
                                 Filter: (t1.c1 < 4)
(15 rows)

select t1.c2, t2.c3, count(*) from t1,t2 where t1.c1 = t2.c2 and t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2,t2.c3 order by t1.c2;
 c2 | c3 | count 
----+----+-------
  1 |  1 |     1
  2 |  2 |     1
  3 |  3 |     1
  4 |  4 |     1
  5 |  5 |     1
  6 |  6 |     1
  7 |  7 |     1
  8 |  8 |     1
  9 |  9 |     1
 10 | 10 |     1
(10 rows)

explain (costs off, verbose on) select t1.c2, t2.c3, count(*) from t1,t2 where t1.c1 = t2.c2 and t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2,t2.c3 order by t1.c2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2, vec_unsupport_expression.t2.c3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c2, t2.c3, (count(*))
   Merge Sort Key: t1.c2
   ->  Sort
         Output: t1.c2, t2.c3, (count(*))
         Sort Key: t1.c2
         ->  HashAggregate
               Output: t1.c2, t2.c3, count(*)
               Group By Key: t1.c2, t2.c3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t1.c2, t2.c3
                     Distribute Key: t2.c3, t1.c2
                     ->  Nested Loop
                           Output: t1.c2, t2.c3
                           Join Filter: (t1.c1 = t2.c2)
                           ->  Streaming(type: BROADCAST)
                                 Output: t1.c2, t1.c1
                                 ->  Result
                                       Output: t1.c2, t1.c1
                                       Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                                       ->  Row Adapter
                                             Output: t1.c2, t1.c1
                                             ->  CStore Scan on vec_unsupport_expression.t1
                                                   Output: t1.c2, t1.c1
                                                   Distribute Key: t1.c1
                           ->  Row Adapter
                                 Output: t2.c3, t2.c2
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c3, t2.c2
                                       Distribute Key: t2.c1
(30 rows)

select t1.c2, t2.c3, sum(t1.c3) from t1,t2 where t1.c1 = t2.c2 and t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2,t2.c3 order by t1.c2 limit 2;
 c2 | c3 | sum 
----+----+-----
  1 |  1 |   1
  2 |  2 |   2
(2 rows)

explain (costs off, verbose on) select t1.c2, t2.c3, sum(t1.c3) from t1,t2 where t1.c1 = t2.c2 and t1.c1=(string_to_array(t1.c2,'a'))[1] group by t1.c2,t2.c3 order by t1.c2 limit 2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2, vec_unsupport_expression.t2.c3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: t1.c2, t2.c3, (sum(t1.c3))
   ->  Streaming (type: GATHER)
         Output: t1.c2, t2.c3, (sum(t1.c3))
         Merge Sort Key: t1.c2
         ->  Limit
               Output: t1.c2, t2.c3, (sum(t1.c3))
               ->  Sort
                     Output: t1.c2, t2.c3, (sum(t1.c3))
                     Sort Key: t1.c2
                     ->  HashAggregate
                           Output: t1.c2, t2.c3, sum(t1.c3)
                           Group By Key: t1.c2, t2.c3
                           ->  Streaming(type: REDISTRIBUTE)
                                 Output: t1.c2, t1.c3, t2.c3
                                 Distribute Key: t2.c3, t1.c2
                                 ->  Nested Loop
                                       Output: t1.c2, t1.c3, t2.c3
                                       Join Filter: (t1.c1 = t2.c2)
                                       ->  Streaming(type: BROADCAST)
                                             Output: t1.c2, t1.c3, t1.c1
                                             ->  Result
                                                   Output: t1.c2, t1.c3, t1.c1
                                                   Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                                                   ->  Row Adapter
                                                         Output: t1.c2, t1.c3, t1.c1
                                                         ->  CStore Scan on vec_unsupport_expression.t1
                                                               Output: t1.c2, t1.c3, t1.c1
                                                               Distribute Key: t1.c1
                                       ->  Row Adapter
                                             Output: t2.c3, t2.c2
                                             ->  CStore Scan on vec_unsupport_expression.t2
                                                   Output: t2.c3, t2.c2
                                                   Distribute Key: t2.c1
(34 rows)

select c1 from (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] union all select * from t2) as dt order by 1;
 c1 
----
  1
  1
  2
  2
  3
  3
  4
  4
  5
  5
  6
  6
  7
  7
  8
  8
  9
  9
 10
 10
 11
 12
(22 rows)

explain (costs off, verbose on) select c1 from (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] union all select * from t2) as dt order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2.c1, vec_unsupport_expression.t1.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".c1
   Merge Sort Key: "*SELECT* 1".c1
   ->  Sort
         Output: "*SELECT* 1".c1
         Sort Key: "*SELECT* 1".c1
         ->  Result
               Output: "*SELECT* 1".c1
               ->  Append
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".c1
                           ->  Result
                                 Output: t1.c1, t1.c2, t1.c3
                                 Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                                 ->  Row Adapter
                                       Output: t1.c1, t1.c2, t1.c3
                                       ->  CStore Scan on vec_unsupport_expression.t1
                                             Output: t1.c1, t1.c2, t1.c3
                                             Distribute Key: t1.c1
                     ->  Row Adapter
                           Output: t2.c1
                           ->  CStore Scan on vec_unsupport_expression.t2
                                 Output: t2.c1
                                 Distribute Key: t2.c1
(24 rows)

select c1 from (select * from t1 union all select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) as dt order by 1;
 c1 
----
  1
  1
  2
  2
  3
  3
  4
  4
  5
  5
  6
  6
  7
  7
  8
  8
  9
  9
 10
 10
 11
 12
(22 rows)

explain (costs off, verbose on) select c1 from (select * from t1 union all select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) as dt order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1
         Sort Key: t1.c1
         ->  Result
               Output: t1.c1
               ->  Append
                     ->  Row Adapter
                           Output: t1.c1
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: t1.c1
                                 Distribute Key: t1.c1
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".c1
                           ->  Result
                                 Output: t2.c1, t2.c2, t2.c3
                                 Filter: (t2.c1 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
                                 ->  Row Adapter
                                       Output: t2.c1, t2.c2, t2.c3
                                       ->  CStore Scan on vec_unsupport_expression.t2
                                             Output: t2.c1, t2.c2, t2.c3
                                             Distribute Key: t2.c1
(24 rows)

select * from (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] union all select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) as dt order by 1;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  1 |  1 |  1
  2 |  2 |  2
  2 |  2 |  2
  3 |  3 |  3
  3 |  3 |  3
  4 |  4 |  4
  4 |  4 |  4
  5 |  5 |  5
  5 |  5 |  5
  6 |  6 |  6
  6 |  6 |  6
  7 |  7 |  7
  7 |  7 |  7
  8 |  8 |  8
  8 |  8 |  8
  9 |  9 |  9
  9 |  9 |  9
 10 | 10 | 10
 10 | 10 | 10
 11 | 11 | 11
 12 | 12 | 12
(22 rows)

explain (costs off, verbose on) select * from (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1] union all select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1]) as dt order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t1.c2, t1.c3
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1, t1.c2, t1.c3
         Sort Key: t1.c1
         ->  Result
               Output: t1.c1, t1.c2, t1.c3
               ->  Append
                     ->  Result
                           Output: t1.c1, t1.c2, t1.c3
                           Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c2, t1.c3
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c2, t1.c3
                                       Distribute Key: t1.c1
                     ->  Result
                           Output: t2.c1, t2.c2, t2.c3
                           Filter: (t2.c1 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t2.c1, t2.c2, t2.c3
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c1, t2.c2, t2.c3
                                       Distribute Key: t2.c1
(25 rows)

select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c1 + 2)=(string_to_array(t2.c2,'a'))[1] order by 1;
 c1 | c1 
----+----
(0 rows)

explain (costs off, verbose on) select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c1 + 2)=(string_to_array(t2.c2,'a'))[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t2.c1
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1, t2.c1
         Sort Key: t1.c1
         ->  Hash Join
               Output: t1.c1, t2.c1
               Hash Cond: ((t1.c1 = t2.c1) AND ((t1.c1 + 2) = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint))
               ->  Row Adapter
                     Output: t1.c1
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1
                           Distribute Key: t1.c1
               ->  Hash
                     Output: t2.c1, t2.c2
                     ->  Row Adapter
                           Output: t2.c1, t2.c2
                           ->  CStore Scan on vec_unsupport_expression.t2
                                 Output: t2.c1, t2.c2
                                 Distribute Key: t2.c1
(21 rows)

select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c2 *2)=(string_to_array(t2.c2,'a'))[1] order by 1;
 c1 | c1 
----+----
(0 rows)

explain (costs off, verbose on) select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c2 *2)=(string_to_array(t2.c2,'a'))[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t2.c1
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1, t2.c1
         Sort Key: t1.c1
         ->  Hash Join
               Output: t1.c1, t2.c1
               Hash Cond: ((t1.c1 = t2.c1) AND ((t1.c2 * 2) = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint))
               ->  Row Adapter
                     Output: t1.c1, t1.c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1, t1.c2
                           Distribute Key: t1.c1
               ->  Hash
                     Output: t2.c1, t2.c2
                     ->  Row Adapter
                           Output: t2.c1, t2.c2
                           ->  CStore Scan on vec_unsupport_expression.t2
                                 Output: t2.c1, t2.c2
                                 Distribute Key: t2.c1
(21 rows)

select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c1 + t2.c2)=(string_to_array(t2.c2,'a'))[1] order by 1;
 c1 | c1 
----+----
(0 rows)

explain (costs off, verbose on) select t1.c1, t2.c1 from t1, t2 where t1.c1 = t2.c1 and (t1.c1 + t2.c2)=(string_to_array(t2.c2,'a'))[1] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t2.c1
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1, t2.c1
         Sort Key: t1.c1
         ->  Hash Join
               Output: t1.c1, t2.c1
               Hash Cond: (t1.c1 = t2.c1)
               Join Filter: ((t1.c1 + t2.c2) = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: t1.c1
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1
                           Distribute Key: t1.c1
               ->  Hash
                     Output: t2.c1, t2.c2
                     ->  Row Adapter
                           Output: t2.c1, t2.c2
                           ->  CStore Scan on vec_unsupport_expression.t2
                                 Output: t2.c1, t2.c2
                                 Distribute Key: t2.c1
(22 rows)

with q1(x) as (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1])
select * from q1 where q1.x=(string_to_array(x,'a'))[1] order by 1,2,3;
 x  | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  3 |  3 |  3
  4 |  4 |  4
  5 |  5 |  5
  6 |  6 |  6
  7 |  7 |  7
  8 |  8 |  8
  9 |  9 |  9
 10 | 10 | 10
 11 | 11 | 11
 12 | 12 | 12
(12 rows)

explain (costs off, verbose on) with q1(x) as (select * from t1 where t1.c1=(string_to_array(t1.c2,'a'))[1])
select * from q1 where q1.x=(string_to_array(x,'a'))[1] order by 1,2,3;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                      QUERY PLAN                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t1.c2, t1.c3
   Merge Sort Key: t1.c1, t1.c2, t1.c3
   ->  Sort
         Output: t1.c1, t1.c2, t1.c3
         Sort Key: t1.c1, t1.c2, t1.c3
         ->  Result
               Output: t1.c1, t1.c2, t1.c3
               Filter: ((t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint) AND (((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint = ((string_to_array((t1.c1)::text, 'a'::text))[1])::bigint))
               ->  Row Adapter
                     Output: t1.c1, t1.c2, t1.c3
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1, t1.c2, t1.c3
                           Distribute Key: t1.c1
(14 rows)

select t1.c1 from t1,t2 where t1.c1=t2.c1 and t1.c1=(string_to_array(t1.c2,'a'))[1] and t1.c2 =1;
 c1 
----
  1
(1 row)

explain (costs off, verbose on) select t1.c1 from t1,t2 where t1.c1=t2.c1 and t1.c1=(string_to_array(t1.c2,'a'))[1] and t1.c2 =1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1
   ->  Nested Loop
         Output: t1.c1
         Join Filter: (t1.c1 = t2.c1)
         ->  Result
               Output: t1.c1, t1.c2
               Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: t1.c1, t1.c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1, t1.c2
                           Distribute Key: t1.c1
                           Filter: (t1.c2 = 1)
         ->  Row Adapter
               Output: t2.c1
               ->  CStore Scan on vec_unsupport_expression.t2
                     Output: t2.c1
                     Distribute Key: t2.c1
(19 rows)

select t1.c1 from t2, t1 where t1.c1=t2.c1 and t1.c1=(string_to_array(t1.c2,'a'))[1] and t1.c2 =1;
 c1 
----
  1
(1 row)

explain (costs off, verbose on) select t1.c1 from t2, t1 where t1.c1=t2.c1 and t1.c1=(string_to_array(t1.c2,'a'))[1] and t1.c2 =1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2.c1, vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1
   ->  Nested Loop
         Output: t1.c1
         Join Filter: (t2.c1 = t1.c1)
         ->  Result
               Output: t1.c1, t1.c2
               Filter: (t1.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
               ->  Row Adapter
                     Output: t1.c1, t1.c2
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1, t1.c2
                           Distribute Key: t1.c1
                           Filter: (t1.c2 = 1)
         ->  Row Adapter
               Output: t2.c1
               ->  CStore Scan on vec_unsupport_expression.t2
                     Output: t2.c1
                     Distribute Key: t2.c1
(19 rows)

select * from t1 where t1.c2 in (select c1 from t2 where 1=1) and c2=(string_to_array(t1.c2,'a'))[1] order by 1,2,3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  3 |  3 |  3
  4 |  4 |  4
  5 |  5 |  5
  6 |  6 |  6
  7 |  7 |  7
  8 |  8 |  8
  9 |  9 |  9
 10 | 10 | 10
(10 rows)

explain (costs off, verbose on) select * from t1 where t1.c2 in (select c1 from t2 where 1=1) and c2=(string_to_array(t1.c2,'a'))[1] order by 1,2,3;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t1.c2, t1.c3
   Merge Sort Key: t1.c1, t1.c2, t1.c3
   ->  Sort
         Output: t1.c1, t1.c2, t1.c3
         Sort Key: t1.c1, t1.c2, t1.c3
         ->  Nested Loop Semi Join
               Output: t1.c1, t1.c2, t1.c3
               Join Filter: (t1.c2 = t2.c1)
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t1.c1, t1.c2, t1.c3
                     Distribute Key: t1.c2
                     ->  Result
                           Output: t1.c1, t1.c2, t1.c3
                           Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c2, t1.c3
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c2, t1.c3
                                       Distribute Key: t1.c1
               ->  Materialize
                     Output: t2.c1
                     ->  Result
                           Output: t2.c1
                           Filter: (t2.c1 = ((string_to_array((t2.c1)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t2.c1
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c1
                                       Distribute Key: t2.c1
(30 rows)

select * from t1 where t1.c2 in (select c1 from t2 where 1=1 and c2=(string_to_array(t2.c2,'a'))[1]) and c2=(string_to_array(t1.c2,'a'))[1] order by 1,2,3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  3 |  3 |  3
  4 |  4 |  4
  5 |  5 |  5
  6 |  6 |  6
  7 |  7 |  7
  8 |  8 |  8
  9 |  9 |  9
 10 | 10 | 10
(10 rows)

explain (costs off, verbose on) select * from t1 where t1.c2 in (select c1 from t2 where 1=1 and c2=(string_to_array(t2.c2,'a'))[1]) and c2=(string_to_array(t1.c2,'a'))[1] order by 1,2,3;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                  QUERY PLAN                                                                                   
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, t1.c2, t1.c3
   Merge Sort Key: t1.c1, t1.c2, t1.c3
   ->  Sort
         Output: t1.c1, t1.c2, t1.c3
         Sort Key: t1.c1, t1.c2, t1.c3
         ->  Nested Loop Semi Join
               Output: t1.c1, t1.c2, t1.c3
               Join Filter: (t1.c2 = t2.c1)
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t1.c1, t1.c2, t1.c3
                     Distribute Key: t1.c2
                     ->  Result
                           Output: t1.c1, t1.c2, t1.c3
                           Filter: (t1.c2 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c2, t1.c3
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c2, t1.c3
                                       Distribute Key: t1.c1
               ->  Materialize
                     Output: t2.c1, t2.c2
                     ->  Result
                           Output: t2.c1, t2.c2
                           Filter: ((t2.c2 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint) AND (t2.c1 = ((string_to_array((t2.c1)::text, 'a'::text))[1])::bigint))
                           ->  Row Adapter
                                 Output: t2.c1, t2.c2
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c1, t2.c2
                                       Distribute Key: t2.c1
(30 rows)

set enable_hashjoin to off;
set enable_nestloop to off;
explain (costs off, verbose on)
select string_to_array(t1.c1, '-') arr2, string_to_array(t2.c1, '-') arr3
from t1, t2
where arr2[1] = arr3[1] order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (string_to_array((t1.c1)::text, '-'::text)), (string_to_array((t2.c1)::text, '-'::text))
   Merge Sort Key: (string_to_array((t1.c1)::text, '-'::text)), (string_to_array((t2.c1)::text, '-'::text))
   ->  Sort
         Output: (string_to_array((t1.c1)::text, '-'::text)), (string_to_array((t2.c1)::text, '-'::text))
         Sort Key: (string_to_array((t1.c1)::text, '-'::text)), (string_to_array((t2.c1)::text, '-'::text))
         ->  Merge Join
               Output: string_to_array((t1.c1)::text, '-'::text), string_to_array((t2.c1)::text, '-'::text)
               Merge Cond: (((string_to_array((t1.c1)::text, '-'::text))[1]) = ((string_to_array((t2.c1)::text, '-'::text))[1]))
               ->  Sort
                     Output: t1.c1, ((string_to_array((t1.c1)::text, '-'::text))[1])
                     Sort Key: ((string_to_array((t1.c1)::text, '-'::text))[1])
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: t1.c1, ((string_to_array((t1.c1)::text, '-'::text))[1])
                           Distribute Key: ((string_to_array((t1.c1)::text, '-'::text))[1])
                           ->  Result
                                 Output: t1.c1, (string_to_array((t1.c1)::text, '-'::text))[1]
                                 ->  Row Adapter
                                       Output: t1.c1
                                       ->  CStore Scan on vec_unsupport_expression.t1
                                             Output: t1.c1
                                             Distribute Key: t1.c1
               ->  Sort
                     Output: t2.c1, ((string_to_array((t2.c1)::text, '-'::text))[1])
                     Sort Key: ((string_to_array((t2.c1)::text, '-'::text))[1])
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: t2.c1, ((string_to_array((t2.c1)::text, '-'::text))[1])
                           Distribute Key: ((string_to_array((t2.c1)::text, '-'::text))[1])
                           ->  Result
                                 Output: t2.c1, (string_to_array((t2.c1)::text, '-'::text))[1]
                                 ->  Row Adapter
                                       Output: t2.c1
                                       ->  CStore Scan on vec_unsupport_expression.t2
                                             Output: t2.c1
                                             Distribute Key: t2.c1
(35 rows)

select string_to_array(t1.c1, '-') arr2, string_to_array(t2.c1, '-') arr3
from t1, t2
where arr2[1] = arr3[1] order by 1,2;
 arr2 | arr3 
------+------
 {1}  | {1}
 {10} | {10}
 {2}  | {2}
 {3}  | {3}
 {4}  | {4}
 {5}  | {5}
 {6}  | {6}
 {7}  | {7}
 {8}  | {8}
 {9}  | {9}
(10 rows)

reset enable_hashjoin;
reset enable_nestloop;
--- insert/update/delete
update t1 set c2 = c2 * 10 where t1.c1 in (select t2.c2 from t2 where t2.c1=(string_to_array(t1.c2,'a'))[1] limit 2);
explain (costs off, verbose on) update t1 set c2 = c2 * 10 where t1.c1 in (select t2.c2 from t2 where t2.c1=(string_to_array(t1.c2,'a'))[1] limit 2);
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2.c1, vec_unsupport_expression.t1.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Update on vec_unsupport_expression.t1
               ->  CStore Scan on vec_unsupport_expression.t1
                     Output: t1.c1, (t1.c2 * 10), t1.c3, t1.c1, t1.c2, t1.ctid, t1.tableoid, t1.xc_node_id
                     Distribute Key: t1.c1
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Limit
                             Output: t2.c2
                             ->  Sort
                                   Output: t2.c2
                                   Sort Key: t2.c2
                                   ->  Result
                                         Output: t2.c2
                                         Filter: (t2.c1 = ((string_to_array((t1.c2)::text, 'a'::text))[1])::bigint)
                                         ->  Materialize
                                               Output: t2.c2, t2.c1
                                               ->  Streaming(type: BROADCAST)
                                                     Output: t2.c2, t2.c1
                                                     ->  Row Adapter
                                                           Output: t2.c2, t2.c1
                                                           ->  CStore Scan on vec_unsupport_expression.t2
                                                                 Output: t2.c2, t2.c1
                                                                 Distribute Key: t2.c1
(25 rows)

INSERT into t1 select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1] and t2.c2<2;
explain (costs off, verbose on) INSERT into t1 select * from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1] and t2.c2<2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Insert on vec_unsupport_expression.t1
               ->  Vector Adapter
                     Output: t2.c1, t2.c2, t2.c3
                     ->  Result
                           Output: t2.c1, t2.c2, t2.c3
                           Filter: (t2.c1 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
                           ->  Row Adapter
                                 Output: t2.c1, t2.c2, t2.c3
                                 ->  CStore Scan on vec_unsupport_expression.t2
                                       Output: t2.c1, t2.c2, t2.c3
                                       Distribute Key: t2.c1
                                       Filter: (t2.c2 < 2)
(14 rows)

DELETE from t1 where t1.c1 in (select c2 from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1] and t2.c3=10 limit 1);
explain (costs off, verbose on) DELETE from t1 where t1.c1 in (select c2 from t2 where t2.c1=(string_to_array(t2.c2,'a'))[1] and t2.c3=10 limit 1);
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c3, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Delete on vec_unsupport_expression.t1
               ->  Vector Adapter
                     Output: t1.c1, t1.ctid, t1.tableoid, t1.xc_node_id, t2.c2
                     ->  Hash Semi Join
                           Output: t1.c1, t1.ctid, t1.tableoid, t1.xc_node_id, t2.c2
                           Hash Cond: (t1.c1 = t2.c2)
                           ->  Row Adapter
                                 Output: t1.c1, t1.ctid, t1.tableoid, t1.xc_node_id
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.ctid, t1.tableoid, t1.xc_node_id
                                       Distribute Key: t1.c1
                           ->  Hash
                                 Output: t2.c2
                                 ->  Streaming(type: REDISTRIBUTE)
                                       Output: t2.c2
                                       Distribute Key: t2.c2
                                       ->  Limit
                                             Output: t2.c2
                                             ->  Streaming(type: BROADCAST)
                                                   Output: t2.c2
                                                   ->  Limit
                                                         Output: t2.c2
                                                         ->  Result
                                                               Output: t2.c2
                                                               Filter: (t2.c1 = ((string_to_array((t2.c2)::text, 'a'::text))[1])::bigint)
                                                               ->  Row Adapter
                                                                     Output: t2.c2, t2.c1
                                                                     ->  CStore Scan on vec_unsupport_expression.t2
                                                                           Output: t2.c2, t2.c1
                                                                           Distribute Key: t2.c1
                                                                           Filter: (t2.c3 = 10)
(33 rows)

create table t10(c1 int, c2 int, c3 varchar, c4 nvarchar2) with (orientation=column) distribute by hash (c1);
insert into t10 select v,v,v,v from generate_series(1,10) as v;
select * from t10 where cast(c1 as numeric)=(string_to_array(t10.c2,'a'))[1] and c2 in (5,6,7,8) order by 1;
 c1 | c2 | c3 | c4 
----+----+----+----
  5 |  5 | 5  | 5
  6 |  6 | 6  | 6
  7 |  7 | 7  | 7
  8 |  8 | 8  | 8
(4 rows)

explain (costs off, verbose on) select * from t10 where cast(c1 as numeric)=(string_to_array(t10.c2,'a'))[1] and c2 in (5,6,7,8) order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t10.c1, vec_unsupport_expression.t10.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c1, c2, c3, c4
   Merge Sort Key: t10.c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: t10.c1
         ->  Result
               Output: c1, c2, c3, c4
               Filter: ((t10.c1)::numeric = ((string_to_array((t10.c2)::text, 'a'::text))[1])::numeric)
               ->  Row Adapter
                     Output: c1, c2, c3, c4
                     ->  CStore Scan on vec_unsupport_expression.t10
                           Output: c1, c2, c3, c4
                           Distribute Key: c1
                           Filter: (t10.c2 = ANY ('{5,6,7,8}'::integer[]))
(15 rows)

select * from t10 where c4=(string_to_array(t10.c2,'4'))[2] order by 1;
 c1 | c2 | c3 | c4 
----+----+----+----
(0 rows)

explain (costs off, verbose on) select * from t10 where c4=(string_to_array(t10.c2,'4'))[2] order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t10.c1, vec_unsupport_expression.t10.c4) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c1, c2, c3, c4
   Merge Sort Key: t10.c1
   ->  Sort
         Output: c1, c2, c3, c4
         Sort Key: t10.c1
         ->  Result
               Output: c1, c2, c3, c4
               Filter: ((t10.c4)::text = (string_to_array((t10.c2)::text, '4'::text))[2])
               ->  Row Adapter
                     Output: c1, c2, c3, c4
                     ->  CStore Scan on vec_unsupport_expression.t10
                           Output: c1, c2, c3, c4
                           Distribute Key: c1
(14 rows)

select c1 from t10 where c1=(string_to_array(t10.c2,'a'))[1] and 12 = ANY (array[2275,1245,12]) order by 1 limit 1;
 c1 
----
  1
(1 row)

explain (costs off, verbose on) select c1 from t10 where c1=(string_to_array(t10.c2,'a'))[1] and 12 = ANY (array[2275,1245,12]) order by 1 limit 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t10.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Limit
   Output: c1
   ->  Streaming (type: GATHER)
         Output: c1
         Merge Sort Key: t10.c1
         ->  Limit
               Output: c1
               ->  Sort
                     Output: c1
                     Sort Key: t10.c1
                     ->  Result
                           Output: c1
                           Filter: (t10.c1 = ((string_to_array((t10.c2)::text, 'a'::text))[1])::bigint)
                           ->  Result
                                 Output: c1, c2
                                 One-Time Filter: (12 = ANY ('{2275,1245,12}'::integer[]))
                                 ->  Row Adapter
                                       Output: c1, c2
                                       ->  CStore Scan on vec_unsupport_expression.t10
                                             Output: c1, c2
                                             Distribute Key: c1
(21 rows)

--- T_RowExpr
CREATE TABLE t2_col(a int, b int)with (orientation = column);
insert into t2_col values (1,2);
select a from t2_col where table_data_skewness(row(a), 'H') > 5;
 a 
---
 1
(1 row)

explain (costs off, verbose on) select a from t2_col where table_data_skewness(row(a), 'H') > 5;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2_col.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: a
   ->  Result
         Output: a
         Filter: (table_data_skewness(ROW(t2_col.a), 'H'::"char") > 5)
         ->  Row Adapter
               Output: a
               ->  CStore Scan on vec_unsupport_expression.t2_col
                     Output: a
                     Distribute Key: a
(10 rows)

/* add_key_column_for_plan create_stream_plan*/
select a from t2_col join t1 on table_data_skewness(row(a), 'H')=t1.c1;
 a 
---
(0 rows)

explain (costs off, verbose on) select a from t2_col join t1 on table_data_skewness(row(a), 'H')=t1.c1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2_col.a, vec_unsupport_expression.t1.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t2_col.a
   ->  Hash Join
         Output: t2_col.a
         Hash Cond: ((table_data_skewness(ROW(t2_col.a), 'H'::"char")) = t1.c1)
         ->  Streaming(type: REDISTRIBUTE)
               Output: t2_col.a, (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
               Distribute Key: (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
               ->  Result
                     Output: t2_col.a, table_data_skewness(ROW(t2_col.a), 'H'::"char")
                     ->  Row Adapter
                           Output: t2_col.a
                           ->  CStore Scan on vec_unsupport_expression.t2_col
                                 Output: t2_col.a
                                 Distribute Key: t2_col.a
         ->  Hash
               Output: t1.c1
               ->  Row Adapter
                     Output: t1.c1
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1
                           Distribute Key: t1.c1
(22 rows)

select table_data_skewness(row(a), 'H') from t2_col;
 table_data_skewness 
---------------------
                  10
(1 row)

explain (costs off, verbose on) select table_data_skewness(row(a), 'H') from t2_col;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2_col.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                            QUERY PLAN                            
------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (table_data_skewness(ROW(a), 'H'::"char"))
   ->  Result
         Output: table_data_skewness(ROW(a), 'H'::"char")
         ->  Row Adapter
               Output: a
               ->  CStore Scan on vec_unsupport_expression.t2_col
                     Output: a
                     Distribute Key: a
(9 rows)

select * from table_skewness('t2_col', 'a') order by 1, 2, 3;
 seqnum | num |  ratio   
--------+-----+----------
 10     | 1   | 100.000%
(1 row)

explain (costs off, verbose on) select * from table_skewness('t2_col', 'a') order by 1, 2, 3;
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Sort
   Output: seqnum, num, ratio
   Sort Key: table_skewness.seqnum, table_skewness.num, table_skewness.ratio
   ->  Function Scan on pg_catalog.table_skewness
         Output: seqnum, num, ratio
         Function Call: table_skewness('t2_col'::text, 'a'::text, '0'::text)
(6 rows)

select table_data_skewness(row(a), 'H') from t2_col where table_data_skewness(row(a), 'H') > 5; 
 table_data_skewness 
---------------------
                  10
(1 row)

explain (costs off, verbose on) select table_data_skewness(row(a), 'H') from t2_col where table_data_skewness(row(a), 'H') > 5;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2_col.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (table_data_skewness(ROW(a), 'H'::"char"))
   ->  Result
         Output: table_data_skewness(ROW(a), 'H'::"char")
         Filter: (table_data_skewness(ROW(t2_col.a), 'H'::"char") > 5)
         ->  Row Adapter
               Output: a
               ->  CStore Scan on vec_unsupport_expression.t2_col
                     Output: a
                     Distribute Key: a
(10 rows)

explain (costs off, verbose on) select table_data_skewness(row(a), 'H') from t2_col join t1 on table_data_skewness(row(a), 'H')=t1.c1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t2_col.a, vec_unsupport_expression.t1.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
   ->  Hash Join
         Output: (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
         Hash Cond: ((table_data_skewness(ROW(t2_col.a), 'H'::"char")) = t1.c1)
         ->  Streaming(type: REDISTRIBUTE)
               Output: t2_col.a, (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
               Distribute Key: (table_data_skewness(ROW(t2_col.a), 'H'::"char"))
               ->  Result
                     Output: t2_col.a, table_data_skewness(ROW(t2_col.a), 'H'::"char")
                     ->  Row Adapter
                           Output: t2_col.a
                           ->  CStore Scan on vec_unsupport_expression.t2_col
                                 Output: t2_col.a
                                 Distribute Key: t2_col.a
         ->  Hash
               Output: t1.c1
               ->  Row Adapter
                     Output: t1.c1
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c1
                           Distribute Key: t1.c1
(22 rows)

--- partition table
create table test3(
c1 int default 101, 
c2 char(100) default 'abcdafeawr',
c3 date default '2018-01-01',
c4 text default 'afeaerw',
c5 numeric(38,15))with(orientation=column) 
partition by range(c1)
(partition p1 values less than(100),
 partition p2 values less than(200),
 partition p3 values less than(300),
 partition p4 values less than(500));
select c2, string_to_array(c2,'o','i') as arref from test3 where c2=arref[1];
 c2 | arref 
----+-------
(0 rows)

explain (costs off, verbose on) select c2, string_to_array(c2,'o','i') as arref from test3 where c2=arref[1];
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.test3.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: c2, (string_to_array((c2)::text, 'o'::text, 'i'::text))
   ->  Result
         Output: c2, string_to_array((c2)::text, 'o'::text, 'i'::text)
         Filter: ((test3.c2)::text = (string_to_array((test3.c2)::text, 'o'::text, 'i'::text))[1])
         ->  Partition Iterator
               Output: c2
               Iterations: 4
               ->  Row Adapter
                     Output: c2
                     ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                           Output: c2
                           Distribute Key: c1
                           Selected Partitions:  1..4
(14 rows)

-- partition table have unsupport expr, the upper stream operator need add result operator--
set enable_broadcast=off;
select string_to_array(t1.c2, '-') arr1, string_to_array(test3.c2, '-') arr2 from t1, test3 where  arr2[1]=arr1[1];
 arr1 | arr2 
------+------
(0 rows)

explain (costs off, verbose on) select string_to_array(t1.c2, '-') arr1, string_to_array(test3.c2, '-') arr2 from t1, test3 where  arr2[1]=arr1[1];
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.test3.c1, vec_unsupport_expression.test3.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (string_to_array((t1.c2)::text, '-'::text)), (string_to_array((test3.c2)::text, '-'::text))
   ->  Hash Join
         Output: string_to_array((t1.c2)::text, '-'::text), string_to_array((test3.c2)::text, '-'::text)
         Hash Cond: (((string_to_array((test3.c2)::text, '-'::text))[1]) = ((string_to_array((t1.c2)::text, '-'::text))[1]))
         ->  Streaming(type: REDISTRIBUTE)
               Output: test3.c2, ((string_to_array((test3.c2)::text, '-'::text))[1])
               Distribute Key: ((string_to_array((test3.c2)::text, '-'::text))[1])
               ->  Result
                     Output: test3.c2, (string_to_array((test3.c2)::text, '-'::text))[1]
                     ->  Partition Iterator
                           Output: test3.c2
                           Iterations: 4
                           ->  Row Adapter
                                 Output: test3.c2
                                 ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                                       Output: test3.c2
                                       Distribute Key: test3.c1
                                       Selected Partitions:  1..4
         ->  Hash
               Output: t1.c2, ((string_to_array((t1.c2)::text, '-'::text))[1])
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t1.c2, ((string_to_array((t1.c2)::text, '-'::text))[1])
                     Distribute Key: ((string_to_array((t1.c2)::text, '-'::text))[1])
                     ->  Result
                           Output: t1.c2, (string_to_array((t1.c2)::text, '-'::text))[1]
                           ->  Row Adapter
                                 Output: t1.c2
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c2
                                       Distribute Key: t1.c1
(31 rows)

set enable_broadcast=on;
-- nestloop parameterized path--
set enable_mergejoin=off;
set enable_hashjoin=off;
create index index11 on t1(c1);
create index index21 on t2(c1);
select regexp_split_to_array(t1.c2, '-') arr1
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t1.c2
and t1.c2 = 10;
 arr1 
------
 {10}
(1 row)

explain (costs off, verbose on) select regexp_split_to_array(t1.c2, '-') arr1
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t1.c2
and t1.c2 = 10;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (regexp_split_to_array((t1.c2)::text, '-'::text))
   ->  Nested Loop
         Output: regexp_split_to_array((t1.c2)::text, '-'::text)
         Join Filter: (t1.c1 = t2.c1)
         ->  Result
               Output: t1.c2, t1.c1
               Filter: (((regexp_split_to_array((t1.c2)::text, '-'::text))[1])::bigint = 10)
               ->  Row Adapter
                     Output: t1.c2, t1.c1
                     ->  CStore Scan on vec_unsupport_expression.t1
                           Output: t1.c2, t1.c1
                           Distribute Key: t1.c1
                           Filter: (t1.c2 = 10)
         ->  Row Adapter
               Output: t2.c1
               ->  CStore Scan on vec_unsupport_expression.t2
                     Output: t2.c1
                     Distribute Key: t2.c1
(19 rows)

select regexp_split_to_array(t2.c2, '-') arr1
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t2.c2
and t2.c2 = 10;
 arr1 
------
(0 rows)

explain (costs off, verbose on) select regexp_split_to_array(t2.c2, '-') arr1
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t2.c2
and t2.c2 = 10;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (regexp_split_to_array((t2.c2)::text, '-'::text))
   ->  Nested Loop
         Output: regexp_split_to_array((t2.c2)::text, '-'::text)
         Join Filter: (t1.c1 = t2.c1)
         ->  Result
               Output: t2.c2, t2.c1
               Filter: (((regexp_split_to_array((t2.c2)::text, '-'::text))[1])::bigint = 10)
               ->  Row Adapter
                     Output: t2.c2, t2.c1
                     ->  CStore Scan on vec_unsupport_expression.t2
                           Output: t2.c2, t2.c1
                           Distribute Key: t2.c1
                           Filter: (t2.c2 = 10)
         ->  Row Adapter
               Output: t1.c1
               ->  CStore Scan on vec_unsupport_expression.t1
                     Output: t1.c1
                     Distribute Key: t1.c1
(19 rows)

select t1.c1, regexp_split_to_array(t1.c2, '-') arr1, regexp_split_to_array(t2.c2, '-') arr2
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t1.c2
and arr2[1]=t2.c2
order by 1,2,3;
 c1 | arr1 | arr2 
----+------+------
  1 | {1}  | {1}
  1 | {10} | {1}
  2 | {20} | {2}
  3 | {30} | {3}
  4 | {40} | {4}
  5 | {50} | {5}
  6 | {60} | {6}
  7 | {70} | {7}
  8 | {80} | {8}
  9 | {90} | {9}
(10 rows)

explain (costs off, verbose on) select t1.c1, regexp_split_to_array(t1.c2, '-') arr1, regexp_split_to_array(t2.c2, '-') arr2
from t1,t2
where t1.c1=t2.c1
and arr1[1]=t1.c2
and arr2[1]=t2.c2
order by 1,2,3;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.t1.c2, vec_unsupport_expression.t2.c1, vec_unsupport_expression.t2.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, (regexp_split_to_array((t1.c2)::text, '-'::text)), (regexp_split_to_array((t2.c2)::text, '-'::text))
   Merge Sort Key: t1.c1, (regexp_split_to_array((t1.c2)::text, '-'::text)), (regexp_split_to_array((t2.c2)::text, '-'::text))
   ->  Sort
         Output: t1.c1, (regexp_split_to_array((t1.c2)::text, '-'::text)), (regexp_split_to_array((t2.c2)::text, '-'::text))
         Sort Key: t1.c1, (regexp_split_to_array((t1.c2)::text, '-'::text)), (regexp_split_to_array((t2.c2)::text, '-'::text))
         ->  Nested Loop
               Output: t1.c1, regexp_split_to_array((t1.c2)::text, '-'::text), regexp_split_to_array((t2.c2)::text, '-'::text)
               Join Filter: (t1.c1 = t2.c1)
               ->  Result
                     Output: t1.c1, t1.c2
                     Filter: (((regexp_split_to_array((t1.c2)::text, '-'::text))[1])::bigint = t1.c2)
                     ->  Row Adapter
                           Output: t1.c1, t1.c2
                           ->  CStore Scan on vec_unsupport_expression.t1
                                 Output: t1.c1, t1.c2
                                 Distribute Key: t1.c1
               ->  Result
                     Output: t2.c2, t2.c1
                     Filter: (((regexp_split_to_array((t2.c2)::text, '-'::text))[1])::bigint = t2.c2)
                     ->  Row Adapter
                           Output: t2.c2, t2.c1
                           ->  CStore Scan on vec_unsupport_expression.t2
                                 Output: t2.c2, t2.c1
                                 Distribute Key: t2.c1
(25 rows)

set enable_mergejoin=on;
set enable_hashjoin=on;
-- append path rel->reltargetlist with vector engine unsupport expr --
insert into test3 values(100);
insert into test3 values(200);
insert into test3 values(300);
select c1,table_data_skewness(row(c1), 'H') as res1,c1 from t1
union all
select c1,table_data_skewness(row(c1), 'H') as res1,c1 from test3
order by 1;
 c1  | res1 | c1  
-----+------+-----
   1 |   10 |   1
   1 |   10 |   1
   2 |   10 |   2
   3 |    9 |   3
   4 |    1 |   4
   5 |    4 |   5
   6 |    8 |   6
   7 |    5 |   7
   8 |    4 |   8
   9 |   10 |   9
  11 |    9 |  11
  12 |    4 |  12
 100 |    1 | 100
 200 |   10 | 200
 300 |    2 | 300
(15 rows)

explain (costs off, verbose on) select c1,table_data_skewness(row(c1), 'H') as res1,c1 from t1
union all
select c1,table_data_skewness(row(c1), 'H') as res1,c1 from test3
order by 1;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.test3.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), t1.c1
   Merge Sort Key: t1.c1
   ->  Sort
         Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), t1.c1
         Sort Key: t1.c1
         ->  Result
               Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), t1.c1
               ->  Append
                     ->  Result
                           Output: t1.c1, table_data_skewness(ROW(t1.c1), 'H'::"char"), t1.c1
                           ->  Row Adapter
                                 Output: t1.c1, t1.c1, t1.c1
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c1, t1.c1
                                       Distribute Key: t1.c1
                     ->  Result
                           Output: test3.c1, table_data_skewness(ROW(test3.c1), 'H'::"char"), test3.c1
                           ->  Partition Iterator
                                 Output: test3.c1, test3.c1, test3.c1
                                 Iterations: 4
                                 ->  Row Adapter
                                       Output: test3.c1, test3.c1, test3.c1
                                       ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                                             Output: test3.c1, test3.c1, test3.c1
                                             Distribute Key: test3.c1
                                             Selected Partitions:  1..4
(27 rows)

select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2 from t1
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2 from test3
order by 1,2;
 c1  | res1 | res2 
-----+------+------
   1 |   10 | 0.00
   1 |   10 | 0.00
   2 |   10 | 0.00
   3 |    9 | 0.00
   4 |    1 | 0.00
   5 |    4 | 0.00
   6 |    8 | 0.00
   7 |    5 | 0.00
   8 |    4 | 0.00
   9 |   10 | 0.00
  11 |    9 | 0.00
  12 |    4 | 0.00
 100 |    1 | 0.00
 200 |   10 | 0.00
 300 |    2 | 0.00
(15 rows)

explain (costs off, verbose on) select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2 from t1
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2 from test3
order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.test3.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2))
   Merge Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
   ->  Sort
         Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2))
         Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
         ->  Result
               Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2))
               ->  Append
                     ->  Result
                           Output: t1.c1, table_data_skewness(ROW(t1.c1), 'H'::"char"), 0.00::numeric(7,2)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c1
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c1
                                       Distribute Key: t1.c1
                     ->  Result
                           Output: test3.c1, table_data_skewness(ROW(test3.c1), 'H'::"char"), 0.00::numeric(7,2)
                           ->  Partition Iterator
                                 Output: test3.c1, test3.c1
                                 Iterations: 4
                                 ->  Row Adapter
                                       Output: test3.c1, test3.c1
                                       ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                                             Output: test3.c1, test3.c1
                                             Distribute Key: test3.c1
                                             Selected Partitions:  1..4
(27 rows)

select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1 from t1 where table_data_skewness(row(c2), 'H')>0
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1 from test3 where table_data_skewness(row(c1), 'H')>0
order by 1,2;
 c1  | res1 | res2 | c1  
-----+------+------+-----
   1 |   10 | 0.00 |   1
   1 |   10 | 0.00 |   1
   2 |   10 | 0.00 |   2
   3 |    9 | 0.00 |   3
   4 |    1 | 0.00 |   4
   5 |    4 | 0.00 |   5
   6 |    8 | 0.00 |   6
   8 |    4 | 0.00 |   8
   9 |   10 | 0.00 |   9
  11 |    9 | 0.00 |  11
  12 |    4 | 0.00 |  12
 100 |    1 | 0.00 | 100
 200 |   10 | 0.00 | 200
 300 |    2 | 0.00 | 300
(14 rows)

explain (costs off, verbose on) select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1 from t1 where table_data_skewness(row(c2), 'H')>0
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1 from test3 where table_data_skewness(row(c1), 'H')>0
order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.test3.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), t1.c1
   Merge Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
   ->  Sort
         Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), t1.c1
         Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
         ->  Result
               Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), t1.c1
               ->  Append
                     ->  Result
                           Output: t1.c1, table_data_skewness(ROW(t1.c1), 'H'::"char"), 0.00::numeric(7,2), t1.c1
                           Filter: (table_data_skewness(ROW(t1.c2), 'H'::"char") > 0)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c2
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c2
                                       Distribute Key: t1.c1
                     ->  Result
                           Output: test3.c1, table_data_skewness(ROW(test3.c1), 'H'::"char"), 0.00::numeric(7,2), test3.c1
                           Filter: (table_data_skewness(ROW(test3.c1), 'H'::"char") > 0)
                           ->  Partition Iterator
                                 Output: test3.c1
                                 Iterations: 4
                                 ->  Row Adapter
                                       Output: test3.c1
                                       ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                                             Output: test3.c1
                                             Distribute Key: test3.c1
                                             Selected Partitions:  1..4
(29 rows)

select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1=c3 from t1 where table_data_skewness(row(c2), 'H')>0
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1=c1+1 from test3 where table_data_skewness(row(c1), 'H')>0
order by 1,2;
 c1  | res1 | res2 | ?column? 
-----+------+------+----------
   1 |   10 | 0.00 | t
   1 |   10 | 0.00 | t
   2 |   10 | 0.00 | t
   3 |    9 | 0.00 | t
   4 |    1 | 0.00 | t
   5 |    4 | 0.00 | t
   6 |    8 | 0.00 | t
   8 |    4 | 0.00 | t
   9 |   10 | 0.00 | t
  11 |    9 | 0.00 | t
  12 |    4 | 0.00 | t
 100 |    1 | 0.00 | f
 200 |   10 | 0.00 | f
 300 |    2 | 0.00 | f
(14 rows)

explain (costs off, verbose on) select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1=c3 from t1 where table_data_skewness(row(c2), 'H')>0
union all
select c1,table_data_skewness(row(c1), 'H') as res1, cast(0 as decimal(7,2)) as res2,c1=c1+1 from test3 where table_data_skewness(row(c1), 'H')>0
order by 1,2;
WARNING:  Statistics in some tables or columns(vec_unsupport_expression.t1.c1, vec_unsupport_expression.test3.c1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), ((t1.c1 = t1.c3))
   Merge Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
   ->  Sort
         Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), ((t1.c1 = t1.c3))
         Sort Key: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char"))
         ->  Result
               Output: t1.c1, (table_data_skewness(ROW(t1.c1), 'H'::"char")), (0.00::numeric(7,2)), ((t1.c1 = t1.c3))
               ->  Append
                     ->  Result
                           Output: t1.c1, table_data_skewness(ROW(t1.c1), 'H'::"char"), 0.00::numeric(7,2), (t1.c1 = t1.c3)
                           Filter: (table_data_skewness(ROW(t1.c2), 'H'::"char") > 0)
                           ->  Row Adapter
                                 Output: t1.c1, t1.c3, t1.c2
                                 ->  CStore Scan on vec_unsupport_expression.t1
                                       Output: t1.c1, t1.c3, t1.c2
                                       Distribute Key: t1.c1
                     ->  Result
                           Output: test3.c1, table_data_skewness(ROW(test3.c1), 'H'::"char"), 0.00::numeric(7,2), (test3.c1 = (test3.c1 + 1))
                           Filter: (table_data_skewness(ROW(test3.c1), 'H'::"char") > 0)
                           ->  Partition Iterator
                                 Output: test3.c1
                                 Iterations: 4
                                 ->  Row Adapter
                                       Output: test3.c1
                                       ->  Partitioned CStore Scan on vec_unsupport_expression.test3
                                             Output: test3.c1
                                             Distribute Key: test3.c1
                                             Selected Partitions:  1..4
(29 rows)

drop schema vec_unsupport_expression cascade;
NOTICE:  drop cascades to 5 other objects
DETAIL:  drop cascades to table t1
drop cascades to table t2
drop cascades to table t10
drop cascades to table t2_col
drop cascades to table test3
