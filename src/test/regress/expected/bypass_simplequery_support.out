--
--simple query support
--
set enable_opfusion=on;
set enable_bitmapscan=off;
set enable_seqscan=off;
set opfusion_debug_mode = 'log';
set log_min_messages=debug;
set logging_module = 'on(OPFUSION)';
set sql_beta_feature = 'index_cost_with_leaf_pages_only';
-- create table
drop table if exists test_bypass_sq1;
NOTICE:  table "test_bypass_sq1" does not exist, skipping
create table test_bypass_sq1(col1 int, col2 int, col3 text);
create index itest_bypass_sq1 on test_bypass_sq1(col1,col2);
-- bypass insert data
 explain insert into test_bypass_sq1 values (0,0,'test_insert');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (0,0,'test_insert');
 explain insert into test_bypass_sq1 values (0,1,'test_insert');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (0,1,'test_insert');
 explain insert into test_bypass_sq1 values (1,1,'test_insert');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (1,1,'test_insert');
 explain insert into test_bypass_sq1 values (1,2,'test_insert');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (1,2,'test_insert');
 explain insert into test_bypass_sq1 values (0,0,'test_insert2');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (0,0,'test_insert2');
 explain insert into test_bypass_sq1 values (2,2,'test_insert2');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (2,2,'test_insert2');
 explain insert into test_bypass_sq1 values (0,0,'test_insert3');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (0,0,'test_insert3');
 explain insert into test_bypass_sq1 values (3,3,'test_insert3');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (3,3,'test_insert3');
 explain insert into test_bypass_sq1(col1,col2) values (1,1);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1(col1,col2) values (1,1);
 explain insert into test_bypass_sq1(col1,col2) values (2,2);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1(col1,col2) values (2,2);
 explain insert into test_bypass_sq1(col1,col2) values (3,3);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1(col1,col2) values (3,3);
 explain insert into test_bypass_sq1 values (null,null,null);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

 insert into test_bypass_sq1 values (null,null,null);
--bypass
set enable_indexonlyscan=off;
explain select * from test_bypass_sq1 where col1=0 and col2=0;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
   Index Cond: ((col1 = 0) AND (col2 = 0))
(3 rows)

select * from test_bypass_sq1 where col1=0 and col2=0;
 col1 | col2 |     col3     
------+------+--------------
    0 |    0 | test_insert3
    0 |    0 | test_insert2
    0 |    0 | test_insert
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col1>0 and col2>0 order by col1,col2;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=8)
   Index Cond: ((col1 > 0) AND (col2 > 0))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1>0 and col2>0 order by col1,col2;
 col1 | col2 
------+------
    1 |    1
    1 |    1
    1 |    2
    2 |    2
    2 |    2
    3 |    3
    3 |    3
(7 rows)

explain select col1,col2 from test_bypass_sq1 where col1>0 and col2>0 order by col1,col2 limit 1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.38 rows=1 width=8)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=8)
         Index Cond: ((col1 > 0) AND (col2 > 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1>0 and col2>0 order by col1,col2 limit 1;
 col1 | col2 
------+------
    1 |    1
(1 row)

explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 for update limit 1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..8.28 rows=1 width=14)
   ->  LockRows  (cost=0.00..8.28 rows=1 width=14)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
               Index Cond: ((col1 = 0) AND (col2 = 0))
(5 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 for update limit 1;
 col1 | col2 
------+------
    0 |    0
(1 row)

explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 limit 0;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..8.27 rows=1 width=8)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=8)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 limit 0;
 col1 | col2 
------+------
(0 rows)

explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 for update limit 0;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..8.28 rows=1 width=14)
   ->  LockRows  (cost=0.00..8.28 rows=1 width=14)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
               Index Cond: ((col1 = 0) AND (col2 = 0))
(5 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1,col2 for update limit 0;
 col1 | col2 
------+------
(0 rows)

reset enable_indexonlyscan;
--bypass though index only scan
set enable_indexscan = off;
explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
   Index Cond: ((col1 = 0) AND (col2 = 0))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0;
 col1 | col2 
------+------
    0 |    0
    0 |    0
    0 |    0
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1 limit 1;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1 limit 1;
 col1 | col2 
------+------
    0 |    0
(1 row)

explain select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1 limit 0;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1=0 and col2=0 order by col1 limit 0;
 col1 | col2 
------+------
(0 rows)

reset enable_indexscan;
--error
explain select * from test_bypass_sq1 where col1=0 and col2=0 order by col1 limit -1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit count grammar with const less than zero.
 Limit  (cost=0.00..8.27 rows=1 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

explain select * from test_bypass_sq1 where col1=0 and col2=0 order by col1 for update limit -1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit count grammar with const less than zero.
 Limit  (cost=0.00..8.28 rows=1 width=46)
   ->  LockRows  (cost=0.00..8.28 rows=1 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=46)
               Index Cond: ((col1 = 0) AND (col2 = 0))
(5 rows)

--bypass
explain update  test_bypass_sq1 set col3='test_null' where col1 is null and col2 is null;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
         Index Cond: ((col1 IS NULL) AND (col2 IS NULL))
(4 rows)

update  test_bypass_sq1 set col3='test_null' where col1 is null and col2 is null;
explain select * from test_bypass_sq1 where col1 is null and col2 is null;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
   Index Cond: ((col1 IS NULL) AND (col2 IS NULL))
(3 rows)

select * from test_bypass_sq1 where col1 is null and col2 is null;
 col1 | col2 |   col3    
------+------+-----------
      |      | test_null
(1 row)

explain select col1,col2 from test_bypass_sq1 where col1 is not null and col2 is not null order by col1,col2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..71.41 rows=1155 width=8)
   Index Cond: ((col1 IS NOT NULL) AND (col2 IS NOT NULL))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1 is not null and col2 is not null order by col1,col2;
 col1 | col2 
------+------
    0 |    0
    0 |    0
    0 |    0
    0 |    1
    1 |    1
    1 |    1
    1 |    2
    2 |    2
    2 |    2
    3 |    3
    3 |    3
(11 rows)

explain select * from test_bypass_sq1 where col1 is not null and col2 = 0 order by col1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..39.92 rows=6 width=40)
   Index Cond: ((col1 IS NOT NULL) AND (col2 = 0))
(3 rows)

select * from test_bypass_sq1 where col1 is not null and col2 = 0 order by col1;
 col1 | col2 |     col3     
------+------+--------------
    0 |    0 | test_insert3
    0 |    0 | test_insert2
    0 |    0 | test_insert
(3 rows)

explain update test_bypass_sq1 set col2=col2-1,col3='test_update' where col1=0 and col2=0;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=14)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

update test_bypass_sq1 set col2=col2-1,col3='test_update' where col1=0 and col2=0;
explain update test_bypass_sq1 set col2=col1 where col1=0 and col2=0;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
         Index Cond: ((col1 = 0) AND (col2 = 0))
(4 rows)

update test_bypass_sq1 set col2=col1 where col1=0 and col2=0;
explain update test_bypass_sq1 set col2=col1-1,col3='test_update' where col1=2 and col2=2;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=10)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=10)
         Index Cond: ((col1 = 2) AND (col2 = 2))
(4 rows)

update test_bypass_sq1 set col2=col1-1,col3='test_update' where col1=2 and col2=2;
explain select * from test_bypass_sq1 where col1=0 and col2=-1;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
   Index Cond: ((col1 = 0) AND (col2 = (-1)))
(3 rows)

select * from test_bypass_sq1 where col1=0 and col2=-1;
 col1 | col2 |    col3     
------+------+-------------
    0 |   -1 | test_update
    0 |   -1 | test_update
    0 |   -1 | test_update
(3 rows)

--not bypass
explain insert into test_bypass_sq1 values(0,generate_series(1,100),'test');
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because the expression of query is not support.
 Insert on test_bypass_sq1  (cost=0.00..5.01 rows=1000 width=0)
   ->  Result  (cost=0.00..5.01 rows=1000 width=0)
(3 rows)

explain select * from test_bypass_sq1 where col3 is not null;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002167.00 rows=1161 width=40)
   Filter: (col3 IS NOT NULL)
(3 rows)

--bypass
explain update test_bypass_sq1 set col2=mod(5,3)  where col1=1 and col2=1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
         Index Cond: ((col1 = 1) AND (col2 = 1))
(4 rows)

update test_bypass_sq1 set col2=mod(5,3)  where col1=1 and col2=1;
--bypass / set  enable_bitmapscan=off;
explain update test_bypass_sq1 set col2=111,col3='test_update2' where  col1=0;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=10)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=10)
         Index Cond: (col1 = 0)
(4 rows)

update test_bypass_sq1 set col2=111,col3='test_update2' where  col1=0;
explain select * from test_bypass_sq1 where col1=0 order by col1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=40)
   Index Cond: (col1 = 0)
(3 rows)

select * from test_bypass_sq1 where col1=0 order by col1;
 col1 | col2 |     col3     
------+------+--------------
    0 |  111 | test_update2
    0 |  111 | test_update2
    0 |  111 | test_update2
    0 |  111 | test_update2
(4 rows)

explain select * from test_bypass_sq1 where col2=2 order by col1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..37.06 rows=6 width=40)
   Index Cond: (col2 = 2)
(3 rows)

select * from test_bypass_sq1 where col2=2 order by col1;
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
    1 |    2 | 
    1 |    2 | test_insert
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col1>0 order by col1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=8)
   Index Cond: (col1 > 0)
(3 rows)

select col1,col2 from test_bypass_sq1 where col1>0 order by col1;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(7 rows)

explain select col1,col2 from test_bypass_sq1 where col1>0 order by col1 limit 3;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.39 rows=3 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=8)
         Index Cond: (col1 > 0)
(4 rows)

select col1,col2 from test_bypass_sq1 where col1>0 order by col1 limit 3;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
(3 rows)

explain select * from test_bypass_sq1 where col1=0 order by col1 for update limit 2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..8.14 rows=2 width=46)
   ->  LockRows  (cost=0.00..24.42 rows=6 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=46)
               Index Cond: (col1 = 0)
(5 rows)

select * from test_bypass_sq1 where col1=0 order by col1 for update limit 2;
 col1 | col2 |     col3     
------+------+--------------
    0 |  111 | test_update2
    0 |  111 | test_update2
(2 rows)

explain select col1,col2 from test_bypass_sq1 where col2<5 order by col1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..60.89 rows=389 width=8)
   Index Cond: (col2 < 5)
(3 rows)

select col1,col2 from test_bypass_sq1 where col2<5 order by col1;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(7 rows)

explain select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=8)
   Index Cond: ((col1 >= 0) AND (col2 > 0))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(11 rows)

explain select * from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit 3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..1.14 rows=3 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=40)
         Index Cond: ((col1 >= 0) AND (col2 > 0))
(4 rows)

select * from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit 3;
 col1 | col2 |     col3     
------+------+--------------
    0 |  111 | test_update2
    0 |  111 | test_update2
    0 |  111 | test_update2
(3 rows)

explain select * from test_bypass_sq1 where col1=1 and col2=2 order by col1 for update limit 1;
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..8.28 rows=1 width=46)
   ->  LockRows  (cost=0.00..8.28 rows=1 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=46)
               Index Cond: ((col1 = 1) AND (col2 = 2))
(5 rows)

select * from test_bypass_sq1 where col1=1 and col2=2 order by col1 for update limit 1;
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
(1 row)

--bypass though index only scan
set enable_indexscan = off;
explain select col1,col2 from  test_bypass_sq1 where col1=0 order by col2;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000002435.51 rows=6 width=8)
   Index Cond: (col1 = 0)
(3 rows)

select col1,col2 from  test_bypass_sq1 where col1=0 order by col2;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
(4 rows)

explain select col2,col1 from test_bypass_sq1 where col2=2 order by col1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000003706.26 rows=6 width=8)
   Index Cond: (col2 = 2)
(3 rows)

select col2,col1 from test_bypass_sq1 where col2=2 order by col1;
 col2 | col1 
------+------
    2 |    1
    2 |    1
    2 |    1
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col1>0 order by col1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000005105.76 rows=389 width=8)
   Index Cond: (col1 > 0)
(3 rows)

select col1,col2 from test_bypass_sq1 where col1>0 order by col1;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(7 rows)

explain select col1,col2 from test_bypass_sq1 where col1 is null and col2 is null;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000000827.01 rows=1 width=8)
   Index Cond: ((col1 IS NULL) AND (col2 IS NULL))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1 is null and col2 is null;
 col1 | col2 
------+------
      |     
(1 row)

explain select col2,col1 from test_bypass_sq1 where col1>0 order by col1 limit 3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=10000000000.00..17634961478.96 rows=3 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000005105.76 rows=389 width=8)
         Index Cond: (col1 > 0)
(4 rows)

select col2,col1 from test_bypass_sq1 where col1>0 order by col1 limit 3;
 col2 | col1 
------+------
    2 |    1
    2 |    1
    2 |    1
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col2<5 order by col1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000006089.26 rows=389 width=8)
   Index Cond: (col2 < 5)
(3 rows)

select col1,col2 from test_bypass_sq1 where col2<5 order by col1;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(7 rows)

explain select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000004944.01 rows=130 width=8)
   Index Cond: ((col1 >= 0) AND (col2 > 0))
(3 rows)

select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(11 rows)

explain select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit 3;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=10000000000.00..32846153960.25 rows=3 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000004944.01 rows=130 width=8)
         Index Cond: ((col1 >= 0) AND (col2 > 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit 3;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
(3 rows)

explain select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit null;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=10000000000.00..1000000004944.01 rows=130 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=10000000000.00..1000000004944.01 rows=130 width=8)
         Index Cond: ((col1 >= 0) AND (col2 > 0))
(4 rows)

select col1,col2 from test_bypass_sq1 where col1>=0 and col2>0 order by col1 limit null;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(11 rows)

reset enable_indexscan;
--not bypass
explain select * from test_bypass_sq1 where col1>col2;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002458.75 rows=389 width=40)
   Filter: (col1 > col2)
(3 rows)

explain select * from test_bypass_sq1 where col1=3 and col2=3 for update;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 LockRows  (cost=0.00..8.28 rows=1 width=46)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=46)
         Index Cond: ((col1 = 3) AND (col2 = 3))
(4 rows)

select * from test_bypass_sq1 where col1=3 and col2=3 for update;
 col1 | col2 |     col3     
------+------+--------------
    3 |    3 | 
    3 |    3 | test_insert3
(2 rows)

explain select * from test_bypass_sq1 where col3='test_update2';
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002458.75 rows=6 width=40)
   Filter: (col3 = 'test_update2'::text)
(3 rows)

--bypass
explain select * from test_bypass_sq1 where col1>0 and col2>0 order by col1 limit 3 offset 3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=1.14..2.28 rows=3 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=40)
         Index Cond: ((col1 > 0) AND (col2 > 0))
(4 rows)

select * from test_bypass_sq1 where col1>0 and col2>0 order by col1 limit 3 offset 3;
 col1 | col2 |    col3     
------+------+-------------
    2 |    1 | test_update
    2 |    1 | test_update
    3 |    3 | 
(3 rows)

select * from test_bypass_sq1 where col1>0 and col2>0 order by col1 limit 3 offset 30;
 col1 | col2 | col3 
------+------+------
(0 rows)

explain select * from test_bypass_sq1 where col1>0  order by col1 for update limit 3 offset 3;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.42..0.85 rows=3 width=46)
   ->  LockRows  (cost=0.00..54.95 rows=389 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=46)
               Index Cond: (col1 > 0)
(5 rows)

explain select * from test_bypass_sq1 where col1>0  order by col1 for update limit 3 offset null;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.42 rows=3 width=46)
   ->  LockRows  (cost=0.00..54.95 rows=389 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=46)
               Index Cond: (col1 > 0)
(5 rows)

explain select * from test_bypass_sq1 where col1>0  order by col1 for update limit 3 offset 30;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=4.24..4.66 rows=3 width=46)
   ->  LockRows  (cost=0.00..54.95 rows=389 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=46)
               Index Cond: (col1 > 0)
(5 rows)

explain select * from test_bypass_sq1 where col1>0 and col2>0 order by col1 offset 3;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=1.14..49.44 rows=127 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=40)
         Index Cond: ((col1 > 0) AND (col2 > 0))
(4 rows)

select * from test_bypass_sq1 where col1>0 and col2>0 order by col1 offset 3;
 col1 | col2 |     col3     
------+------+--------------
    2 |    1 | test_update
    2 |    1 | test_update
    3 |    3 | 
    3 |    3 | test_insert3
(4 rows)

select * from test_bypass_sq1 where col1>0  order by col1 for update limit 3 offset 30;
 col1 | col2 | col3 
------+------+------
(0 rows)

explain select * from test_bypass_sq1 where col1>0 order by col1 for update offset 3;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.42..54.95 rows=386 width=46)
   ->  LockRows  (cost=0.00..54.95 rows=389 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=46)
               Index Cond: (col1 > 0)
(5 rows)

explain update test_bypass_sq1 set col2=3*7  where col1=3 and col2=2;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=42)
         Index Cond: ((col1 = 3) AND (col2 = 2))
(4 rows)

update test_bypass_sq1 set col2=3*7  where col1=3 and col2=2;
explain delete from  test_bypass_sq1 where col1=1 and col2=1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [Bypass]
 Delete on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=6)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=6)
         Index Cond: ((col1 = 1) AND (col2 = 1))
(4 rows)

delete from  test_bypass_sq1 where col1=1 and col2=1;
explain delete from test_bypass_sq1 where col1 is null and col2 is null;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [Bypass]
 Delete on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=6)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=6)
         Index Cond: ((col1 IS NULL) AND (col2 IS NULL))
(4 rows)

delete from test_bypass_sq1 where col1 is null and col2 is null;
explain insert into test_bypass_sq1 values (null,null,null);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

insert into test_bypass_sq1 values (null,null,null);
--bypass / set  enable_bitmapscan=off;
select * from test_bypass_sq1 where col1=3;
 col1 | col2 |     col3     
------+------+--------------
    3 |    3 | 
    3 |    3 | test_insert3
(2 rows)

explain select col1,col2 from test_bypass_sq1 order by col1 desc;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan Backward using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=8)
(2 rows)

select col1,col2 from test_bypass_sq1 order by col1 desc; --order by is supported when ordered col is in index
 col1 | col2 
------+------
      |     
    3 |    3
    3 |    3
    2 |    1
    2 |    1
    1 |    2
    1 |    2
    1 |    2
    0 |  111
    0 |  111
    0 |  111
    0 |  111
(12 rows)

explain select col1,col2 from test_bypass_sq1 order by col1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=8)
(2 rows)

select col1,col2 from test_bypass_sq1 order by col1;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
      |     
(12 rows)

--not bypass
explain select col1,col2 from test_bypass_sq1 order by col1,col2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=8)
(2 rows)

select col1,col2 from test_bypass_sq1 order by col1,col2;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
      |     
(12 rows)

explain select * from test_bypass_sq1 where col1 > 0 order by col1,col2 desc;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=67.79..68.76 rows=389 width=40)
   Sort Key: col1, col2 DESC
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=40)
         Index Cond: (col1 > 0)
(5 rows)

--bypass
explain select col1,col2 from test_bypass_sq1 where col1 > 0 order by col1,col2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=8)
   Index Cond: (col1 > 0)
(3 rows)

select col1,col2 from test_bypass_sq1 where col1 > 0 order by col1,col2;
 col1 | col2 
------+------
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
(7 rows)

--not bypass
explain select * from test_bypass_sq1 where true;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002167.00 rows=1167 width=40)
(2 rows)

--bypass
explain select col1, col2 from test_bypass_sq1 where true order by col1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=8)
(2 rows)

select col1, col2 from test_bypass_sq1 where true order by col1;
 col1 | col2 
------+------
    0 |  111
    0 |  111
    0 |  111
    0 |  111
    1 |    2
    1 |    2
    1 |    2
    2 |    1
    2 |    1
    3 |    3
    3 |    3
      |     
(12 rows)

select col2, col1 from test_bypass_sq1 order by col1;
 col2 | col1 
------+------
  111 |    0
  111 |    0
  111 |    0
  111 |    0
    2 |    1
    2 |    1
    2 |    1
    1 |    2
    1 |    2
    3 |    3
    3 |    3
      |     
(12 rows)

select col1, col2 from test_bypass_sq1 order by col1 desc;
 col1 | col2 
------+------
      |     
    3 |    3
    3 |    3
    2 |    1
    2 |    1
    1 |    2
    1 |    2
    1 |    2
    0 |  111
    0 |  111
    0 |  111
    0 |  111
(12 rows)

explain insert into test_bypass_sq1 select * from test_bypass_sq1 where col1>0;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query combines insert operator with others.
 Insert on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=40)
         Index Cond: (col1 > 0)
(4 rows)

insert into test_bypass_sq1 select * from test_bypass_sq1 where col1>0;
--
drop table if exists test_bypass_sq2;
NOTICE:  table "test_bypass_sq2" does not exist, skipping
create table test_bypass_sq2(col1 int not null, col2 int);
create index itest_bypass_sq2 on test_bypass_sq2(col1);
--bypass
explain insert into test_bypass_sq2(col1) values (0);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq2  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

insert into test_bypass_sq2(col1) values (0);
--error
explain insert into test_bypass_sq2(col1) values (null);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq2  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

--bypass
explain insert into test_bypass_sq2(col1,col2) values (1,1);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq2  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

insert into test_bypass_sq2(col1,col2) values (1,1);
insert into test_bypass_sq2(col1,col2) values (3,3);
insert into test_bypass_sq2(col1,col2) values (-1,-1);
insert into test_bypass_sq2(col1,col2) values (1,1);
insert into test_bypass_sq2(col1,col2) values (2,2);
insert into test_bypass_sq2(col1,col2) values (3,3);
explain insert into test_bypass_sq2(col1,col2) values (null,null);--error
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq2  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

--bypass
set enable_indexonlyscan=off;
explain update test_bypass_sq2 set col2 = col2+1 where col1 = 0;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq2  (cost=0.00..36.47 rows=11 width=14)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.47 rows=11 width=14)
         Index Cond: (col1 = 0)
(4 rows)

update test_bypass_sq2 set col2 = col2+1 where col1 = 0;
explain select * from test_bypass_sq2  where col1 = 0 order by col1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=8)
   Index Cond: (col1 = 0)
(3 rows)

select * from test_bypass_sq2  where col1 = 0 order by col1;
 col1 | col2 
------+------
    0 |     
(1 row)

explain select * from test_bypass_sq2  where col1 >= 0 order by col1;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..56.78 rows=716 width=8)
   Index Cond: (col1 >= 0)
(3 rows)

select * from test_bypass_sq2  where col1 >= 0 order by col1;
 col1 | col2 
------+------
    0 |     
    1 |    1
    1 |    1
    2 |    2
    3 |    3
    3 |    3
(6 rows)

explain select * from test_bypass_sq2  where col1 >= 0 order by col1 limit 4;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.32 rows=4 width=8)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..56.78 rows=716 width=8)
         Index Cond: (col1 >= 0)
(4 rows)

select * from test_bypass_sq2  where col1 >= 0 order by col1 limit 4;
 col1 | col2 
------+------
    0 |     
    1 |    1
    1 |    1
    2 |    2
(4 rows)

explain select * from test_bypass_sq2  where col1 = 1 order by col1 for update limit 1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..3.32 rows=1 width=14)
   ->  LockRows  (cost=0.00..36.55 rows=11 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=14)
               Index Cond: (col1 = 1)
(5 rows)

select * from test_bypass_sq2  where col1 = 1 order by col1 for update limit 1;
 col1 | col2 
------+------
    1 |    1
(1 row)

explain select col1 from test_bypass_sq2 order by col1 limit 2;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.07 rows=2 width=4)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..80.49 rows=2149 width=4)
(3 rows)

select col1 from test_bypass_sq2 order by col1 limit 2;
 col1 
------
   -1
    0
(2 rows)

explain select * from test_bypass_sq2  where col1 > 0 order by col1 limit 2 offset 2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.16..0.32 rows=2 width=8)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..56.78 rows=716 width=8)
         Index Cond: (col1 > 0)
(4 rows)

select * from test_bypass_sq2  where col1 > 0 order by col1 limit 2 offset 2;
 col1 | col2 
------+------
    2 |    2
    3 |    3
(2 rows)

explain select * from test_bypass_sq2  where col1 > 0 order by col1 for update limit 2 offset 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.18..0.36 rows=2 width=14)
   ->  LockRows  (cost=0.00..63.94 rows=716 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..56.78 rows=716 width=14)
               Index Cond: (col1 > 0)
(5 rows)

reset enable_indexonlyscan;
--not bypass
explain select * from test_bypass_sq2  where col2 is null;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003149.00 rows=11 width=8)
   Filter: (col2 IS NULL)
(3 rows)

explain select * from test_bypass_sq2  where col1 = 0 and col2 = 0;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used indexscan with qual.
 Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.47 rows=1 width=8)
   Index Cond: (col1 = 0)
   Filter: (col2 = 0)
(4 rows)

explain select t1.col3, t2.col2  from test_bypass_sq1 as t1 join test_bypass_sq2 as t2 on t1.col1=t2.col1;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join  (cost=80.34..307.71 rows=12539 width=36)
   Hash Cond: (t2.col1 = t1.col1)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2 t2  (cost=0.00..80.49 rows=2149 width=8)
   ->  Hash  (cost=65.76..65.76 rows=1167 width=36)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1 t1  (cost=0.00..65.76 rows=1167 width=36)
(6 rows)

explain select count(*),col1 from test_bypass_sq1 group by col1;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 GroupAggregate  (cost=0.00..73.59 rows=200 width=12)
   Group By Key: col1
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=4)
(4 rows)

--bypass (order by is supported when ordered col is  in index)
select col1 from test_bypass_sq2 order by col1 desc;
 col1 
------
    3
    3
    2
    1
    1
    0
   -1
(7 rows)

select col1 from test_bypass_sq2 order by col1;
 col1 
------
   -1
    0
    1
    1
    2
    3
    3
(7 rows)

--not bypass
explain select * from test_bypass_sq2 order by col1,col2;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=1000000003267.94..1000000003273.31 rows=2149 width=8)
   Sort Key: col1, col2
   ->  Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003149.00 rows=2149 width=8)
(4 rows)

--
drop table if exists test_bypass_sq3;
NOTICE:  table "test_bypass_sq3" does not exist, skipping
create table test_bypass_sq3(col1 int default 1, col2 int, col3 timestamp);
create index itest_bypass_sq3 on test_bypass_sq3(col1);
--bypass
insert into test_bypass_sq3(col2,col3) values (3,null);
--bypass (default is null)
insert into test_bypass_sq3(col2,col3) values(1,default);
insert into test_bypass_sq3 values(2,3,null);
insert into test_bypass_sq3 values (3,3,null);
--not bypass
explain insert into test_bypass_sq3 values(3,3,current_timestamp);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because the expression of query is not support.
 Insert on test_bypass_sq3  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

explain select * from test_bypass_sq3 where col1 = 1 order by col2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=32.55..32.57 rows=9 width=16)
   Sort Key: col2
   ->  Index Scan using itest_bypass_sq3 on test_bypass_sq3  (cost=0.00..32.41 rows=9 width=16)
         Index Cond: (col1 = 1)
(5 rows)

--bypass
select * from test_bypass_sq3 where col1 = 1 limit 1;
 col1 | col2 | col3 
------+------+------
    1 |    1 | 
(1 row)

select col2 from test_bypass_sq3 where col1 = 1 for update;
 col2 
------
    1
    3
(2 rows)

update test_bypass_sq3 set col2 = col2*3 where col1 = 1;
--bypass (col1 is default 1)
insert into test_bypass_sq3 values(default,default,default);
--test random index pos
drop table if exists test_bypass_sq4;
NOTICE:  table "test_bypass_sq4" does not exist, skipping
create table test_bypass_sq4(col1 int, col2 int, col3 int);
create index itest_bypass_sq4 on test_bypass_sq4(col3,col2);
insert into test_bypass_sq4 values (11,21,31);
insert into test_bypass_sq4 values (11,22,32);
insert into test_bypass_sq4 values (12,23,32);
insert into test_bypass_sq4 values (12,23,33);
insert into test_bypass_sq4 values (13,24,33);
insert into test_bypass_sq4 values (13,24,34);
insert into test_bypass_sq4 values (14,25,34);
insert into test_bypass_sq4 values (14,25,35);
insert into test_bypass_sq4 values (55,55,55);
insert into test_bypass_sq4 values (55,55,null);
insert into test_bypass_sq4 values (55,null,55);
insert into test_bypass_sq4 values (55,null,null);
insert into test_bypass_sq4 values (null,null,null);
explain select col3, col1, col2 from test_bypass_sq4 where col2 >22 order by 1,3;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..69.32 rows=648 width=12)
   Index Cond: (col2 > 22)
(3 rows)

select col3, col1, col2 from test_bypass_sq4 where col2 >22 order by 1,3;
 col3 | col1 | col2 
------+------+------
   32 |   12 |   23
   33 |   12 |   23
   33 |   13 |   24
   34 |   13 |   24
   34 |   14 |   25
   35 |   14 |   25
   55 |   55 |   55
      |   55 |   55
(8 rows)

explain select * from test_bypass_sq4 where col2 =22 and col3= 32 order by col2;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..8.27 rows=1 width=12)
   Index Cond: ((col3 = 32) AND (col2 = 22))
(3 rows)

select * from test_bypass_sq4 where col2 =22 and col3= 32 order by col2;
 col1 | col2 | col3 
------+------+------
   11 |   22 |   32
(1 row)

explain select col3,col2,col3 from test_bypass_sq4 where col3 >= 33 and col2 >= 22 order by col3,col2;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..52.89 rows=216 width=8)
   Index Cond: ((col3 >= 33) AND (col2 >= 22))
(3 rows)

select col3,col2,col3 from test_bypass_sq4 where col3 >= 33 and col2 >= 22 order by col3,col2;
 col3 | col2 | col3 
------+------+------
   33 |   23 |   33
   33 |   24 |   33
   34 |   24 |   34
   34 |   25 |   34
   35 |   25 |   35
   55 |   55 |   55
(6 rows)

select col2,col3,col2 from test_bypass_sq4 where col3 >= 34 and col2 >= 22 order by col3,col2;
 col2 | col3 | col2 
------+------+------
   24 |   34 |   24
   25 |   34 |   25
   25 |   35 |   25
   55 |   55 |   55
(4 rows)

explain select col3,col2,col3 from test_bypass_sq4 where col3 >= 33 and col2 >= 22 order by col3 for update;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 LockRows  (cost=0.00..55.05 rows=216 width=14)
   ->  Index Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..52.89 rows=216 width=14)
         Index Cond: ((col3 >= 33) AND (col2 >= 22))
(4 rows)

explain select col2,col3,col2 from test_bypass_sq4 where col3 >= 34 and col2 >= 22 order by col3,col2 for update;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 [Bypass]
 LockRows  (cost=0.00..55.05 rows=216 width=14)
   ->  Index Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..52.89 rows=216 width=14)
         Index Cond: ((col3 >= 34) AND (col2 >= 22))
(4 rows)

select col2,col3,col2 from test_bypass_sq4 where col3 is null and col2 is null order by col3,col2;
 col2 | col3 | col2 
------+------+------
      |      |     
      |      |     
(2 rows)

explain select col2,col3 from test_bypass_sq4 where col3 is null and col2 is not null;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..32.45 rows=10 width=8)
   Index Cond: ((col3 IS NULL) AND (col2 IS NOT NULL))
(3 rows)

select col2,col3 from test_bypass_sq4 where col3 is null and col2 is not null;
 col2 | col3 
------+------
   55 |     
(1 row)

explain select col2,col3 from test_bypass_sq4 where col3 is not null order by col3 desc,col2 desc;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan Backward using itest_bypass_sq4 on test_bypass_sq4  (cost=0.00..82.11 rows=1935 width=8)
   Index Cond: (col3 IS NOT NULL)
(3 rows)

select col2,col3 from test_bypass_sq4 where col3 is not null order by col3 desc,col2 desc;
 col2 | col3 
------+------
      |   55
   55 |   55
   25 |   35
   25 |   34
   24 |   34
   24 |   33
   23 |   33
   23 |   32
   22 |   32
   21 |   31
(10 rows)

drop table if exists test_bypass_sq5;
NOTICE:  table "test_bypass_sq5" does not exist, skipping
create table test_bypass_sq5(col1 int, col2 int, col3 int default 1);
create index itest_bypass_sq5 on test_bypass_sq5(col2);
insert into test_bypass_sq5 values (1,2,3);
insert into test_bypass_sq5 values (2,3,4);
-- permission
DROP ROLE IF EXISTS bypassuser;
NOTICE:  role "bypassuser" does not exist, skipping
CREATE USER bypassuser PASSWORD 'ttest@123';
GRANT select ON test_bypass_sq5 TO bypassuser;
GRANT update ON test_bypass_sq5 TO bypassuser;
SET SESSION AUTHORIZATION bypassuser PASSWORD 'ttest@123';
SELECT SESSION_USER, CURRENT_USER;
 session_user | current_user 
--------------+--------------
 bypassuser   | bypassuser
(1 row)

select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    3
    2 |    3 |    4
(2 rows)

select * from test_bypass_sq5 where col2>2 for update;
 col1 | col2 | col3 
------+------+------
    2 |    3 |    4
(1 row)

insert into test_bypass_sq5 values (2,3,4); --fail
ERROR:  permission denied for relation test_bypass_sq5
DETAIL:  N/A
update test_bypass_sq5 set col3 = col3+1 where col2 > 0;
delete from test_bypass_sq5; --fail
ERROR:  permission denied for relation test_bypass_sq5
DETAIL:  N/A
RESET SESSION AUTHORIZATION;
revoke update on test_bypass_sq5 from bypassuser;
revoke select on test_bypass_sq5 from bypassuser;
DROP OWNED BY bypassuser;
DROP ROLE bypassuser;
-- bypass transaction
start transaction;
    insert into test_bypass_sq5 values (3,4,5);
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    5
(3 rows)

    savepoint s1;
    update test_bypass_sq5 set col3 = col3+1 where col2 > 0;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    5
    2 |    3 |    6
    3 |    4 |    6
(3 rows)

    rollback to savepoint s1;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    5
(3 rows)

    savepoint s2;
    delete from test_bypass_sq5 where col2 < 3;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    2 |    3 |    5
    3 |    4 |    5
(2 rows)

    rollback to savepoint s2;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    5
(3 rows)

rollback;
start transaction read only;
    insert into test_bypass_sq5 values (3,4,5);
ERROR:  cannot execute INSERT in a read-only transaction
rollback;
start transaction read only;
    update test_bypass_sq5 set col3 = col3+1 where col2 > 0;
ERROR:  cannot execute UPDATE in a read-only transaction
rollback;
start transaction read only;
    delete from test_bypass_sq5 where col2 < 3;
ERROR:  cannot execute DELETE in a read-only transaction
rollback;
select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
(2 rows)

-- maybe wrong savepoint and cursor
drop table if exists test_bypass_sq5;
create table test_bypass_sq5(col1 int, col2 int, col3 int default 1);
create index itest_bypass_sq5 on test_bypass_sq5(col2);
insert into test_bypass_sq5 values (1,2,3);
insert into test_bypass_sq5 values (2,3,4);
start transaction;
    insert into test_bypass_sq5 values (3,4,5);
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    3
    2 |    3 |    4
    3 |    4 |    5
(3 rows)

    cursor tt for select * from test_bypass_sq5 order by col2;
    update test_bypass_sq5 set col3 = col3+1 where col2 > 0;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    6
(3 rows)

    fetch 2 from tt;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    3
    2 |    3 |    4
(2 rows)

    savepoint s3;
    update test_bypass_sq5 set col3 = col3+1 where col2 > 0;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    5
    2 |    3 |    6
    3 |    4 |    7
(3 rows)

    rollback to savepoint s3;
    select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    6
(3 rows)

    fetch 2 from tt;
 col1 | col2 | col3 
------+------+------
    3 |    4 |    5
(1 row)

commit;
select * from test_bypass_sq5 order by col2;
 col1 | col2 | col3 
------+------+------
    1 |    2 |    4
    2 |    3 |    5
    3 |    4 |    6
(3 rows)

-- test complex type
drop table if exists test_bypass_sq6;
NOTICE:  table "test_bypass_sq6" does not exist, skipping
create type complextype AS (f1 int, f2 text);
create table test_bypass_sq6(col1 int, col2 complextype,col3 text);
create index itest_bypass_sq6 on test_bypass_sq6(col1,col3);
--not bypass
explain insert into test_bypass_sq6 values (1,ROW(1, 'Simon1'::text),'test'::text);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used unsupported DML target type.
 Insert on test_bypass_sq6  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

-- just insert
reset opfusion_debug_mode;
insert into test_bypass_sq6 values (1,ROW(1, 'Simon1'::text),'test'::text);
set opfusion_debug_mode = 'error';
ERROR:  invalid value for parameter "opfusion_debug_mode": "error"
HINT:  Available values: off, log.
--bypass
select * from test_bypass_sq6 where col1 is not null;
 col1 |    col2    | col3 
------+------------+------
    1 | (1,Simon1) | test
(1 row)

select * from test_bypass_sq6 where col3 ='test'::text for update;
 col1 |    col2    | col3 
------+------------+------
    1 | (1,Simon1) | test
(1 row)

update test_bypass_sq6 set col3='test_2'::text where col1 = 1;
select * from test_bypass_sq6 where col3 is not null;
 col1 |    col2    |  col3  
------+------------+--------
    1 | (1,Simon1) | test_2
(1 row)

select col1 from test_bypass_sq6;
 col1 
------
    1
(1 row)

select col3 from test_bypass_sq6 order by col1,col3;
  col3  
--------
 test_2
(1 row)

select col1, col3 from test_bypass_sq6 where true;
 col1 |  col3  
------+--------
    1 | test_2
(1 row)

--notbypass
explain update test_bypass_sq6 set col2=ROW(2,'Ruby2'::text) where col1 = 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Update on test_bypass_sq6  (cost=0.00..20.32 rows=4 width=42)
   ->  Index Scan using itest_bypass_sq6 on test_bypass_sq6  (cost=0.00..20.32 rows=4 width=42)
         Index Cond: (col1 = 1)
(3 rows)

--bypass
delete from test_bypass_sq6 where col1 = 1;
--test QPS
set opfusion_debug_mode='error';
ERROR:  invalid value for parameter "opfusion_debug_mode": "error"
HINT:  Available values: off, log.
drop table if exists test_bypass_sq7;
NOTICE:  table "test_bypass_sq7" does not exist, skipping
create table test_bypass_sq7(col1 int, col2 int, col3 int);
create index test_bypass_sq7_index on test_bypass_sq7(col1,col2);
insert into test_bypass_sq7 values (11,21,31);
insert into test_bypass_sq7 values (11,22,32);
insert into test_bypass_sq7 values (12,23,32);
SET track_activities=on;
SET track_sql_count=on;
DROP USER IF EXISTS qps CASCADE;
NOTICE:  role "qps" does not exist, skipping
CREATE USER qps PASSWORD 'TTEST@123';
GRANT INSERT on TABLE test_bypass_sq7 to qps;
GRANT SELECT on TABLE test_bypass_sq7 to qps;
GRANT UPDATE on TABLE test_bypass_sq7 to qps;
GRANT DELETE on TABLE test_bypass_sq7 to qps;
SET SESSION SESSION AUTHORIZATION qps PASSWORD 'TTEST@123';
SELECT node_name,select_count, update_count, insert_count, delete_count,  ddl_count, dml_count FROM gs_sql_count where user_name='qps';
 node_name | select_count | update_count | insert_count | delete_count | ddl_count | dml_count 
-----------+--------------+--------------+--------------+--------------+-----------+-----------
 datanode1 |            6 |            0 |            0 |            0 |         0 |         6
(1 row)

SELECT * from test_bypass_sq7 where col1 >10 and col2 >10 order by col1,col2;
 col1 | col2 | col3 
------+------+------
   11 |   21 |   31
   11 |   22 |   32
   12 |   23 |   32
(3 rows)

update test_bypass_sq7 set col2 =1 where col1 =11;
insert into test_bypass_sq7 values (1,2,3);
delete test_bypass_sq7 where col1 =1;
SELECT node_name,select_count, update_count, insert_count, delete_count,  ddl_count, dml_count FROM gs_sql_count where user_name='qps';
 node_name | select_count | update_count | insert_count | delete_count | ddl_count | dml_count 
-----------+--------------+--------------+--------------+--------------+-----------+-----------
 datanode1 |            8 |            1 |            1 |            1 |         0 |        11
(1 row)

CREATE OR REPLACE FUNCTION tri_bypass() RETURNS trigger AS $$
BEGIN
    NEW.col2 = NEW.col2 + 2;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
set opfusion_debug_mode = 'log';
drop table if exists test_bypass_sq8;
NOTICE:  table "test_bypass_sq8" does not exist, skipping
create table test_bypass_sq8(col1 int, col2 int, col3 text);
create index itest_bypass_sq8 on test_bypass_sq8(col1,col2);
create trigger tri_bypass after insert on test_bypass_sq8 for each row execute procedure tri_bypass();
insert into test_bypass_sq8 values(1,1,'test');
explain select * from test_bypass_sq8 where col1 = 1;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's relation is not support.
 Index Scan using itest_bypass_sq8 on test_bypass_sq8  (cost=0.00..24.36 rows=6 width=40)
   Index Cond: (col1 = 1)
(3 rows)

explain update test_bypass_sq8 set col2 = 2 where col1 = 1;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's relation is not support.
 Update on test_bypass_sq8  (cost=0.00..24.36 rows=6 width=42)
   ->  Index Scan using itest_bypass_sq8 on test_bypass_sq8  (cost=0.00..24.36 rows=6 width=42)
         Index Cond: (col1 = 1)
(4 rows)

explain delete test_bypass_sq8 where col1 = 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's relation is not support.
 Delete on test_bypass_sq8  (cost=0.00..24.36 rows=6 width=6)
   ->  Index Scan using itest_bypass_sq8 on test_bypass_sq8  (cost=0.00..24.36 rows=6 width=6)
         Index Cond: (col1 = 1)
(4 rows)

explain insert into test_bypass_sq8 values(2,2,'testinsert');
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's relation is not support.
 Insert on test_bypass_sq8  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

set opfusion_debug_mode=off;
RESET SESSION AUTHORIZATION;
SELECT node_name,select_count, update_count, insert_count, delete_count,  ddl_count, dml_count FROM pgxc_sql_count where user_name='qps' order by node_name;
ERROR:  relation "pgxc_sql_count" does not exist on datanode1
LINE 1: ...t_count, delete_count,  ddl_count, dml_count FROM pgxc_sql_c...
                                                             ^
revoke insert on test_bypass_sq7 from qps;
revoke delete on test_bypass_sq7 from qps;
revoke update on test_bypass_sq7 from qps;
revoke select on test_bypass_sq7 from qps;
DROP OWNED BY qps;
DROP ROLE qps;
-- test rule do nothing
create table test(a int);
create view v_test as select * from test;
CREATE OR REPLACE RULE v_delete as ON DELETE TO v_test DO INSTEAD NOTHING;
delete from v_test;
set explain_perf_mode=pretty;
explain delete from v_test;
        QUERY PLAN         
---------------------------
 Query rewrites to nothing
(1 row)

reset explain_perf_mode;
drop table test cascade;
NOTICE:  drop cascades to view v_test
-- end
reset track_activities;
set track_sql_count = off;
reset enable_seqscan;
reset enable_bitmapscan;
reset opfusion_debug_mode;
reset enable_opfusion;
reset enable_indexscan;
reset enable_indexonlyscan;
reset log_min_messages;
reset logging_module;
drop table test_bypass_sq1;
drop table test_bypass_sq2;
drop table test_bypass_sq3;
drop table test_bypass_sq4;
drop table test_bypass_sq5;
drop table test_bypass_sq6;
drop table test_bypass_sq7;
drop table test_bypass_sq8;
ERROR:  table "test_bypass_sq8" does not exist
drop function tri_bypass;
ERROR:  function tri_bypass does not exist
drop type complextype;
