--
--FOR BLACKLIST FEATURE: REFERENCES/INHERITS/WITH OIDS/RULE/CREATE TYPE/DOMAIN is not supported.
--
--
-- ALTER_TABLE
-- add attribute
--
CREATE TABLE tmp (initial int4);
COMMENT ON TABLE tmp_wrong IS 'table comment';
ERROR:  relation "tmp_wrong" does not exist
COMMENT ON TABLE tmp IS 'table comment';
COMMENT ON TABLE tmp IS NULL;
ALTER TABLE tmp ADD COLUMN xmin integer; -- fails
ERROR:  column name "xmin" conflicts with a system column name
ALTER TABLE tmp ADD COLUMN a int4 default 3;
ALTER TABLE tmp ADD COLUMN b name;
ALTER TABLE tmp ADD COLUMN c text;
ALTER TABLE tmp ADD COLUMN d float8;
ALTER TABLE tmp ADD COLUMN e float4;
ALTER TABLE tmp ADD COLUMN f int2;
ALTER TABLE tmp ADD COLUMN g polygon;
ALTER TABLE tmp ADD COLUMN h abstime;
ALTER TABLE tmp ADD COLUMN i char;
ALTER TABLE tmp ADD COLUMN j abstime[];
ALTER TABLE tmp ADD COLUMN k int4;
ALTER TABLE tmp ADD COLUMN l tid;
ALTER TABLE tmp ADD COLUMN m xid;
ALTER TABLE tmp ADD COLUMN n oidvector;
--ALTER TABLE tmp ADD COLUMN o lock;
ALTER TABLE tmp ADD COLUMN p smgr;
ALTER TABLE tmp ADD COLUMN q point;
ALTER TABLE tmp ADD COLUMN r lseg;
ALTER TABLE tmp ADD COLUMN s path;
ALTER TABLE tmp ADD COLUMN t box;
ALTER TABLE tmp ADD COLUMN u tinterval;
ALTER TABLE tmp ADD COLUMN v timestamp;
ALTER TABLE tmp ADD COLUMN w interval;
ALTER TABLE tmp ADD COLUMN x float8[];
ALTER TABLE tmp ADD COLUMN y float4[];
ALTER TABLE tmp ADD COLUMN z int2[];
INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM tmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE tmp;
-- the wolf bug - schema mods caused inconsistent row descriptors
CREATE TABLE tmp (
	initial 	int4
);
ALTER TABLE tmp ADD COLUMN a int4;
ALTER TABLE tmp ADD COLUMN b name;
ALTER TABLE tmp ADD COLUMN c text;
ALTER TABLE tmp ADD COLUMN d float8;
ALTER TABLE tmp ADD COLUMN e float4;
ALTER TABLE tmp ADD COLUMN f int2;
ALTER TABLE tmp ADD COLUMN g polygon;
ALTER TABLE tmp ADD COLUMN h abstime;
ALTER TABLE tmp ADD COLUMN i char;
ALTER TABLE tmp ADD COLUMN j abstime[];
ALTER TABLE tmp ADD COLUMN k int4;
ALTER TABLE tmp ADD COLUMN l tid;
ALTER TABLE tmp ADD COLUMN m xid;
ALTER TABLE tmp ADD COLUMN n oidvector;
--ALTER TABLE tmp ADD COLUMN o lock;
ALTER TABLE tmp ADD COLUMN p smgr;
ALTER TABLE tmp ADD COLUMN q point;
ALTER TABLE tmp ADD COLUMN r lseg;
ALTER TABLE tmp ADD COLUMN s path;
ALTER TABLE tmp ADD COLUMN t box;
ALTER TABLE tmp ADD COLUMN u tinterval;
ALTER TABLE tmp ADD COLUMN v timestamp;
ALTER TABLE tmp ADD COLUMN w interval;
ALTER TABLE tmp ADD COLUMN x float8[];
ALTER TABLE tmp ADD COLUMN y float4[];
ALTER TABLE tmp ADD COLUMN z int2[];
INSERT INTO tmp (a, b, c, d, e, f, g, h, i, j, k, l, m, n, p, q, r, s, t, u,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'Mon May  1 00:30:30 1995', 'c', '{Mon May  1 00:30:30 1995, Monday Aug 24 14:43:07 1992, epoch}',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', 'magnetic disk', '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)', '["epoch" "infinity"]',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}');
SELECT * FROM tmp;
 initial | a |  b   |  c   |  d  |  e  | f |           g           |              h               | i |                                               j                                                |   k    |   l   |  m  |        n        |       p       |     q     |           r           |              s              |          t          |                      u                      |            v             |        w         |     x     |     y     |     z     
---------+---+------+------+-----+-----+---+-----------------------+------------------------------+---+------------------------------------------------------------------------------------------------+--------+-------+-----+-----------------+---------------+-----------+-----------------------+-----------------------------+---------------------+---------------------------------------------+--------------------------+------------------+-----------+-----------+-----------
         | 4 | name | text | 4.1 | 4.1 | 2 | ((4.1,4.1),(3.1,3.1)) | Mon May 01 00:30:30 1995 PDT | c | {"Mon May 01 00:30:30 1995 PDT","Mon Aug 24 14:43:07 1992 PDT","Wed Dec 31 16:00:00 1969 PST"} | 314159 | (1,1) | 512 | 1 2 3 4 5 6 7 8 | magnetic disk | (1.1,1.1) | [(4.1,4.1),(3.1,3.1)] | ((0,2),(4.1,4.1),(3.1,3.1)) | (4.1,4.1),(3.1,3.1) | ["Wed Dec 31 16:00:00 1969 PST" "infinity"] | Thu Jan 01 00:00:00 1970 | @ 1 hour 10 secs | {1,2,3,4} | {1,2,3,4} | {1,2,3,4}
(1 row)

DROP TABLE tmp;
--
-- rename - check on both non-temp and temp tables
--
CREATE TABLE tmp (regtable int);
-- Enforce use of COMMIT instead of 2PC for temporary objects
\set VERBOSITY verbose
-- CREATE TEMP TABLE tmp (tmptable int);
ALTER TABLE tmp RENAME TO tmp_new;
-- SELECT * FROM tmp;
-- SELECT * FROM tmp_new;
-- ALTER TABLE tmp RENAME TO tmp_new2;
SELECT * FROM tmp;		-- should fail
ERROR:  
GAUSS-00108: relation "tmp" does not exist
SQLSTATE: 42P01
LINE 1: SELECT * FROM tmp;
                      ^
--?.*
SELECT *, FROM tmp;		-- should fail
ERROR:  
GAUSS-00047: syntax error at or near "FROM"
SQLSTATE: 42601
LINE 1: SELECT *, FROM tmp;
                  ^
--?.*
SELECT * FROM tmp_new;
 regtable 
----------
(0 rows)

-- SELECT * FROM tmp_new2;
DROP TABLE tmp_new;
-- DROP TABLE tmp_new2;
CREATE TABLE tmp (ch1 character(1));
SQLSTATE: 00000
--?.*
insert into tmp values ('asdv');
ERROR:  
GAUSS-03257: value too long for type character(1)
SQLSTATE: 22001
CONTEXT:  referenced column: ch1
--?.*
DROP TABLE tmp;
\set VERBOSITY default
-- ALTER TABLE ... RENAME on non-table relations
-- renaming indexes (FIXME: this should probably test the index's functionality)
ALTER INDEX IF EXISTS __onek_unique1 RENAME TO tmp_onek_unique1;
NOTICE:  relation "__onek_unique1" does not exist, skipping
ALTER INDEX IF EXISTS __tmp_onek_unique1 RENAME TO onek_unique1;
NOTICE:  relation "__tmp_onek_unique1" does not exist, skipping
ALTER INDEX onek_unique1 RENAME TO tmp_onek_unique1;
ALTER INDEX tmp_onek_unique1 RENAME TO onek_unique1;
-- renaming views
CREATE VIEW tmp_view (unique1) AS SELECT unique1 FROM tenk1;
ALTER TABLE tmp_view RENAME TO tmp_view_new;
-- hack to ensure we get an indexscan here
ANALYZE tenk1;
set enable_seqscan to off;
set enable_bitmapscan to off;
-- 5 values, sorted 
SELECT unique1 FROM tenk1 WHERE unique1 < 5 ORDER BY unique1;
 unique1 
---------
       0
       1
       2
       3
       4
(5 rows)

reset enable_seqscan;
reset enable_bitmapscan;
DROP VIEW tmp_view_new;
-- toast-like relation name
alter table stud_emp rename to pg_toast_stud_emp;
alter table pg_toast_stud_emp rename to stud_emp;
-- renaming index should rename constraint as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "onek_unique1_constraint" for table "onek"
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
-- renaming constraint
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0);
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo;
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo;
-- renaming constraint should rename index as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "onek_unique1_constraint" for table "onek"
DROP INDEX onek_unique1_constraint;  -- to see whether it's there
ERROR:  cannot drop index onek_unique1_constraint because constraint onek_unique1_constraint on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint on table onek instead.
ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo;
DROP INDEX onek_unique1_constraint_foo;  -- to see whether it's there
ERROR:  cannot drop index onek_unique1_constraint_foo because constraint onek_unique1_constraint_foo on table onek requires it
HINT:  You can drop constraint onek_unique1_constraint_foo on table onek instead.
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo;
-- renaming constraints vs. inheritance
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int);
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1" CHECK (a > 0)

CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
\d constraint_rename_test2
ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo; -- fail
ERROR:  relation "constraint_rename_test2" does not exist
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- fail
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo; -- ok
ERROR:  constraint "con1" for table "constraint_rename_test" does not exist
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)

\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT;
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo; -- ok
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar; -- ok
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 b      | integer | 
 c      | integer | 
Check constraints:
    "con1foo" CHECK (a > 0)
    "con2bar" CHECK (b > 0) NO INHERIT

\d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "con3" for table "constraint_rename_test"
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo; -- ok
\d constraint_rename_test
Table "public.constraint_rename_test"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | not null
 b      | integer | 
 c      | integer | 
Indexes:
    "con3foo" PRIMARY KEY, btree (a) TABLESPACE pg_default
Check constraints:
    "con1foo" CHECK (a > 0)
    "con2bar" CHECK (b > 0) NO INHERIT

\d constraint_rename_test2
DROP TABLE constraint_rename_test2;
ERROR:  table "constraint_rename_test2" does not exist
DROP TABLE constraint_rename_test;
ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a);
NOTICE:  relation "constraint_rename_test" does not exist, skipping
-- FOREIGN KEY CONSTRAINT adding TEST
CREATE TABLE tmp2 (a int primary key);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "tmp2_pkey" for table "tmp2"
CREATE TABLE tmp3 (a int, b int);
CREATE TABLE tmp4 (a int, b int, unique(a,b));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "tmp4_a_b_key" for table "tmp4"
CREATE TABLE tmp5 (a int, b int);
-- Insert rows into tmp2 (pktable)
INSERT INTO tmp2 values (1);
INSERT INTO tmp2 values (2);
INSERT INTO tmp2 values (3);
INSERT INTO tmp2 values (4);
-- Insert rows into tmp3
INSERT INTO tmp3 values (1,10);
INSERT INTO tmp3 values (1,20);
INSERT INTO tmp3 values (5,50);
-- Try (and fail) to add constraint due to invalid source columns
ALTER TABLE tmp3 add constraint tmpconstr foreign key(c) references tmp2 match full;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- Try (and fail) to add constraint due to invalide destination columns explicitly given
ALTER TABLE tmp3 add constraint tmpconstr foreign key(a) references tmp2(b) match full;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- Try (and fail) to add constraint due to invalid data
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- Delete failing row
DELETE FROM tmp3 where a=5;
-- Try (and succeed)
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
ALTER TABLE tmp3 drop constraint tmpconstr;
ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
INSERT INTO tmp3 values (5,50);
-- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
ALTER TABLE tmp3 add constraint tmpconstr foreign key (a) references tmp2 match full NOT VALID;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
ALTER TABLE tmp3 validate constraint tmpconstr;
ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
-- Delete failing row
DELETE FROM tmp3 where a=5;
-- Try (and succeed) and repeat to show it works on already valid constraint
ALTER TABLE tmp3 validate constraint tmpconstr;
ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
ALTER TABLE tmp3 validate constraint tmpconstr;
ERROR:  constraint "tmpconstr" of relation "tmp3" does not exist
-- Try a non-verified CHECK constraint
ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10); -- fail
ERROR:  check constraint "b_greater_than_ten" is violated by some row
ALTER TABLE tmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID; -- succeeds
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- fails
ERROR:  check constraint "b_greater_than_ten" is violated by some row
DELETE FROM tmp3 WHERE NOT b > 10;
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_greater_than_ten; -- succeeds
-- Test inherited NOT VALID CHECK constraints
select * from tmp3;
 a | b  
---+----
 1 | 20
(1 row)

CREATE TABLE tmp6 () INHERITS (tmp3);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
CREATE TABLE tmp7 () INHERITS (tmp3);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
INSERT INTO tmp6 VALUES (6, 30), (7, 16);
ERROR:  relation "tmp6" does not exist
LINE 1: INSERT INTO tmp6 VALUES (6, 30), (7, 16);
                    ^
ALTER TABLE tmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID;
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- fails
DELETE FROM tmp6 WHERE b > 20;
ERROR:  relation "tmp6" does not exist
LINE 1: DELETE FROM tmp6 WHERE b > 20;
                    ^
ALTER TABLE tmp3 VALIDATE CONSTRAINT b_le_20;	-- succeeds
-- An already validated constraint must not be revalidated
CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$;
INSERT INTO tmp7 VALUES (8, 18);
ERROR:  relation "tmp7" does not exist
LINE 1: INSERT INTO tmp7 VALUES (8, 18);
                    ^
set client_min_messages=WARNING;
ALTER TABLE tmp7 ADD CONSTRAINT identity CHECK (b = boo(b));
ERROR:  relation "tmp7" does not exist
reset client_min_messages;
ALTER TABLE tmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID;
set client_min_messages=WARNING;
ALTER TABLE tmp3 VALIDATE CONSTRAINT identity;
reset client_min_messages;
-- Try (and fail) to create constraint from tmp5(a) to tmp4(a) - unique constraint on
-- tmp4 is a,b
ALTER TABLE tmp5 add constraint tmpconstr foreign key(a) references tmp4(a) match full;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
DROP TABLE tmp7;
ERROR:  table "tmp7" does not exist
DROP TABLE tmp6;
ERROR:  table "tmp6" does not exist
DROP TABLE tmp5;
DROP TABLE tmp4;
DROP TABLE tmp3;
DROP TABLE tmp2;
-- NOT VALID with plan invalidation -- ensure we don't use a constraint for
-- exclusion until validated
set constraint_exclusion TO 'partition';
create table nv_parent (d date);
create table nv_child_2010 () inherits (nv_parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table nv_child_2011 () inherits (nv_parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid;
ERROR:  relation "nv_child_2010" does not exist
alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid;
ERROR:  relation "nv_child_2011" does not exist
explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31';
   QUERY PLAN   
----------------
 Data Node Scan
(1 row)

create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date;
   QUERY PLAN   
----------------
 Data Node Scan
(1 row)

explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
   QUERY PLAN   
----------------
 Data Node Scan
(1 row)

-- after validation, the constraint should be used
alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check;
ERROR:  relation "nv_child_2011" does not exist
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date;
   QUERY PLAN   
----------------
 Data Node Scan
(1 row)

-- Foreign key adding test with mixed types
-- Note: these tables are TEMP to avoid name conflicts when this test
-- is run in parallel with foreign_key.sql.
CREATE TABLE PKTABLE (ptest1 int PRIMARY KEY);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pktable_pkey" for table "pktable"
INSERT INTO PKTABLE VALUES(42);
CREATE TABLE FKTABLE (ftest1 inet);
-- This next should fail, because int=inet does not exist
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- This should also fail for the same reason, but here we
-- give the column name
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
DROP TABLE FKTABLE;
-- This should succeed, even though they are different types,
-- because int=int8 exists and is a member of the integer opfamily
CREATE TABLE FKTABLE (ftest1 int8);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
INSERT INTO FKTABLE VALUES(43);		-- should fail
DROP TABLE FKTABLE;
-- This should fail, because we'd have to cast numeric to int which is
-- not an implicit coercion (or use numeric=numeric, but that's not part
-- of the integer opfamily)
CREATE TABLE FKTABLE (ftest1 numeric);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
DROP TABLE FKTABLE;
DROP TABLE PKTABLE;
-- On the other hand, this should work because int implicitly promotes to
-- numeric, and we allow promotion on the FK side
CREATE TABLE PKTABLE (ptest1 numeric PRIMARY KEY);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pktable_pkey" for table "pktable"
INSERT INTO PKTABLE VALUES(42);
CREATE TABLE FKTABLE (ftest1 int);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- Check it actually works
INSERT INTO FKTABLE VALUES(42);		-- should succeed
INSERT INTO FKTABLE VALUES(43);		-- should fail
DROP TABLE FKTABLE;
DROP TABLE PKTABLE;
CREATE TABLE PKTABLE (ptest1 int, ptest2 inet,
                           PRIMARY KEY(ptest1, ptest2));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pktable_pkey" for table "pktable"
-- This should fail, because we just chose really odd types
CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable;
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
DROP TABLE FKTABLE;
-- Again, so should this...
CREATE TABLE FKTABLE (ftest1 cidr, ftest2 timestamp);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest1, ptest2);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
DROP TABLE FKTABLE;
-- This fails because we mixed up the column ordering
CREATE TABLE FKTABLE (ftest1 int, ftest2 inet);
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest2, ptest1);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- As does this...
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
     references pktable(ptest1, ptest2);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
-- temp tables should go away by themselves, need not drop them.
-- test check constraint adding
create table atacc1 ( test int );
-- add a check constraint
alter table atacc1 add constraint atacc_test1 check (test>3);
-- should fail
insert into atacc1 (test) values (2);
ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
DETAIL:  Failing row contains (2).
-- should succeed
insert into atacc1 (test) values (4);
drop table atacc1;
-- let's do one where the check fails when added
create table atacc1 ( test int );
-- insert a soon to be failing row
insert into atacc1 (test) values (2);
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test>3);
ERROR:  check constraint "atacc_test1" is violated by some row
insert into atacc1 (test) values (4);
drop table atacc1;
-- let's do one where the check fails because the column doesn't exist
create table atacc1 ( test int );
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test1>3);
ERROR:  column "test1" does not exist
drop table atacc1;
-- something a little more complicated
create table atacc1 ( test int, test2 int, test3 int);
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4);
-- should fail
insert into atacc1 (test,test2,test3) values (4,4,2);
ERROR:  new row for relation "atacc1" violates check constraint "atacc_test1"
DETAIL:  Failing row contains (4, 4, 2).
-- should succeed
insert into atacc1 (test,test2,test3) values (4,4,5);
drop table atacc1;
-- lets do some naming tests
create table atacc1 (test int check (test>3), test2 int);
alter table atacc1 add check (test2>test);
-- should fail for $2
insert into atacc1 (test2, test) values (3, 4);
ERROR:  new row for relation "atacc1" violates check constraint "atacc1_check"
DETAIL:  Failing row contains (4, 3).
drop table atacc1;
-- inheritance related tests
create table atacc1 (test int);
create table atacc2 (test2 int);
create table atacc3 (test3 int) inherits (atacc1, atacc2);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
alter table atacc2 add constraint foo check (test2>0);
-- fail and then succeed on atacc2
insert into atacc2 (test2) values (-3);
ERROR:  new row for relation "atacc2" violates check constraint "foo"
DETAIL:  Failing row contains (-3).
insert into atacc2 (test2) values (3);
-- fail and then succeed on atacc3
insert into atacc3 (test2) values (-3);
ERROR:  relation "atacc3" does not exist
LINE 1: insert into atacc3 (test2) values (-3);
                    ^
insert into atacc3 (test2) values (3);
ERROR:  relation "atacc3" does not exist
LINE 1: insert into atacc3 (test2) values (3);
                    ^
drop table atacc3;
ERROR:  table "atacc3" does not exist
drop table atacc2;
drop table atacc1;
-- same things with one created with INHERIT
create table atacc1 (test int);
create table atacc2 (test2 int);
create table atacc3 (test3 int) inherits (atacc1, atacc2);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
alter table atacc3 no inherit atacc2;
ERROR:  relation "atacc3" does not exist
-- fail
alter table atacc3 no inherit atacc2;
ERROR:  relation "atacc3" does not exist
-- make sure it really isn't a child
insert into atacc3 (test2) values (3);
ERROR:  relation "atacc3" does not exist
LINE 1: insert into atacc3 (test2) values (3);
                    ^
select test2 from atacc2;
 test2 
-------
(0 rows)

-- fail due to missing constraint
alter table atacc2 add constraint foo check (test2>0);
alter table atacc3 inherit atacc2;
ERROR:  relation "atacc3" does not exist
-- fail due to missing column
alter table atacc3 rename test2 to testx;
ERROR:  relation "atacc3" does not exist
alter table atacc3 inherit atacc2;
ERROR:  relation "atacc3" does not exist
-- fail due to mismatched data type
alter table atacc3 add test2 bool;
ERROR:  relation "atacc3" does not exist
alter table atacc3 inherit atacc2;
ERROR:  relation "atacc3" does not exist
alter table atacc3 drop test2;
ERROR:  relation "atacc3" does not exist
-- succeed
alter table atacc3 add test2 int;
ERROR:  relation "atacc3" does not exist
update atacc3 set test2 = 4 where test2 is null;
ERROR:  relation "atacc3" does not exist
LINE 1: update atacc3 set test2 = 4 where test2 is null;
               ^
alter table atacc3 add constraint foo check (test2>0);
ERROR:  relation "atacc3" does not exist
alter table atacc3 inherit atacc2;
ERROR:  relation "atacc3" does not exist
-- fail due to duplicates and circular inheritance
alter table atacc3 inherit atacc2;
ERROR:  relation "atacc3" does not exist
alter table atacc2 inherit atacc3;
ERROR:  relation "atacc3" does not exist
alter table atacc2 inherit atacc2;
ERROR:  circular inheritance not allowed
DETAIL:  "atacc2" is already a child of "atacc2".
-- test that we really are a child now (should see 4 not 3 and cascade should go through)
select test2 from atacc2;
 test2 
-------
(0 rows)

drop table atacc2 cascade;
drop table atacc1;
-- adding only to a parent is allowed as of 9.2
create table atacc1 (test int);
create table atacc2 (test2 int) inherits (atacc1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- ok:
alter table atacc1 add constraint foo check (test>0) no inherit;
-- check constraint is not there on child
insert into atacc2 (test) values (-3);
ERROR:  relation "atacc2" does not exist
LINE 1: insert into atacc2 (test) values (-3);
                    ^
-- check constraint is there on parent
insert into atacc1 (test) values (-3);
ERROR:  new row for relation "atacc1" violates check constraint "foo"
DETAIL:  Failing row contains (-3).
insert into atacc1 (test) values (3);
-- fail, violating row:
alter table atacc2 add constraint foo check (test>0) no inherit;
ERROR:  relation "atacc2" does not exist
drop table atacc2;
ERROR:  table "atacc2" does not exist
drop table atacc1;
-- test unique constraint adding
create table atacc1 ( test int ) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test);
ERROR:  relation "atacc1" does not exist
-- insert first value
insert into atacc1 (test) values (2);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (2);
                    ^
-- should fail
insert into atacc1 (test) values (2);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (2);
                    ^
-- should succeed
insert into atacc1 (test) values (4);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (4);
                    ^
-- try adding a unique oid constraint
alter table atacc1 add constraint atacc_oid1 unique(oid);
ERROR:  relation "atacc1" does not exist
-- try to create duplicates via alter table using - should fail
alter table atacc1 alter column test type integer using 0;
ERROR:  relation "atacc1" does not exist
drop table atacc1;
ERROR:  table "atacc1" does not exist
-- let's do one where the unique constraint fails when added
create table atacc1 ( test int );
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
insert into atacc1 (test) values (2);
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "atacc_test1" for table "atacc1"
ERROR:  could not create unique index "atacc_test1"
DETAIL:  Key (test)=(2) is duplicated.
insert into atacc1 (test) values (3);
drop table atacc1;
-- let's do one where the unique constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test1);
ERROR:  column "test1" named in key does not exist
drop table atacc1;
-- something a little more complicated
create table atacc1 ( test int, test2 int);
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test, test2);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "atacc_test1" for table "atacc1"
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test, test2)=(4, 4) already exists.
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
insert into atacc1 (test,test2) values (5,4);
insert into atacc1 (test,test2) values (5,5);
drop table atacc1;
-- lets do some naming tests
create table atacc1 (test int, test2 int, unique(test));
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "atacc1_test_key" for table "atacc1"
alter table atacc1 add unique (test2);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "atacc1_test2_key" for table "atacc1"
-- should fail for @@ second one @@
insert into atacc1 (test2, test) values (3, 3);
insert into atacc1 (test2, test) values (2, 3);
ERROR:  duplicate key value violates unique constraint "atacc1_test_key"
DETAIL:  Key (test)=(3) already exists.
drop table atacc1;
-- test primary key constraint adding
create table atacc1 ( test int ) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test);
ERROR:  relation "atacc1" does not exist
-- insert first value
insert into atacc1 (test) values (2);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (2);
                    ^
-- should fail
insert into atacc1 (test) values (2);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (2);
                    ^
-- should succeed
insert into atacc1 (test) values (4);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values (4);
                    ^
-- inserting NULL should fail
insert into atacc1 (test) values(NULL);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (test) values(NULL);
                    ^
-- try adding a second primary key (should fail)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ERROR:  relation "atacc1" does not exist
-- drop first primary key constraint
alter table atacc1 drop constraint atacc_test1 restrict;
ERROR:  relation "atacc1" does not exist
-- try adding a primary key on oid (should succeed)
alter table atacc1 add constraint atacc_oid1 primary key(oid);
ERROR:  relation "atacc1" does not exist
drop table atacc1;
ERROR:  table "atacc1" does not exist
-- let's do one where the primary key constraint fails when added
create table atacc1 ( test int );
-- insert soon to be failing rows
insert into atacc1 (test) values (2);
insert into atacc1 (test) values (2);
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "atacc_test1" for table "atacc1"
ERROR:  could not create unique index "atacc_test1"
DETAIL:  Key (test)=(2) is duplicated.
insert into atacc1 (test) values (3);
drop table atacc1;
-- let's do another one where the primary key constraint fails when added
create table atacc1 ( test int );
-- insert soon to be failing row
insert into atacc1 (test) values (NULL);
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "atacc_test1" for table "atacc1"
ERROR:  column "test" contains null values
insert into atacc1 (test) values (3);
drop table atacc1;
-- let's do one where the primary key constraint fails
-- because the column doesn't exist
create table atacc1 ( test int );
-- add a primary key constraint (fails)
alter table atacc1 add constraint atacc_test1 primary key (test1);
ERROR:  column "test1" named in key does not exist
drop table atacc1;
-- adding a new column as primary key to a non-empty table.
-- should fail unless the column has a non-null default value.
create table atacc1 ( test int );
insert into atacc1 (test) values (0);
-- add a primary key column without a default (fails).
alter table atacc1 add column test2 int primary key;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "atacc1_pkey" for table "atacc1"
ERROR:  column "test2" contains null values
-- now add a primary key column with a default (succeeds).
alter table atacc1 add column test2 int default 0 primary key;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "atacc1_pkey" for table "atacc1"
drop table atacc1;
-- something a little more complicated
create table atacc1 ( test int, test2 int);
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test, test2);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "atacc_test1" for table "atacc1"
-- try adding a second primary key - should fail
alter table atacc1 add constraint atacc_test2 primary key (test);
ERROR:  multiple primary keys for table "atacc1" are not allowed
-- insert initial value
insert into atacc1 (test,test2) values (4,4);
-- should fail
insert into atacc1 (test,test2) values (4,4);
ERROR:  duplicate key value violates unique constraint "atacc_test1"
DETAIL:  Key (test, test2)=(4, 4) already exists.
insert into atacc1 (test,test2) values (NULL,3);
ERROR:  null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, 3).
insert into atacc1 (test,test2) values (3, NULL);
ERROR:  null value in column "test2" violates not-null constraint
DETAIL:  Failing row contains (3, null).
insert into atacc1 (test,test2) values (NULL,NULL);
ERROR:  null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, null).
-- should all succeed
insert into atacc1 (test,test2) values (4,5);
insert into atacc1 (test,test2) values (5,4);
insert into atacc1 (test,test2) values (5,5);
drop table atacc1;
-- lets do some naming tests
create table atacc1 (test int, test2 int, primary key(test));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "atacc1_pkey" for table "atacc1"
-- only first should succeed
insert into atacc1 (test2, test) values (3, 3);
insert into atacc1 (test2, test) values (2, 3);
ERROR:  duplicate key value violates unique constraint "atacc1_pkey"
DETAIL:  Key (test)=(3) already exists.
insert into atacc1 (test2, test) values (1, NULL);
ERROR:  null value in column "test" violates not-null constraint
DETAIL:  Failing row contains (null, 1).
drop table atacc1;
-- alter table modify not null
-- try altering syscatlog should fail
alter table pg_class modify (relname not null enable);
ERROR:  permission denied: "pg_class" is a system catalog
alter table pg_class modify relname not null enable;
ERROR:  permission denied: "pg_class" is a system catalog
-- try altering non-existent table should fail
alter table non_existent modify (bar not null enable);
ERROR:  relation "non_existent" does not exist
-- test alter table
create table test_modify (a int, b int);
alter table test_modify modify (b not null enable);
insert into test_modify(b) values (null);
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (null, null).
insert into test_modify values (1, null);
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (1, null).
alter table test_modify modify(b null);
insert into test_modify values (1, null);
alter table test_modify modify (b not null enable);
ERROR:  column "b" contains null values
delete from test_modify;
alter table test_modify modify (a not null, b not null);
insert into test_modify values (1,null);
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (1, null).
insert into test_modify values (null,1);
ERROR:  null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null, 1).
alter table test_modify modify (a null, b null);
insert into test_modify values (1,null);
insert into test_modify values (null,1);
alter table test_modify modify (b constraint ak not null);
ERROR:  column "b" contains null values
delete from test_modify;
alter table test_modify modify (b constraint ak not null);
insert into test_modify values(1,1);
insert into test_modify values(1,null);
ERROR:  null value in column "b" violates not-null constraint
DETAIL:  Failing row contains (1, null).
alter table test_modify modify (b constraint ak null);
insert into test_modify values(1,null);
alter table test_modify modify (a null, a not null);
ERROR:  cannot alter type of column "a" twice
-- try alter view should fail
create view test_modify_view as select * from test_modify;
alter table test_modify_view modify (a not null enable);
ERROR:  "test_modify_view" is not a table or foreign table
drop view test_modify_view;
drop table test_modify;
-- alter table / alter column [set/drop] not null tests
-- try altering system catalogs, should fail
alter table pg_class alter column relname drop not null;
ERROR:  permission denied: "pg_class" is a system catalog
alter table pg_class alter relname set not null;
ERROR:  permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table non_existent alter column bar set not null;
ERROR:  relation "non_existent" does not exist
alter table non_existent alter column bar drop not null;
ERROR:  relation "non_existent" does not exist
-- test setting columns to null and not null and vice versa
-- test checking for null values and primary key
create table atacc1 (test int not null) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
alter table atacc1 add constraint "atacc1_pkey" primary key (test);
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter column test drop not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 drop constraint "atacc1_pkey";
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter column test drop not null;
ERROR:  relation "atacc1" does not exist
insert into atacc1 values (null);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (null);
                    ^
alter table atacc1 alter test set not null;
ERROR:  relation "atacc1" does not exist
delete from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: delete from atacc1;
                    ^
alter table atacc1 alter test set not null;
ERROR:  relation "atacc1" does not exist
-- try altering a non-existent column, should fail
alter table atacc1 alter bar set not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter bar drop not null;
ERROR:  relation "atacc1" does not exist
-- try altering the oid column, should fail
alter table atacc1 alter oid set not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter oid drop not null;
ERROR:  relation "atacc1" does not exist
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: create view myview as select * from atacc1;
                                            ^
alter table myview alter column test drop not null;
ERROR:  relation "myview" does not exist
alter table myview alter column test set not null;
ERROR:  relation "myview" does not exist
drop view myview;
ERROR:  view "myview" does not exist
drop table atacc1;
ERROR:  table "atacc1" does not exist
-- test inheritance
create table parent (a int);
create table child (b varchar(255)) inherits (parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
alter table parent alter a set not null;
insert into parent values (NULL);
ERROR:  null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null).
insert into child (a, b) values (NULL, 'foo');
ERROR:  relation "child" does not exist
LINE 1: insert into child (a, b) values (NULL, 'foo');
                    ^
alter table parent alter a drop not null;
insert into parent values (NULL);
insert into child (a, b) values (NULL, 'foo');
ERROR:  relation "child" does not exist
LINE 1: insert into child (a, b) values (NULL, 'foo');
                    ^
alter table only parent alter a set not null;
ERROR:  column "a" contains null values
alter table child alter a set not null;
ERROR:  relation "child" does not exist
delete from parent;
alter table only parent alter a set not null;
insert into parent values (NULL);
ERROR:  null value in column "a" violates not-null constraint
DETAIL:  Failing row contains (null).
alter table child alter a set not null;
ERROR:  relation "child" does not exist
insert into child (a, b) values (NULL, 'foo');
ERROR:  relation "child" does not exist
LINE 1: insert into child (a, b) values (NULL, 'foo');
                    ^
delete from child;
ERROR:  relation "child" does not exist
LINE 1: delete from child;
                    ^
alter table child alter a set not null;
ERROR:  relation "child" does not exist
insert into child (a, b) values (NULL, 'foo');
ERROR:  relation "child" does not exist
LINE 1: insert into child (a, b) values (NULL, 'foo');
                    ^
drop table child;
ERROR:  table "child" does not exist
drop table parent;
-- test setting and removing default values
create table def_test (
	c1	int4 default 5,
	c2	text default 'initial_default'
);
insert into def_test default values;
alter table def_test alter column c1 drop default;
insert into def_test default values;
alter table def_test alter column c2 drop default;
insert into def_test default values;
alter table def_test alter column c1 set default 10;
alter table def_test alter column c2 set default 'new_default';
insert into def_test default values;
select * from def_test order by 1, 2;
 c1 |       c2        
----+-----------------
  5 | initial_default
 10 | new_default
    | initial_default
    | 
(4 rows)

-- set defaults to an incorrect type: this should fail
alter table def_test alter column c1 set default 'wrong_datatype';
ERROR:  invalid input syntax for integer: "wrong_datatype"
alter table def_test alter column c2 set default 20;
-- set defaults on a non-existent column: this should fail
alter table def_test alter column c3 set default 30;
ERROR:  column "c3" of relation "def_test" does not exist
-- set defaults on views: we need to create a view, add a rule
-- to allow insertions into it, and then alter the view to add
-- a default
create view def_view_test as select * from def_test;
create rule def_view_test_ins as
	on insert to def_view_test
	do instead insert into def_test select new.*;
ERROR:  RULE is not yet supported.
insert into def_view_test default values;
ERROR:  cannot insert into view "def_view_test"
HINT:  You need an unconditional ON INSERT DO INSTEAD rule or an INSTEAD OF INSERT trigger.
alter table def_view_test alter column c1 set default 45;
insert into def_view_test default values;
ERROR:  cannot insert into view "def_view_test"
HINT:  You need an unconditional ON INSERT DO INSTEAD rule or an INSTEAD OF INSERT trigger.
alter table def_view_test alter column c2 set default 'view_default';
insert into def_view_test default values;
ERROR:  cannot insert into view "def_view_test"
HINT:  You need an unconditional ON INSERT DO INSTEAD rule or an INSTEAD OF INSERT trigger.
select * from def_view_test order by 1, 2;
 c1 |       c2        
----+-----------------
  5 | initial_default
 10 | new_default
    | initial_default
    | 
(4 rows)

drop rule def_view_test_ins on def_view_test;
ERROR:  rule "def_view_test_ins" for relation "def_view_test" does not exist
drop view def_view_test;
drop table def_test;
-- alter table / drop column tests
-- try altering system catalogs, should fail
alter table pg_class drop column relname;
ERROR:  permission denied: "pg_class" is a system catalog
-- try altering non-existent table, should fail
alter table nosuchtable drop column bar;
ERROR:  relation "nosuchtable" does not exist
-- test dropping columns
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
insert into atacc1 values (1, 2, 3, 4);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (1, 2, 3, 4);
                    ^
alter table atacc1 drop a;
ERROR:  relation "atacc1" does not exist
alter table atacc1 drop a;
ERROR:  relation "atacc1" does not exist
-- SELECTs
select * from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1;
                      ^
select * from atacc1 order by a;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 order by a;
                      ^
select * from atacc1 order by "........pg.dropped.1........";
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 order by "........pg.dropped.1........"...
                      ^
select * from atacc1 group by a;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 group by a;
                      ^
select * from atacc1 group by "........pg.dropped.1........";
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 group by "........pg.dropped.1........"...
                      ^
select atacc1.* from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select atacc1.* from atacc1;
                             ^
select a from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select a from atacc1;
                      ^
select atacc1.a from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select atacc1.a from atacc1;
                             ^
select b,c,d from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select b,c,d from atacc1;
                          ^
select a,b,c,d from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select a,b,c,d from atacc1;
                            ^
select * from atacc1 where a = 1;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 where a = 1;
                      ^
select "........pg.dropped.1........" from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select "........pg.dropped.1........" from atacc1;
                                                   ^
select atacc1."........pg.dropped.1........" from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select atacc1."........pg.dropped.1........" from atacc1;
                                                          ^
select "........pg.dropped.1........",b,c,d from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select "........pg.dropped.1........",b,c,d from atacc1;
                                                         ^
select * from atacc1 where "........pg.dropped.1........" = 1;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1 where "........pg.dropped.1........" = ...
                      ^
-- UPDATEs
update atacc1 set a = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: update atacc1 set a = 3;
               ^
update atacc1 set b = 2 where a = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: update atacc1 set b = 2 where a = 3;
               ^
update atacc1 set "........pg.dropped.1........" = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: update atacc1 set "........pg.dropped.1........" = 3;
               ^
update atacc1 set b = 2 where "........pg.dropped.1........" = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: update atacc1 set b = 2 where "........pg.dropped.1........"...
               ^
-- INSERTs
insert into atacc1 values (10, 11, 12, 13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (10, 11, 12, 13);
                    ^
insert into atacc1 values (default, 11, 12, 13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (default, 11, 12, 13);
                    ^
insert into atacc1 values (11, 12, 13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (11, 12, 13);
                    ^
insert into atacc1 (a) values (10);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (10);
                    ^
insert into atacc1 (a) values (default);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (a) values (default);
                    ^
insert into atacc1 (a,b,c,d) values (10,11,12,13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (10,11,12,13);
                    ^
insert into atacc1 (a,b,c,d) values (default,11,12,13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (a,b,c,d) values (default,11,12,13);
                    ^
insert into atacc1 (b,c,d) values (11,12,13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 (b,c,d) values (11,12,13);
                    ^
insert into atacc1 ("........pg.dropped.1........") values (10);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                    ^
insert into atacc1 ("........pg.dropped.1........") values (default);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........") values (...
                    ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                    ^
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 ("........pg.dropped.1........",b,c,d) va...
                    ^
-- DELETEs
delete from atacc1 where a = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: delete from atacc1 where a = 3;
                    ^
delete from atacc1 where "........pg.dropped.1........" = 3;
ERROR:  relation "atacc1" does not exist
LINE 1: delete from atacc1 where "........pg.dropped.1........" = 3;
                    ^
delete from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: delete from atacc1;
                    ^
-- try dropping a non-existent column, should fail
alter table atacc1 drop bar;
ERROR:  relation "atacc1" does not exist
-- try dropping the oid column, should succeed
alter table atacc1 drop oid;
ERROR:  relation "atacc1" does not exist
-- try dropping the xmin column, should fail
alter table atacc1 drop xmin;
ERROR:  relation "atacc1" does not exist
-- try creating a view and altering that, should fail
create view myview as select * from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: create view myview as select * from atacc1;
                                            ^
select * from myview;
ERROR:  relation "myview" does not exist
LINE 1: select * from myview;
                      ^
alter table myview drop d;
ERROR:  relation "myview" does not exist
drop view myview;
ERROR:  view "myview" does not exist
-- test some commands to make sure they fail on the dropped column
analyze atacc1(a);
ERROR:  relation "atacc1" does not exist
analyze atacc1("........pg.dropped.1........");
ERROR:  relation "atacc1" does not exist
vacuum analyze atacc1(a);
ERROR:  relation "atacc1" does not exist
vacuum analyze atacc1("........pg.dropped.1........");
ERROR:  relation "atacc1" does not exist
comment on column atacc1.a is 'testing';
ERROR:  relation "atacc1" does not exist
comment on column atacc1."........pg.dropped.1........" is 'testing';
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a set storage plain;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set storage plain;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a set statistics 0;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set statistics 0;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a set default 3;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set default 3;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a drop default;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" drop default;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a set not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" set not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter a drop not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 alter "........pg.dropped.1........" drop not null;
ERROR:  relation "atacc1" does not exist
alter table atacc1 rename a to x;
ERROR:  relation "atacc1" does not exist
alter table atacc1 rename "........pg.dropped.1........" to x;
ERROR:  relation "atacc1" does not exist
alter table atacc1 add primary key(a);
ERROR:  relation "atacc1" does not exist
alter table atacc1 add primary key("........pg.dropped.1........");
ERROR:  relation "atacc1" does not exist
alter table atacc1 add unique(a);
ERROR:  relation "atacc1" does not exist
alter table atacc1 add unique("........pg.dropped.1........");
ERROR:  relation "atacc1" does not exist
alter table atacc1 add check (a > 3);
ERROR:  relation "atacc1" does not exist
alter table atacc1 add check ("........pg.dropped.1........" > 3);
ERROR:  relation "atacc1" does not exist
create table atacc2 (id int4 unique);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "atacc2_id_key" for table "atacc2"
alter table atacc1 add foreign key (a) references atacc2(id);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
alter table atacc2 add foreign key (id) references atacc1(a);
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........");
ERROR:  FOREIGN KEY ... REFERENCES constraint is not yet supported.
drop table atacc2;
create index "testing_idx" on atacc1(a);
ERROR:  relation "atacc1" does not exist
create index "testing_idx" on atacc1("........pg.dropped.1........");
ERROR:  relation "atacc1" does not exist
-- test create as and select into
insert into atacc1 values (21, 22, 23);
ERROR:  relation "atacc1" does not exist
LINE 1: insert into atacc1 values (21, 22, 23);
                    ^
create table test1 as select * from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: create table test1 as select * from atacc1;
                                            ^
select * from test1;
ERROR:  relation "test1" does not exist
LINE 1: select * from test1;
                      ^
drop table test1;
ERROR:  table "test1" does not exist
select * into test2 from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select * into test2 from atacc1;
                                 ^
select * from test2;
ERROR:  relation "test2" does not exist
LINE 1: select * from test2;
                      ^
drop table test2;
ERROR:  table "test2" does not exist
-- try dropping all columns
alter table atacc1 drop c;
ERROR:  relation "atacc1" does not exist
alter table atacc1 drop d;
ERROR:  relation "atacc1" does not exist
alter table atacc1 drop b;
ERROR:  relation "atacc1" does not exist
select * from atacc1;
ERROR:  relation "atacc1" does not exist
LINE 1: select * from atacc1;
                      ^
drop table atacc1;
ERROR:  table "atacc1" does not exist
-- test constraint error reporting in presence of dropped columns
create table atacc1 (id serial primary key, value int check (value < 10));
NOTICE:  CREATE TABLE will create implicit sequence "atacc1_id_seq" for serial column "atacc1.id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "atacc1_pkey" for table "atacc1"
insert into atacc1(value) values (100);
ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
DETAIL:  Failing row contains (1, 100).
alter table atacc1 drop column value;
alter table atacc1 add column value int check (value < 10);
insert into atacc1(value) values (100);
ERROR:  new row for relation "atacc1" violates check constraint "atacc1_value_check"
DETAIL:  Failing row contains (2, 100).
insert into atacc1(id, value) values (null, 0);
ERROR:  null value in column "id" violates not-null constraint
DETAIL:  Failing row contains (null, 0).
drop table atacc1;
-- test inheritance
create table parent (a int, b int, c int);
insert into parent values (1, 2, 3);
alter table parent drop a;
create table child (d varchar(255)) inherits (parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
insert into child values (12, 13, 'testing');
ERROR:  relation "child" does not exist
LINE 1: insert into child values (12, 13, 'testing');
                    ^
select * from parent order by b;
 b | c 
---+---
 2 | 3
(1 row)

select * from child;
ERROR:  relation "child" does not exist
LINE 1: select * from child;
                      ^
alter table parent drop c;
select * from parent order by b;
 b 
---
 2
(1 row)

select * from child;
ERROR:  relation "child" does not exist
LINE 1: select * from child;
                      ^
drop table child;
ERROR:  table "child" does not exist
drop table parent;
-- test copy in/out
create table test (a int4, b int4, c int4);
insert into test values (1,2,3);
alter table test drop a;
copy test to stdout;
2	3
copy test(a) to stdout;
ERROR:  column "a" of relation "test" does not exist
copy test("........pg.dropped.1........") to stdout;
ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
copy test from stdin;
ERROR:  extra data after last expected column
CONTEXT:  COPY test, line 1: "10	11	12"
select * from test order by b;
 b | c 
---+---
 2 | 3
(1 row)

copy test from stdin;
select * from test order by b;
 b  | c  
----+----
  2 |  3
 21 | 22
(2 rows)

copy test(a) from stdin;
ERROR:  column "a" of relation "test" does not exist
copy test("........pg.dropped.1........") from stdin;
ERROR:  column "........pg.dropped.1........" of relation "test" does not exist
copy test(b,c) from stdin;
select * from test order by b;
 b  | c  
----+----
  2 |  3
 21 | 22
 31 | 32
(3 rows)

drop table test;
-- test inheritance
create table dropColumn (a int, b int, e int);
create table dropColumnChild (c int) inherits (dropColumn);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table dropColumnAnother (d int) inherits (dropColumnChild);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- these two should fail
alter table dropColumnchild drop column a;
ERROR:  relation "dropcolumnchild" does not exist
alter table only dropColumnChild drop column b;
ERROR:  relation "dropcolumnchild" does not exist
-- these three should work
alter table only dropColumn drop column e;
alter table dropColumnChild drop column c;
ERROR:  relation "dropcolumnchild" does not exist
alter table dropColumn drop column a;
create table renameColumn (a int);
create table renameColumnChild (b int) inherits (renameColumn);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table renameColumnAnother (c int) inherits (renameColumnChild);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- these three should fail
alter table renameColumnChild rename column a to d;
ERROR:  relation "renamecolumnchild" does not exist
alter table only renameColumnChild rename column a to d;
ERROR:  relation "renamecolumnchild" does not exist
alter table only renameColumn rename column a to d;
-- these should work
alter table renameColumn rename column a to d;
ERROR:  column "a" does not exist
alter table renameColumnChild rename column b to a;
ERROR:  relation "renamecolumnchild" does not exist
-- these should work
alter table if exists doesnt_exist_tab rename column a to d;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
alter table if exists doesnt_exist_tab rename column b to a;
NOTICE:  relation "doesnt_exist_tab" does not exist, skipping
-- this should work
alter table renameColumn add column w int;
-- this should fail
alter table only renameColumn add column x int;
-- Test corner cases in dropping of inherited columns
create table p1 (f1 int, f2 int);
create table c1 (f1 int not null) inherits(p1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
-- should work
alter table p1 drop column f1;
-- c1.f1 is still there, but no longer inherited
select f1 from c1;
ERROR:  relation "c1" does not exist
LINE 1: select f1 from c1;
                       ^
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
select f1 from c1;
ERROR:  relation "c1" does not exist
LINE 1: select f1 from c1;
                       ^
drop table p1 cascade;
create table p1 (f1 int, f2 int);
create table c1 () inherits(p1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
alter table p1 drop column f1;
-- c1.f1 is dropped now, since there is no local definition for it
select f1 from c1;
ERROR:  relation "c1" does not exist
LINE 1: select f1 from c1;
                       ^
drop table p1 cascade;
create table p1 (f1 int, f2 int);
create table c1 () inherits(p1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
alter table only p1 drop column f1;
-- c1.f1 is NOT dropped, but must now be considered non-inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
drop table p1 cascade;
create table p1 (f1 int, f2 int);
create table c1 (f1 int not null) inherits(p1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
alter table only p1 drop column f1;
-- c1.f1 is still there, but no longer inherited
alter table c1 drop column f1;
ERROR:  relation "c1" does not exist
drop table p1 cascade;
create table p1(id int, name text);
create table p2(id2 int, name text, height int);
create table c1(age int) inherits(p1,p2);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table gc1() inherits (c1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 p1      | id      |           0 | t
 p1      | name    |           0 | t
 p2      | id2     |           0 | t
 p2      | name    |           0 | t
 p2      | height  |           0 | t
(5 rows)

-- should work
alter table only p1 drop column name;
-- should work. Now c1.name is local and inhcount is 0.
alter table p2 drop column name;
-- should be rejected since its inherited
alter table gc1 drop column name;
ERROR:  relation "gc1" does not exist
-- should work, and drop gc1.name along
alter table c1 drop column name;
ERROR:  relation "c1" does not exist
-- should fail: column does not exist
alter table gc1 drop column name;
ERROR:  relation "gc1" does not exist
-- should work and drop the attribute in all tables
alter table p2 drop column height;
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum;
 relname | attname | attinhcount | attislocal 
---------+---------+-------------+------------
 p1      | id      |           0 | t
 p2      | id2     |           0 | t
(2 rows)

drop table p1, p2 cascade;
--
-- Test the ALTER TABLE SET WITH/WITHOUT OIDS command
--
create table altstartwith (col integer) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
insert into altstartwith values (1);
ERROR:  relation "altstartwith" does not exist
LINE 1: insert into altstartwith values (1);
                    ^
select oid > 0, * from altstartwith;
ERROR:  relation "altstartwith" does not exist
LINE 1: select oid > 0, * from altstartwith;
                               ^
alter table altstartwith set without oids;
ERROR:  relation "altstartwith" does not exist
select oid > 0, * from altstartwith; -- fails
ERROR:  relation "altstartwith" does not exist
LINE 1: select oid > 0, * from altstartwith;
                               ^
select * from altstartwith;
ERROR:  relation "altstartwith" does not exist
LINE 1: select * from altstartwith;
                      ^
alter table altstartwith set with oids;
ERROR:  relation "altstartwith" does not exist
select oid > 0, * from altstartwith;
ERROR:  relation "altstartwith" does not exist
LINE 1: select oid > 0, * from altstartwith;
                               ^
drop table altstartwith;
ERROR:  table "altstartwith" does not exist
-- Check inheritance cases
create table altwithoid (col integer) with oids;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
-- Inherits parents oid column anyway
create table altinhoid () inherits (altwithoid) without oids;
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
insert into altinhoid values (1);
ERROR:  relation "altinhoid" does not exist
LINE 1: insert into altinhoid values (1);
                    ^
select oid > 0, * from altwithoid;
ERROR:  relation "altwithoid" does not exist
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
alter table altwithoid set without oids;
ERROR:  relation "altwithoid" does not exist
select oid > 0, * from altwithoid; -- fails
ERROR:  relation "altwithoid" does not exist
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid; -- fails
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
select * from altwithoid;
ERROR:  relation "altwithoid" does not exist
LINE 1: select * from altwithoid;
                      ^
select * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select * from altinhoid;
                      ^
alter table altwithoid set with oids;
ERROR:  relation "altwithoid" does not exist
select oid > 0, * from altwithoid;
ERROR:  relation "altwithoid" does not exist
LINE 1: select oid > 0, * from altwithoid;
                               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
drop table altwithoid cascade;
ERROR:  table "altwithoid" does not exist
create table altwithoid (col integer) without oids;
-- child can have local oid column
create table altinhoid () inherits (altwithoid) with oids;
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
insert into altinhoid values (1);
ERROR:  relation "altinhoid" does not exist
LINE 1: insert into altinhoid values (1);
                    ^
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
alter table altwithoid set with oids;
ERROR:  Un-support feature
DETAIL:  ALTER TABLE ... SET WITH OIDS is not yet supported.
select oid > 0, * from altwithoid;
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
-- the child's local definition should remain
alter table altwithoid set without oids;
ERROR:  Un-support feature
DETAIL:  ALTER TABLE ... SET WITHOUT OIDS is not yet supported.
select oid > 0, * from altwithoid; -- fails
ERROR:  column "oid" does not exist
LINE 1: select oid > 0, * from altwithoid;
               ^
select oid > 0, * from altinhoid;
ERROR:  relation "altinhoid" does not exist
LINE 1: select oid > 0, * from altinhoid;
                               ^
drop table altwithoid cascade;
-- test renumbering of child-table columns in inherited operations
create table p1 (f1 int);
create table c1 (f2 text, f3 int) inherits (p1);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
alter table p1 add column a1 int check (a1 > 0);
alter table p1 add column f2 text;
insert into p1 values (1,2,'abc');
insert into c1 values(11,'xyz',33,0); -- should fail
ERROR:  relation "c1" does not exist
LINE 1: insert into c1 values(11,'xyz',33,0);
                    ^
insert into c1 values(11,'xyz',33,22);
ERROR:  relation "c1" does not exist
LINE 1: insert into c1 values(11,'xyz',33,22);
                    ^
select * from p1 order by f1;
 f1 | a1 | f2  
----+----+-----
  1 |  2 | abc
(1 row)

update p1 set a1 = a1 + 1, f2 = upper(f2);
select * from p1 order by f1;
 f1 | a1 | f2  
----+----+-----
  1 |  3 | ABC
(1 row)

drop table p1 cascade;
-- test that operations with a dropped column do not try to reference
-- its datatype
create domain mytype as text;
ERROR:  domain is not yet supported.
create table foo (f1 text, f2 mytype, f3 text);
ERROR:  type "mytype" does not exist
LINE 1: create table foo (f1 text, f2 mytype, f3 text);
                                      ^
insert into foo values('bb','cc','dd');
ERROR:  relation "foo" does not exist
LINE 1: insert into foo values('bb','cc','dd');
                    ^
select * from foo order by f1;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo order by f1;
                      ^
drop domain mytype cascade;
ERROR:  type "mytype" does not exist
select * from foo order by f1;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo order by f1;
                      ^
insert into foo values('qq','rr');
ERROR:  relation "foo" does not exist
LINE 1: insert into foo values('qq','rr');
                    ^
select * from foo order by f1;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo order by f1;
                      ^
update foo set f3 = 'zz';
ERROR:  relation "foo" does not exist
LINE 1: update foo set f3 = 'zz';
               ^
select * from foo order by f1;
ERROR:  relation "foo" does not exist
LINE 1: select * from foo order by f1;
                      ^
select f3,max(f1) from foo group by f3;
ERROR:  relation "foo" does not exist
LINE 1: select f3,max(f1) from foo group by f3;
                               ^
-- Simple tests for alter table column type
delete from foo where f1 = 'qq';
ERROR:  relation "foo" does not exist
LINE 1: delete from foo where f1 = 'qq';
                    ^
alter table foo alter f1 TYPE integer; -- fails
ERROR:  relation "foo" does not exist
alter table foo alter f1 TYPE varchar(10);
ERROR:  relation "foo" does not exist
drop table foo;
ERROR:  table "foo" does not exist
create table anothertab (atcol1 serial8, atcol2 boolean,
	constraint anothertab_chk check (atcol1 <= 3));;
NOTICE:  CREATE TABLE will create implicit sequence "anothertab_atcol1_seq" for serial column "anothertab.atcol1"
insert into anothertab (atcol1, atcol2) values (default, true);
insert into anothertab (atcol1, atcol2) values (default, false);
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | t
      2 | f
(2 rows)

alter table anothertab alter column atcol1 type boolean; -- we could support this cast
alter table anothertab alter column atcol1 type integer;
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | f
      1 | t
(2 rows)

insert into anothertab (atcol1, atcol2) values (45, null); -- fails
ERROR:  new row for relation "anothertab" violates check constraint "anothertab_chk"
DETAIL:  Failing row contains (45, null).
insert into anothertab (atcol1, atcol2) values (default, null);
select * from anothertab order by atcol1, atcol2;
 atcol1 | atcol2 
--------+--------
      1 | f
      1 | t
      3 | 
(3 rows)

alter table anothertab alter column atcol2 type text
      using case when atcol2 is true then 'IT WAS TRUE'
                 when atcol2 is false then 'IT WAS FALSE'
                 else 'IT WAS NULL!' end;
select * from anothertab order by atcol1, atcol2;
 atcol1 |    atcol2    
--------+--------------
      1 | IT WAS FALSE
      1 | IT WAS TRUE
      3 | IT WAS NULL!
(3 rows)

alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
alter table anothertab alter column atcol1 drop default;
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end; -- fails
alter table anothertab drop constraint anothertab_chk;
alter table anothertab drop constraint anothertab_chk; -- fails
ERROR:  constraint "anothertab_chk" of relation "anothertab" does not exist
alter table anothertab drop constraint IF EXISTS anothertab_chk; -- succeeds
NOTICE:  constraint "anothertab_chk" of relation "anothertab" does not exist, skipping
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end;
select * from anothertab order by atcol1, atcol2;
 atcol1 |    atcol2    
--------+--------------
 f      | IT WAS FALSE
 f      | IT WAS NULL!
 f      | IT WAS TRUE
(3 rows)

drop table anothertab;
create table another (f1 int, f2 text);;
insert into another values(1, 'one');
insert into another values(2, 'two');
insert into another values(3, 'three');
select * from another order by f1, f2;
 f1 |  f2   
----+-------
  1 | one
  2 | two
  3 | three
(3 rows)

alter table another
  alter f1 type text using f2 || ' more',
  alter f2 type bigint using f1 * 10;
select * from another order by f1, f2;
     f1     | f2 
------------+----
 one more   | 10
 three more | 30
 two more   | 20
(3 rows)

drop table another;
-- table's row type
create table tab1 (a int, b text);
create table tab2 (x int, y tab1);
alter table tab1 alter column b type varchar; -- fails
ERROR:  cannot alter table "tab1" because column "tab2.y" uses its row type
-- disallow recursive containment of row types
create table recur1 (f1 int);
alter table recur1 add column f2 recur1; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 recur1[]; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
create domain array_of_recur1 as recur1[];
ERROR:  domain is not yet supported.
alter table recur1 add column f2 array_of_recur1; -- fails
ERROR:  type "array_of_recur1" does not exist
LINE 1: alter table recur1 add column f2 array_of_recur1;
                                         ^
create table recur2 (f1 int, f2 recur1);
alter table recur1 add column f2 recur2; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
alter table recur1 add column f2 int;
alter table recur1 alter column f2 type recur2; -- fails
ERROR:  composite type recur1 cannot be made a member of itself
-- SET STORAGE may need to add a TOAST table
create table test_storage (a text);
alter table test_storage alter a set storage plain;
alter table test_storage add b int default 0; -- rewrite table to remove its TOAST table
alter table test_storage alter a set storage extended; -- re-add TOAST table
select reltoastrelid <> 0 as has_toast_table
from pg_class
where oid = 'test_storage'::regclass;
 has_toast_table 
-----------------
 t
(1 row)

-- ALTER TYPE with a check constraint and a child table (bug before Nov 2012)
CREATE TABLE test_inh_check (a float check (a > 10.2));
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric;
\d test_inh_check
Table "public.test_inh_check"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | numeric | 
Check constraints:
    "test_inh_check_a_check" CHECK (a::double precision > 10.2::double precision)

\d test_inh_check_child
--
-- lock levels
--
drop type lockmodes;
ERROR:  type "lockmodes" does not exist
create type lockmodes as enum (
 'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
);
ERROR:  user defined type is not yet supported.
drop view my_locks;
ERROR:  view "my_locks" does not exist
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = txid_current()::integer)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname;
ERROR:  type "lockmodes" does not exist
LINE 2: ...t%' then 'pg_toast' else c.relname end, max(mode::lockmodes)...
                                                             ^
CONTEXT:  referenced column: max_lockmode
create table alterlock (f1 int primary key, f2 text);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "alterlock_pkey" for table "alterlock"
start transaction; alter table alterlock alter column f2 set statistics 150;
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
rollback;
start transaction; alter table alterlock cluster on alterlock_pkey;
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock set without cluster;
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock set (fillfactor = 100);
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock reset (fillfactor);
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock set (toast.autovacuum_enabled = off);
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock set (autovacuum_enabled = off);
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
commit;
start transaction; alter table alterlock alter column f2 set (n_distinct = 1);
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
rollback;
start transaction; alter table alterlock alter column f2 set storage extended;
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
rollback;
start transaction; alter table alterlock alter column f2 set default 'x';
select * from my_locks order by 1;
ERROR:  relation "my_locks" does not exist
LINE 1: select * from my_locks order by 1;
                      ^
rollback;
-- cleanup
drop table alterlock;
drop view my_locks;
ERROR:  view "my_locks" does not exist
drop type lockmodes;
ERROR:  type "lockmodes" does not exist
--
-- alter function
--
create function test_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql returns null on null input;
select test_strict(NULL);
 test_strict 
-------------
 
(1 row)

alter function test_strict(text) called on null input;
select test_strict(NULL);
    test_strict    
-------------------
 got passed a null
(1 row)

create function non_strict(text) returns text as
    'select coalesce($1, ''got passed a null'');'
    language sql called on null input;
select non_strict(NULL);
    non_strict     
-------------------
 got passed a null
(1 row)

alter function non_strict(text) returns null on null input;
select non_strict(NULL);
 non_strict 
------------
 
(1 row)

--
-- alter object set schema
--
create schema alter1;
create schema alter2;
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0));
NOTICE:  CREATE TABLE will create implicit sequence "t1_f1_seq" for serial column "t1.f1"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create view alter1.v1 as select * from alter1.t1;
create function alter1.plus1(int) returns int as 'select $1+1' language sql;
create domain alter1.posint integer check (value > 0);
ERROR:  domain is not yet supported.
create type alter1.ctype as (f1 int, f2 text);
ERROR:  user defined type is not yet supported.
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2';
ERROR:  type alter1.ctype does not exist
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype);
ERROR:  user defined operator is not yet supported.
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
  operator 1 alter1.=(alter1.ctype, alter1.ctype);
ERROR:  user defined operator is not yet supported.
create conversion alter1.ascii_to_utf8 for 'sql_ascii' to 'utf8' from ascii_to_utf8;
ERROR:  user defined conversion is not yet supported.
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
ERROR:  user-defined text search parser is not yet supported.
create text search configuration alter1.cfg(parser = alter1.prs);
ERROR:  text search parser "alter1.prs" does not exist
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize);
ERROR:  user-defined text search template is not yet supported.
create text search dictionary alter1.dict(template = alter1.tmpl);
ERROR:  user-defined text search dictionary is not yet supported.
insert into alter1.t1(f2) values(11);
insert into alter1.t1(f2) values(12);
alter table alter1.t1 set schema alter2;
ERROR:  There's dependent sequence, but ALTER SEQUENCE SET SCHEMA is not yet supported.
alter table alter1.v1 set schema alter2;
alter function alter1.plus1(int) set schema alter2;
alter domain alter1.posint set schema alter2;
ERROR:  type "alter1.posint" does not exist
alter operator class alter1.ctype_hash_ops using hash set schema alter2;
ERROR:  operator class "alter1.ctype_hash_ops" does not exist for access method "hash"
alter operator family alter1.ctype_hash_ops using hash set schema alter2;
ERROR:  operator family "alter1.ctype_hash_ops" does not exist for access method "hash"
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2;
ERROR:  type "alter1.ctype" does not exist
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2;
ERROR:  type "alter1.ctype" does not exist
alter type alter1.ctype set schema alter2;
ERROR:  type "alter1.ctype" does not exist
alter conversion alter1.ascii_to_utf8 set schema alter2;
ERROR:  conversion "alter1.ascii_to_utf8" does not exist
alter text search parser alter1.prs set schema alter2;
ERROR:  TEXT SEARCH PARSER is not yet supported.
alter text search configuration alter1.cfg set schema alter2;
ERROR:  text search configuration "alter1.cfg" does not exist
alter text search template alter1.tmpl set schema alter2;
ERROR:  TEXT SEARCH TEMPLATE is not yet supported.
alter text search dictionary alter1.dict set schema alter2;
ERROR:  TEXT SEARCH DICTIONARY is not yet supported.
-- this should succeed because nothing is left in alter1
drop schema alter1;
ERROR:  cannot drop schema alter1 because other objects depend on it
DETAIL:  table alter1.t1 depends on schema alter1
view alter2.v1 depends on table alter1.t1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
insert into alter2.t1(f2) values(13);
ERROR:  relation "alter2.t1" does not exist
LINE 1: insert into alter2.t1(f2) values(13);
                    ^
insert into alter2.t1(f2) values(14);
ERROR:  relation "alter2.t1" does not exist
LINE 1: insert into alter2.t1(f2) values(14);
                    ^
select * from alter2.t1 order by f1, f2;
ERROR:  relation "alter2.t1" does not exist
LINE 1: select * from alter2.t1 order by f1, f2;
                      ^
select * from alter2.v1 order by f1, f2;
 f1 | f2 
----+----
  1 | 11
  2 | 12
(2 rows)

select alter2.plus1(41);
 plus1 
-------
    42
(1 row)

-- clean up
drop schema alter2 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view alter2.v1
drop cascades to function alter2.plus1(integer)
drop schema alter1 cascade;
NOTICE:  drop cascades to table alter1.t1
--
-- composite types
--
CREATE TYPE test_type AS (a int);
ERROR:  user defined type is not yet supported.
\d test_type
ALTER TYPE nosuchtype ADD ATTRIBUTE b text; -- fails
ERROR:  relation "nosuchtype" does not exist
ALTER TYPE test_type ADD ATTRIBUTE b text;
ERROR:  relation "test_type" does not exist
\d test_type
ALTER TYPE test_type ADD ATTRIBUTE b text; -- fails
ERROR:  relation "test_type" does not exist
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar;
ERROR:  relation "test_type" does not exist
\d test_type
ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer;
ERROR:  relation "test_type" does not exist
\d test_type
ALTER TYPE test_type DROP ATTRIBUTE b;
ERROR:  relation "test_type" does not exist
\d test_type
ALTER TYPE test_type DROP ATTRIBUTE c; -- fails
ERROR:  relation "test_type" does not exist
ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c;
ERROR:  relation "test_type" does not exist
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean;
ERROR:  relation "test_type" does not exist
\d test_type
ALTER TYPE test_type RENAME ATTRIBUTE a TO aa;
ERROR:  relation "test_type" does not exist
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd;
ERROR:  relation "test_type" does not exist
\d test_type
DROP TYPE test_type;
ERROR:  type "test_type" does not exist
CREATE TYPE test_type1 AS (a int, b text);
ERROR:  user defined type is not yet supported.
CREATE TABLE test_tbl1 (x int, y test_type1);
ERROR:  type "test_type1" does not exist
LINE 1: CREATE TABLE test_tbl1 (x int, y test_type1);
                                         ^
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  relation "test_type1" does not exist
CREATE TYPE test_type2 AS (a int, b text);
ERROR:  user defined type is not yet supported.
CREATE TABLE test_tbl2 OF test_type2;
ERROR:  type "test_type2" does not exist
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 ADD ATTRIBUTE c text; -- fails
ERROR:  relation "test_type2" does not exist
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE;
ERROR:  relation "test_type2" does not exist
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar; -- fails
ERROR:  relation "test_type2" does not exist
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE;
ERROR:  relation "test_type2" does not exist
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 DROP ATTRIBUTE b; -- fails
ERROR:  relation "test_type2" does not exist
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE;
ERROR:  relation "test_type2" does not exist
\d test_type2
\d test_tbl2
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa; -- fails
ERROR:  relation "test_type2" does not exist
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE;
ERROR:  relation "test_type2" does not exist
\d test_type2
\d test_tbl2
\d test_tbl2_subclass
DROP TABLE test_tbl2_subclass;
ERROR:  table "test_tbl2_subclass" does not exist
-- This test isn't that interesting on its own, but the purpose is to leave
-- behind a table to test pg_upgrade with. The table has a composite type
-- column in it, and the composite type has a dropped attribute.
CREATE TYPE test_type3 AS (a int);
ERROR:  user defined type is not yet supported.
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
ERROR:  type "test_type3" does not exist
LINE 1: CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3;
                                                    ^
CONTEXT:  referenced column: test_type3
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int;
ERROR:  relation "test_type3" does not exist
CREATE TYPE test_type_empty AS ();
ERROR:  user defined type is not yet supported.
--
-- typed tables: OF / NOT OF
--
CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2));
ERROR:  user defined type is not yet supported.
ALTER TYPE tt_t0 DROP ATTRIBUTE z;
ERROR:  relation "tt_t0" does not exist
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2));	-- OK
CREATE TABLE tt1 (x int, y bigint);					-- wrong base type
CREATE TABLE tt2 (x int, y numeric(9,2));			-- wrong typmod
CREATE TABLE tt3 (y numeric(8,2), x int);			-- wrong column order
CREATE TABLE tt4 (x int);							-- too few columns
CREATE TABLE tt5 (x int, y numeric(8,2), z int);	-- too few columns
CREATE TABLE tt6 () INHERITS (tt0);					-- can't have a parent
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
CREATE TABLE tt7 (x int, q text, y numeric(8,2)) WITH OIDS;
ERROR:  CREATE TABLE ... WITH OIDS is not yet supported.
ALTER TABLE tt7 DROP q;								-- OK
ERROR:  relation "tt7" does not exist
ALTER TABLE tt0 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt1 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt2 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt3 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt4 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt5 OF tt_t0;
ERROR:  type "tt_t0" does not exist
ALTER TABLE tt6 OF tt_t0;
ERROR:  relation "tt6" does not exist
ALTER TABLE tt7 OF tt_t0;
ERROR:  relation "tt7" does not exist
CREATE TYPE tt_t1 AS (x int, y numeric(8,2));
ERROR:  user defined type is not yet supported.
ALTER TABLE tt7 OF tt_t1;			-- reassign an already-typed table
ERROR:  relation "tt7" does not exist
ALTER TABLE tt7 NOT OF;
ERROR:  relation "tt7" does not exist
\d tt7
-- make sure we can drop a constraint on the parent but it remains on the child
CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL));
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check";
-- should fail
INSERT INTO test_drop_constr_child (c) VALUES (NULL);
ERROR:  relation "test_drop_constr_child" does not exist
LINE 1: INSERT INTO test_drop_constr_child (c) VALUES (NULL);
                    ^
DROP TABLE test_drop_constr_parent CASCADE;
--
-- IF EXISTS test
--
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
NOTICE:  relation "tt8" does not exist, skipping
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
NOTICE:  relation "tt8" does not exist, skipping
CREATE TABLE tt8(a int);
CREATE SCHEMA alter2;
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int;
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f);
ERROR:  Cannot create index whose evaluation cannot be enforced to remote nodes
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10);
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0;
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1;
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2;
\d alter2.tt8
      Table "alter2.tt8"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | 
 f1     | integer | default 0
Check constraints:
    "tt8_f_check" CHECK (f1 >= 0 AND f1 <= 10)

DROP TABLE alter2.tt8;
DROP SCHEMA alter2;
--custom script
--create table
CREATE TABLE TBL_DOMAIN
(
  IDOMAINID   NUMBER(10) NOT NULL,
  SDOMAINNAME VARCHAR2(30) NOT NULL
);
--create/recreate primary, unique and foreign key constraints 
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT PK_TBL_DOMAIN PRIMARY KEY (IDOMAINID)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "pk_tbl_domain" for table "tbl_domain"
  
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT IX_TBL_DOMAIN UNIQUE (SDOMAINNAME)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "ix_tbl_domain" for table "tbl_domain"
\d+ TBL_DOMAIN
                                Table "public.tbl_domain"
   Column    |         Type          | Modifiers | Storage  | Stats target | Description 
-------------+-----------------------+-----------+----------+--------------+-------------
 idomainid   | numeric(10,0)         | not null  | main     |              | 
 sdomainname | character varying(30) | not null  | extended |              | 
Indexes:
    "pk_tbl_domain" PRIMARY KEY, btree (idomainid) TABLESPACE pg_default
    "ix_tbl_domain" UNIQUE CONSTRAINT, btree (sdomainname) TABLESPACE pg_default
Has OIDs: no
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no

DROP TABLE TBL_DOMAIN;
--create table
CREATE TABLE TBL_CM_MAXTSENDTOHOST
(
  I_MODULETYPE  NUMBER(38) NOT NULL,
  I_MODULENO    NUMBER(38) NOT NULL,
  I_PLAMODULENO NUMBER(38) NOT NULL,
  I_TABLEID     NUMBER(38) NOT NULL,
  I_OLDMAXTUPLE NUMBER(38) NOT NULL,
  I_NEWMAXTUPLE NUMBER(38) NOT NULL,
  I_RESERVED1   NUMBER(38) DEFAULT 0,
  I_RESERVED2   NUMBER(38) DEFAULT 0,
  I_RESERVED3   NUMBER(38) DEFAULT 0,
  I_RESERVED4   NUMBER(38) DEFAULT 0,
  I_RESERVED5   NUMBER(38) DEFAULT 0,
  I_RESERVED6   NUMBER(38) DEFAULT 0,
  I_RESERVED7   NUMBER(38) DEFAULT 0,
  SV_RESERVED8  VARCHAR2(32) DEFAULT '',
  SV_RESERVED9  VARCHAR2(32) DEFAULT '',
  SV_RESERVED10 VARCHAR2(32) DEFAULT ''
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )
 ;
--add primary key
ALTER TABLE TBL_CM_MAXTSENDTOHOST
  ADD PRIMARY KEY (I_PLAMODULENO, I_TABLEID)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_cm_maxtsendtohost_pkey" for table "tbl_cm_maxtsendtohost"
 \d+ TBL_CM_MAXTSENDTOHOST
                                      Table "public.tbl_cm_maxtsendtohost"
    Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
---------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_moduletype  | numeric(38,0)         | not null                        | main     |              | 
 i_moduleno    | numeric(38,0)         | not null                        | main     |              | 
 i_plamoduleno | numeric(38,0)         | not null                        | main     |              | 
 i_tableid     | numeric(38,0)         | not null                        | main     |              | 
 i_oldmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_newmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7   | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10 | character varying(32) | default NULL::character varying | extended |              | 
Indexes:
    "tbl_cm_maxtsendtohost_pkey" PRIMARY KEY, btree (i_plamoduleno, i_tableid) TABLESPACE pg_default
Has OIDs: no
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no

 DROP TABLE TBL_CM_MAXTSENDTOHOST;
--create table
CREATE TABLE TBL_LICCTRLDESC_DEFAULT
(
  I_INDEX        NUMBER(38) NOT NULL,
  SV_FEATURENAME VARCHAR2(64) NOT NULL,
  SV_ITEMNAME    VARCHAR2(64) NOT NULL,
  I_ITEMTYPE     NUMBER(38) NOT NULL,
  I_ITEMVALUEMIN NUMBER(38) NOT NULL,
  I_ITEMVALUEMAX NUMBER(38) NOT NULL,
  I_RESERVED1    NUMBER(38) DEFAULT 0,
  I_RESERVED2    NUMBER(38) DEFAULT 0,
  I_RESERVED3    NUMBER(38) DEFAULT 0,
  I_RESERVED4    NUMBER(38) DEFAULT 0,
  I_RESERVED5    NUMBER(38) DEFAULT 0,
  I_RESERVED6    NUMBER(38) DEFAULT 0,
  I_RESERVED7    NUMBER(38) DEFAULT 0,
  SV_RESERVED8   VARCHAR2(32) DEFAULT '',
  SV_RESERVED9   VARCHAR2(32) DEFAULT '',
  SV_RESERVED10  VARCHAR2(32) DEFAULT '',
  I_STATUS       NUMBER(38) NOT NULL
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  )
 ;
--add primary key
ALTER TABLE TBL_LICCTRLDESC_DEFAULT
  ADD PRIMARY KEY (I_INDEX)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_licctrldesc_default_pkey" for table "tbl_licctrldesc_default"
--add unique index
CREATE UNIQUE INDEX IDX_TBL_LICCTRL_DEF ON TBL_LICCTRLDESC_DEFAULT (I_INDEX DESC, I_STATUS)
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
\d+ TBL_LICCTRLDESC_DEFAULT
                                      Table "public.tbl_licctrldesc_default"
     Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
----------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_index        | numeric(38,0)         | not null                        | main     |              | 
 sv_featurename | character varying(64) | not null                        | extended |              | 
 sv_itemname    | character varying(64) | not null                        | extended |              | 
 i_itemtype     | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemin | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemax | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7    | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10  | character varying(32) | default NULL::character varying | extended |              | 
 i_status       | numeric(38,0)         | not null                        | main     |              | 
Indexes:
    "tbl_licctrldesc_default_pkey" PRIMARY KEY, btree (i_index) TABLESPACE pg_default
    "idx_tbl_licctrl_def" UNIQUE, btree (i_index DESC, i_status) TABLESPACE pg_default
Has OIDs: no
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no

 DROP TABLE TBL_LICCTRLDESC_DEFAULT;
--using index clause
CREATE TABLE STUDENTS
(
	ID INT,
	NAME VARCHAR2(20),
	AGE INT,
	ADDRESS VARCHAR(30)
);
 --alter table to add unique index or primary key 
ALTER TABLE STUDENTS ADD UNIQUE (ID)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "students_id_key" for table "students"
ALTER TABLE STUDENTS ADD CONSTRAINT ZHANGYG UNIQUE (AGE, ADDRESS)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "zhangyg" for table "students"
ALTER TABLE STUDENTS ADD PRIMARY KEY (AGE)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "students_pkey" for table "students"
\d+ STUDENTS
                               Table "public.students"
 Column  |         Type          | Modifiers | Storage  | Stats target | Description 
---------+-----------------------+-----------+----------+--------------+-------------
 id      | integer               |           | plain    |              | 
 name    | character varying(20) |           | extended |              | 
 age     | integer               | not null  | plain    |              | 
 address | character varying(30) |           | extended |              | 
Indexes:
    "students_pkey" PRIMARY KEY, btree (age) TABLESPACE pg_default
    "students_id_key" UNIQUE CONSTRAINT, btree (id) TABLESPACE pg_default
    "zhangyg" UNIQUE CONSTRAINT, btree (age, address) TABLESPACE pg_default
Has OIDs: no
Location Nodes: ALL DATANODES
Options: orientation=row, compression=no

DROP TABLE STUDENTS;
--simulate A db's ALTER TABLE gram
CREATE TABLE MODIFY_TABLE_A(I INTEGER);
ALTER TABLE MODIFY_TABLE_A ADD (mychar CHAR); 
ALTER TABLE MODIFY_TABLE_A ADD (myint1 INT, mychar1 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD (myint2 INT, mychar2 CHAR, mychar3 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD a CHAR, ADD b CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 

ALTER TABLE MODIFY_TABLE_A ADD mychar4 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY I VARCHAR2(64);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character varying(64) | 
 mychar  | character(1)          | 
 myint1  | integer               | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY I CHAR, MODIFY myint1 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | character(1) | 
 mychar  | character(1) | 
 myint1  | character(1) | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(12));
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(12) | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(13), mychar1 INT);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(13) | 
 mychar1 | integer               | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(13), myint1 INT);
ERROR:  cannot alter type of column "myint1" twice
DROP TABLE MODIFY_TABLE_A;
create table test_alter_type(a int,b text);
alter table test_alter_type alter column a type regclass;
ERROR:  cannot alter data type of distribute column
DROP TABLE test_alter_type;
create table test_mod(a int,b text) distribute by modulo(a);
alter table test_mod alter column a type regclass;
ERROR:  cannot alter data type of distribute column
alter table test_mod alter column a set default "d";
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int + 1;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
drop table test_mod;
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name ADD( { element_list_clause } [, ...] )
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name MODIFY( { element_list_clause } [, ...] )
create schema  columnar_storage;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 modify (c_int varchar(20));
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 modify (c_int varchar(20), c_double  varchar(20));
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid | c_time_008 | c_timetz_008 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------+------------+--------------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
drop schema columnar_storage;
create table test_drop_column_1 (a int, b int, c int);
create table test_drop_column_2 (a int, b int);
create table test_drop_column_3 (a int, b int);
alter table test_drop_column_1 drop column c;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2;
WARNING:  Statistics in some tables or columns(public.test_drop_column_2.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Insert on public.test_drop_column_1
         ->  Streaming(type: REDISTRIBUTE)
               Output: test_drop_column_2.a, test_drop_column_2.b, (NULL::integer)
               Distribute Key: test_drop_column_2.b
               Spawn on: All datanodes
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.b, NULL::integer
(9 rows)

insert into test_drop_column_1 select * from test_drop_column_2;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
WARNING:  Statistics in some tables or columns(public.test_drop_column_2.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Insert on public.test_drop_column_1
         ->  Streaming(type: REDISTRIBUTE)
               Output: "*SELECT*".a, "*SELECT*".b, (NULL::integer)
               Distribute Key: "*SELECT*".b
               Spawn on: All datanodes
               ->  Subquery Scan on "*SELECT*"
                     Output: "*SELECT*".a, "*SELECT*".b, NULL::integer
                     ->  Sort
                           Output: test_drop_column_2.a, test_drop_column_2.b
                           Sort Key: test_drop_column_2.b
                           ->  Seq Scan on public.test_drop_column_2
                                 Output: test_drop_column_2.a, test_drop_column_2.b
(14 rows)

insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
WARNING:  Statistics in some tables or columns(public.test_drop_column_2.a, public.test_drop_column_3.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Insert on public.test_drop_column_1
         ->  Hash Join
               Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
               Hash Cond: (test_drop_column_2.a = test_drop_column_3.a)
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.b
               ->  Hash
                     Output: test_drop_column_3.a
                     ->  Seq Scan on public.test_drop_column_3
                           Output: test_drop_column_3.a
(12 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
WARNING:  Statistics in some tables or columns(public.test_drop_column_2.a, public.test_drop_column_3.a, public.test_drop_column_3.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Insert on public.test_drop_column_1
         ->  Streaming(type: REDISTRIBUTE)
               Output: test_drop_column_2.a, test_drop_column_3.a, (NULL::integer)
               Distribute Key: test_drop_column_3.a
               Spawn on: All datanodes
               ->  Hash Join
                     Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
                     Hash Cond: (test_drop_column_3.b = test_drop_column_2.a)
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: test_drop_column_3.a, test_drop_column_3.b
                           Distribute Key: test_drop_column_3.b
                           Spawn on: All datanodes
                           ->  Seq Scan on public.test_drop_column_3
                                 Output: test_drop_column_3.a, test_drop_column_3.b
                     ->  Hash
                           Output: test_drop_column_2.a
                           ->  Seq Scan on public.test_drop_column_2
                                 Output: test_drop_column_2.a
(20 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
WARNING:  Statistics in some tables or columns(public.test_drop_column_2.a, public.test_drop_column_3.a, public.test_drop_column_3.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Insert on public.test_drop_column_1
         ->  Streaming(type: REDISTRIBUTE)
               Output: "*SELECT*".a, "*SELECT*".a, (NULL::integer)
               Distribute Key: "*SELECT*".a
               Spawn on: All datanodes
               ->  Subquery Scan on "*SELECT*"
                     Output: "*SELECT*".a, "*SELECT*".a, NULL::integer
                     ->  Sort
                           Output: test_drop_column_2.a, test_drop_column_3.a
                           Sort Key: test_drop_column_2.a, test_drop_column_3.a
                           ->  Hash Join
                                 Output: test_drop_column_2.a, test_drop_column_3.a
                                 Hash Cond: (test_drop_column_3.b = test_drop_column_2.a)
                                 ->  Streaming(type: REDISTRIBUTE)
                                       Output: test_drop_column_3.a, test_drop_column_3.b
                                       Distribute Key: test_drop_column_3.b
                                       Spawn on: All datanodes
                                       ->  Seq Scan on public.test_drop_column_3
                                             Output: test_drop_column_3.a, test_drop_column_3.b
                                 ->  Hash
                                       Output: test_drop_column_2.a
                                       ->  Seq Scan on public.test_drop_column_2
                                             Output: test_drop_column_2.a
(25 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
explain (verbose true, costs false) update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
WARNING:  Statistics in some tables or columns(public.test_drop_column_1.b, public.test_drop_column_2.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Update on public.test_drop_column_1
         ->  Nested Loop
               Output: test_drop_column_2.a, test_drop_column_1.b, NULL::integer, test_drop_column_1.ctid, test_drop_column_1.xc_node_id, test_drop_column_2.ctid
               ->  Streaming(type: BROADCAST)
                     Output: test_drop_column_2.a, test_drop_column_2.ctid
                     Spawn on: All datanodes
                     ->  Seq Scan on public.test_drop_column_2
                           Output: test_drop_column_2.a, test_drop_column_2.ctid
               ->  Materialize
                     Output: test_drop_column_1.b, test_drop_column_1.ctid, test_drop_column_1.xc_node_id
                     ->  Seq Scan on public.test_drop_column_1
                           Output: test_drop_column_1.b, test_drop_column_1.ctid, test_drop_column_1.xc_node_id
(14 rows)

update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
explain (verbose true, costs false) delete from test_drop_column_1 where a in (select a from test_drop_column_2);
WARNING:  Statistics in some tables or columns(public.test_drop_column_1.b, public.test_drop_column_1.a, public.test_drop_column_2.a) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Delete on public.test_drop_column_1
         ->  Streaming(type: REDISTRIBUTE)
               Output: test_drop_column_1.a, test_drop_column_1.ctid, test_drop_column_1.xc_node_id, test_drop_column_1.b, test_drop_column_2.ctid
               Distribute Key: test_drop_column_1.b
               Spawn on: All datanodes
               ->  Hash Semi Join
                     Output: test_drop_column_1.a, test_drop_column_1.ctid, test_drop_column_1.xc_node_id, test_drop_column_1.b, test_drop_column_2.ctid
                     Hash Cond: (test_drop_column_1.a = test_drop_column_2.a)
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: test_drop_column_1.a, test_drop_column_1.ctid, test_drop_column_1.xc_node_id, test_drop_column_1.b
                           Distribute Key: test_drop_column_1.a
                           Spawn on: All datanodes
                           ->  Seq Scan on public.test_drop_column_1
                                 Output: test_drop_column_1.a, test_drop_column_1.ctid, test_drop_column_1.xc_node_id, test_drop_column_1.b
                     ->  Hash
                           Output: test_drop_column_2.ctid, test_drop_column_2.a
                           ->  Seq Scan on public.test_drop_column_2
                                 Output: test_drop_column_2.ctid, test_drop_column_2.a
(20 rows)

delete from test_drop_column_1 where a in (select a from test_drop_column_2);
create table test_drop_column_cstore_1 (a int, b int, c int) with (orientation = column);
create table test_drop_column_cstore_2 (a int, b int) with (orientation = column);
create table test_drop_column_cstore_3 (a int) with (orientation = column);
alter table test_drop_column_cstore_1 drop column c;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2 order by 2;
insert into test_drop_column_cstore_1 select test_drop_column_cstore_2.a, test_drop_column_cstore_3.a from test_drop_column_cstore_2, test_drop_column_cstore_3 where test_drop_column_cstore_2.a = test_drop_column_cstore_3.a;
drop table test_drop_column_1;
drop table test_drop_column_2;
drop table test_drop_column_3;
drop table test_drop_column_cstore_1;
drop table test_drop_column_cstore_2;
drop table test_drop_column_cstore_3;
create table test_hash (a int, b int);
create sequence test_seq1;
alter table test_hash alter column a type serial; --fail 
ERROR:  cannot alter column type to "serial"
alter table test_hash alter column a set default nextval('test_seq1'); 
insert into test_hash(b) values(generate_series(1,10));
alter table test_hash add column c serial; --not supported
ERROR:  It's not supported to alter table add serial column
alter table test_hash add column d int default nextval('test_seq1'); --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
alter table test_hash add column e int default nextval('test_seq1')*10; --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
drop table test_hash;
drop sequence test_seq1;
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text);
insert into at_base_table values (23, 'skidoo');
create view at_view_1 as select * from at_base_table bt;
create view at_view_2 as select *, v1 as j from at_view_1 v1;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
View definition:
 SELECT bt.id, bt.stuff
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT v1.id, v1.stuff, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
WARNING:  Statistics in some tables or columns(public.at_base_table.id) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan on at_base_table "_REMOTE_TABLE_QUERY_"
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff)
   Node/s: All datanodes
   Remote query: SELECT id, stuff FROM ONLY public.at_base_table bt WHERE true
(4 rows)

select * from at_view_2;
 id | stuff  |      j      
----+--------+-------------
 23 | skidoo | (23,skidoo)
(1 row)

create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 more   | integer |           | plain    | 
View definition:
 SELECT bt.id, bt.stuff, 2 + 2 AS more
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT v1.id, v1.stuff, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
WARNING:  Statistics in some tables or columns(public.at_base_table.id) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Data Node Scan on at_base_table "_REMOTE_TABLE_QUERY_"
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff, NULL)
   Node/s: All datanodes
   Remote query: SELECT id, stuff FROM ONLY public.at_base_table bt WHERE true
(4 rows)

select * from at_view_2;
 id | stuff  |      j       
----+--------+--------------
 23 | skidoo | (23,skidoo,)
(1 row)

drop view at_view_2;
drop view at_view_1;
drop table at_base_table;
create table tt_row_rep_1(a int);
alter table tt_row_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_row_rep_2(a int, b int);
alter table tt_row_rep_2 drop column b;
alter table tt_row_rep_2 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_1(a int) with(orientation=column);
alter table tt_col_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_2(a int, b int) with(orientation=column);
alter table tt_col_rep_2 drop column b;
alter table tt_col_rep_2 drop column a;
ERROR:  must have at least one column
drop table tt_row_rep_1;
drop table tt_row_rep_2;
drop table tt_col_rep_1;
drop table tt_col_rep_2;
-- renaming constraints with cache reset of target relation
CREATE TABLE constraint_rename_cache (a int,
  CONSTRAINT chk_a CHECK (a > 0),
  PRIMARY KEY (a));
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "constraint_rename_cache_pkey" for table "constraint_rename_cache"
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT chk_a TO chk_a_new;
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new;
CREATE TABLE like_constraint_rename_cache
  (LIKE constraint_rename_cache INCLUDING ALL);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "like_constraint_rename_cache_pkey" for table "like_constraint_rename_cache"
\d like_constraint_rename_cache
Table "public.like_constraint_rename_cache"
 Column |  Type   | Modifiers 
--------+---------+-----------
 a      | integer | not null
Indexes:
    "like_constraint_rename_cache_pkey" PRIMARY KEY, btree (a) TABLESPACE pg_default
Check constraints:
    "chk_a_new" CHECK (a > 0)

DROP TABLE constraint_rename_cache;
DROP TABLE like_constraint_rename_cache;
