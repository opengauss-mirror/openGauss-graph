create schema full_join_on_true_row_1;
set current_schema='full_join_on_true_row_1';
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
drop table if exists t2;
NOTICE:  table "t2" does not exist, skipping
drop table if exists t3;
NOTICE:  table "t3" does not exist, skipping
drop table if exists t4;
NOTICE:  table "t4" does not exist, skipping
create table t1(a1 int , b1 int, c1 int, samename int);
create table t2(a2 int , b2 int, c2 int, samename int);
create table t3(a3 int , b3 int, c3 int, samename int);
create table t4(a4 int , b4 int, c4 int, samename int);
--------------------------------
-- When the condition is 1=1, GaussDB can noly create Nestloop plan
--------------------------------
-- Both sides are empty
select *from t1 full join t2 on 1=1;
 a1 | b1 | c1 | samename | a2 | b2 | c2 | samename 
----+----+----+----------+----+----+----+----------
(0 rows)

select *from t1 full join t2 on 1=1 full join t3 on 1=1;
 a1 | b1 | c1 | samename | a2 | b2 | c2 | samename | a3 | b3 | c3 | samename 
----+----+----+----------+----+----+----+----------+----+----+----+----------
(0 rows)

select *from t1 full join t2 on 1=1 full join t3 on 1=1 full join t4 on 1=1;
 a1 | b1 | c1 | samename | a2 | b2 | c2 | samename | a3 | b3 | c3 | samename | a4 | b4 | c4 | samename 
----+----+----+----------+----+----+----+----------+----+----+----+----------+----+----+----+----------
(0 rows)

explain (costs off) select *from t1 full join t2 on 1=1;
                        QUERY PLAN                        
----------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Result
         ->  Append
               ->  Nested Loop Left Join
                     ->  Seq Scan on t1
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Seq Scan on t2
               ->  Nested Loop Left Anti Full Join
                     ->  Seq Scan on t2
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Seq Scan on t1
(16 rows)

explain (costs off) select *from t1 full join t2 on 1=1 full join t3 on 1=1;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Result
         ->  Append
               ->  Nested Loop Left Join
                     ->  Result
                           ->  Append
                                 ->  Nested Loop Left Join
                                       ->  Seq Scan on t1
                                       ->  Materialize
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on t2
                                 ->  Nested Loop Left Anti Full Join
                                       ->  Seq Scan on t2
                                       ->  Materialize
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on t1
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Seq Scan on t3
               ->  Nested Loop Left Anti Full Join
                     ->  Seq Scan on t3
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Result
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   ->  Seq Scan on t1
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t2
                                             ->  Nested Loop Left Anti Full Join
                                                   ->  Seq Scan on t2
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t1
(42 rows)

explain (costs off) select *from t1 full join t2 on 1=1 full join t3 on 1=1 full join t4 on 1=1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Result
         ->  Append
               ->  Nested Loop Left Join
                     ->  Result
                           ->  Append
                                 ->  Nested Loop Left Join
                                       ->  Result
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         ->  Seq Scan on t1
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t2
                                                   ->  Nested Loop Left Anti Full Join
                                                         ->  Seq Scan on t2
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t1
                                       ->  Materialize
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on t3
                                 ->  Nested Loop Left Anti Full Join
                                       ->  Seq Scan on t3
                                       ->  Materialize
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Result
                                                         ->  Append
                                                               ->  Nested Loop Left Join
                                                                     ->  Seq Scan on t1
                                                                     ->  Materialize
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Spawn on: All datanodes
                                                                                 ->  Seq Scan on t2
                                                               ->  Nested Loop Left Anti Full Join
                                                                     ->  Seq Scan on t2
                                                                     ->  Materialize
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Spawn on: All datanodes
                                                                                 ->  Seq Scan on t1
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Seq Scan on t4
               ->  Nested Loop Left Anti Full Join
                     ->  Seq Scan on t4
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Result
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   ->  Result
                                                         ->  Append
                                                               ->  Nested Loop Left Join
                                                                     ->  Seq Scan on t1
                                                                     ->  Materialize
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Spawn on: All datanodes
                                                                                 ->  Seq Scan on t2
                                                               ->  Nested Loop Left Anti Full Join
                                                                     ->  Seq Scan on t2
                                                                     ->  Materialize
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Spawn on: All datanodes
                                                                                 ->  Seq Scan on t1
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t3
                                             ->  Nested Loop Left Anti Full Join
                                                   ->  Seq Scan on t3
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Result
                                                                     ->  Append
                                                                           ->  Nested Loop Left Join
                                                                                 ->  Seq Scan on t1
                                                                                 ->  Materialize
                                                                                       ->  Streaming(type: BROADCAST)
                                                                                             Spawn on: All datanodes
                                                                                             ->  Seq Scan on t2
                                                                           ->  Nested Loop Left Anti Full Join
                                                                                 ->  Seq Scan on t2
                                                                                 ->  Materialize
                                                                                       ->  Streaming(type: BROADCAST)
                                                                                             Spawn on: All datanodes
                                                                                             ->  Seq Scan on t1
(94 rows)

explain (verbose,costs off) select *from t1 full join t2 on 1=1;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                           QUERY PLAN                                                                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
   Node/s: All datanodes
   ->  Result
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
         ->  Append
               ->  Nested Loop Left Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                           Distribute Key: full_join_on_true_row_1.t1.a1
                     ->  Materialize
                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
               ->  Nested Loop Left Anti Full Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                     ->  Seq Scan on full_join_on_true_row_1.t2
                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                           Distribute Key: full_join_on_true_row_1.t2.a2
                     ->  Materialize
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                       Distribute Key: full_join_on_true_row_1.t1.a1
(34 rows)

explain (verbose,costs off) select *from t1 full join t2 on 1=1 full join t3 on 1=1;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                                                                            QUERY PLAN                                                                                                                                                                                                            
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
   Node/s: All datanodes
   ->  Result
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
         ->  Append
               ->  Nested Loop Left Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Result
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Seq Scan on full_join_on_true_row_1.t1
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                             Distribute Key: full_join_on_true_row_1.t1.a1
                                       ->  Materialize
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t2
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Nested Loop Left Anti Full Join
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Seq Scan on full_join_on_true_row_1.t2
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Distribute Key: full_join_on_true_row_1.t2.a2
                                       ->  Materialize
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t1
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                         Distribute Key: full_join_on_true_row_1.t1.a1
                     ->  Materialize
                           Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
               ->  Nested Loop Left Anti Full Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Seq Scan on full_join_on_true_row_1.t3
                           Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                           Distribute Key: full_join_on_true_row_1.t3.a3
                     ->  Materialize
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Result
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t1
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                         Distribute Key: full_join_on_true_row_1.t1.a1
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t2
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Distribute Key: full_join_on_true_row_1.t2.a2
                                             ->  Nested Loop Left Anti Full Join
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t2
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         Distribute Key: full_join_on_true_row_1.t2.a2
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t1
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                     Distribute Key: full_join_on_true_row_1.t1.a1
(90 rows)

explain (verbose,costs off) select *from t1 full join t2 on 1=1 full join t3 on 1=1 full join t4 on 1=1;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename, full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
   Node/s: All datanodes
   ->  Result
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename, full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
         ->  Append
               ->  Nested Loop Left Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename, full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                     ->  Result
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                           ->  Append
                                 ->  Nested Loop Left Join
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Result
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t1
                                                               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                               Distribute Key: full_join_on_true_row_1.t1.a1
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t2
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           Distribute Key: full_join_on_true_row_1.t2.a2
                                                   ->  Nested Loop Left Anti Full Join
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t2
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Distribute Key: full_join_on_true_row_1.t2.a2
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t1
                                                                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                           Distribute Key: full_join_on_true_row_1.t1.a1
                                       ->  Materialize
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t3
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Nested Loop Left Anti Full Join
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Seq Scan on full_join_on_true_row_1.t3
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Distribute Key: full_join_on_true_row_1.t3.a3
                                       ->  Materialize
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Result
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Append
                                                               ->  Nested Loop Left Join
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     ->  Seq Scan on full_join_on_true_row_1.t1
                                                                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                           Distribute Key: full_join_on_true_row_1.t1.a1
                                                                     ->  Materialize
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                 Spawn on: All datanodes
                                                                                 Consumer Nodes: All datanodes
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                                                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                                               ->  Nested Loop Left Anti Full Join
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     ->  Seq Scan on full_join_on_true_row_1.t2
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           Distribute Key: full_join_on_true_row_1.t2.a2
                                                                     ->  Materialize
                                                                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                 Spawn on: All datanodes
                                                                                 Consumer Nodes: All datanodes
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                                                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t1.a1
                     ->  Materialize
                           Output: full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t4
                                       Output: full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                                       Distribute Key: full_join_on_true_row_1.t4.a4
               ->  Nested Loop Left Anti Full Join
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename, full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                     ->  Seq Scan on full_join_on_true_row_1.t4
                           Output: full_join_on_true_row_1.t4.a4, full_join_on_true_row_1.t4.b4, full_join_on_true_row_1.t4.c4, full_join_on_true_row_1.t4.samename
                           Distribute Key: full_join_on_true_row_1.t4.a4
                     ->  Materialize
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                           ->  Streaming(type: BROADCAST)
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Result
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Result
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Append
                                                               ->  Nested Loop Left Join
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     ->  Seq Scan on full_join_on_true_row_1.t1
                                                                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                           Distribute Key: full_join_on_true_row_1.t1.a1
                                                                     ->  Materialize
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                 Spawn on: All datanodes
                                                                                 Consumer Nodes: All datanodes
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                                                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                                               ->  Nested Loop Left Anti Full Join
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     ->  Seq Scan on full_join_on_true_row_1.t2
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           Distribute Key: full_join_on_true_row_1.t2.a2
                                                                     ->  Materialize
                                                                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                           ->  Streaming(type: BROADCAST)
                                                                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                 Spawn on: All datanodes
                                                                                 Consumer Nodes: All datanodes
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                                                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t1.a1
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t3
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Distribute Key: full_join_on_true_row_1.t3.a3
                                             ->  Nested Loop Left Anti Full Join
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t3
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Result
                                                                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     ->  Append
                                                                           ->  Nested Loop Left Join
                                                                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                                                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t1.a1
                                                                                 ->  Materialize
                                                                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                       ->  Streaming(type: BROADCAST)
                                                                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                             Spawn on: All datanodes
                                                                                             Consumer Nodes: All datanodes
                                                                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                                   Distribute Key: full_join_on_true_row_1.t2.a2
                                                                           ->  Nested Loop Left Anti Full Join
                                                                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                                                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                                                                 ->  Materialize
                                                                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                       ->  Streaming(type: BROADCAST)
                                                                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                             Spawn on: All datanodes
                                                                                             Consumer Nodes: All datanodes
                                                                                             ->  Seq Scan on full_join_on_true_row_1.t1
                                                                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                                                                   Distribute Key: full_join_on_true_row_1.t1.a1
(202 rows)

-- One side is empty
insert into t1 values(1,1,1,1);
insert into t1 values(11,11,11,11);
insert into t1 values(11,11,11,11);
insert into t1 values(111,111,111,111);
insert into t1 values(111,111,111,111);
insert into t1 values(111,111,111,111);
insert into t1 values(NULL,1111,1111,1111);
select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 order by 1,2,3,4,5,6;
 a1  |  b1  |  c1  | a2 | b2 | c2 
-----+------+------+----+----+----
   1 |    1 |    1 |    |    |   
  11 |   11 |   11 |    |    |   
  11 |   11 |   11 |    |    |   
 111 |  111 |  111 |    |    |   
 111 |  111 |  111 |    |    |   
 111 |  111 |  111 |    |    |   
     | 1111 | 1111 |    |    |   
(7 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1 full join t2 on 1=1 full join t3 on 1=1 order by 1,2,3,4,5,6,7,8,9;
 a1  |  b1  |  c1  | a2 | b2 | c2 | a3 | b3 | c3 
-----+------+------+----+----+----+----+----+----
   1 |    1 |    1 |    |    |    |    |    |   
  11 |   11 |   11 |    |    |    |    |    |   
  11 |   11 |   11 |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |   
     | 1111 | 1111 |    |    |    |    |    |   
(7 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3,a4,b4,c4 from t1 full join t2 on 1=1 full join t3 on 1=1 full join t4 on 1=1 order by 1,2,3,4,5,6,7,8,9,10,11,12;
 a1  |  b1  |  c1  | a2 | b2 | c2 | a3 | b3 | c3 | a4 | b4 | c4 
-----+------+------+----+----+----+----+----+----+----+----+----
   1 |    1 |    1 |    |    |    |    |    |    |    |    |   
  11 |   11 |   11 |    |    |    |    |    |    |    |    |   
  11 |   11 |   11 |    |    |    |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |    |    |    |   
 111 |  111 |  111 |    |    |    |    |    |    |    |    |   
     | 1111 | 1111 |    |    |    |    |    |    |    |    |   
(7 rows)

-- Neither side is empty
insert into t2 values(2,2,2,2);
insert into t2 values(22,22,22,22);
insert into t2 values(22,22,22,22);
insert into t2 values(NULL,222,222,222);
select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 order by 1,2,3,4,5,6;
 a1  |  b1  |  c1  | a2 | b2  | c2  
-----+------+------+----+-----+-----
   1 |    1 |    1 |  2 |   2 |   2
   1 |    1 |    1 | 22 |  22 |  22
   1 |    1 |    1 | 22 |  22 |  22
   1 |    1 |    1 |    | 222 | 222
  11 |   11 |   11 |  2 |   2 |   2
  11 |   11 |   11 |  2 |   2 |   2
  11 |   11 |   11 | 22 |  22 |  22
  11 |   11 |   11 | 22 |  22 |  22
  11 |   11 |   11 | 22 |  22 |  22
  11 |   11 |   11 | 22 |  22 |  22
  11 |   11 |   11 |    | 222 | 222
  11 |   11 |   11 |    | 222 | 222
 111 |  111 |  111 |  2 |   2 |   2
 111 |  111 |  111 |  2 |   2 |   2
 111 |  111 |  111 |  2 |   2 |   2
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 | 22 |  22 |  22
 111 |  111 |  111 |    | 222 | 222
 111 |  111 |  111 |    | 222 | 222
 111 |  111 |  111 |    | 222 | 222
     | 1111 | 1111 |  2 |   2 |   2
     | 1111 | 1111 | 22 |  22 |  22
     | 1111 | 1111 | 22 |  22 |  22
     | 1111 | 1111 |    | 222 | 222
(28 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1 full join t2 on 1=1 full join t3 on 1=1 order by 1,2,3,4,5,6,7,8,9;
 a1  |  b1  |  c1  | a2 | b2  | c2  | a3 | b3 | c3 
-----+------+------+----+-----+-----+----+----+----
   1 |    1 |    1 |  2 |   2 |   2 |    |    |   
   1 |    1 |    1 | 22 |  22 |  22 |    |    |   
   1 |    1 |    1 | 22 |  22 |  22 |    |    |   
   1 |    1 |    1 |    | 222 | 222 |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
     | 1111 | 1111 |  2 |   2 |   2 |    |    |   
     | 1111 | 1111 | 22 |  22 |  22 |    |    |   
     | 1111 | 1111 | 22 |  22 |  22 |    |    |   
     | 1111 | 1111 |    | 222 | 222 |    |    |   
(28 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3,a4,b4,c4 from t1 full join t2 on 1=1 full join t3 on 1=1 full join t4 on 1=1 order by 1,2,3,4,5,6,7,8,9,10,11,12;
 a1  |  b1  |  c1  | a2 | b2  | c2  | a3 | b3 | c3 | a4 | b4 | c4 
-----+------+------+----+-----+-----+----+----+----+----+----+----
   1 |    1 |    1 |  2 |   2 |   2 |    |    |    |    |    |   
   1 |    1 |    1 | 22 |  22 |  22 |    |    |    |    |    |   
   1 |    1 |    1 | 22 |  22 |  22 |    |    |    |    |    |   
   1 |    1 |    1 |    | 222 | 222 |    |    |    |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |    |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |    |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |    |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |    |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |    |    |    |   
  11 |   11 |   11 | 22 |  22 |  22 |    |    |    |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |    |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |    |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |    |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |    |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |    |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |    |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |    |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |    |    |    |   
     | 1111 | 1111 |  2 |   2 |   2 |    |    |    |    |    |   
     | 1111 | 1111 | 22 |  22 |  22 |    |    |    |    |    |   
     | 1111 | 1111 | 22 |  22 |  22 |    |    |    |    |    |   
     | 1111 | 1111 |    | 222 | 222 |    |    |    |    |    |   
(28 rows)

-- Quals on base table
select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 order by 1,2,3,4,5,6;
 a1 | b1 | c1 | a2 | b2  | c2  
----+----+----+----+-----+-----
 11 | 11 | 11 |  2 |   2 |   2
 11 | 11 | 11 |  2 |   2 |   2
 11 | 11 | 11 | 22 |  22 |  22
 11 | 11 | 11 | 22 |  22 |  22
 11 | 11 | 11 | 22 |  22 |  22
 11 | 11 | 11 | 22 |  22 |  22
 11 | 11 | 11 |    | 222 | 222
 11 | 11 | 11 |    | 222 | 222
(8 rows)

select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 or t1.a1 is null order by 1,2,3,4,5,6;
 a1 |  b1  |  c1  | a2 | b2  | c2  
----+------+------+----+-----+-----
 11 |   11 |   11 |  2 |   2 |   2
 11 |   11 |   11 |  2 |   2 |   2
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 |    | 222 | 222
 11 |   11 |   11 |    | 222 | 222
    | 1111 | 1111 |  2 |   2 |   2
    | 1111 | 1111 | 22 |  22 |  22
    | 1111 | 1111 | 22 |  22 |  22
    | 1111 | 1111 |    | 222 | 222
(12 rows)

select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where (t1.a1=11 or t1.a1 is null) and (t2.a2>1 or t2.a2 is null) order by 1,2,3,4,5,6;
 a1 |  b1  |  c1  | a2 | b2  | c2  
----+------+------+----+-----+-----
 11 |   11 |   11 |  2 |   2 |   2
 11 |   11 |   11 |  2 |   2 |   2
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 | 22 |  22 |  22
 11 |   11 |   11 |    | 222 | 222
 11 |   11 |   11 |    | 222 | 222
    | 1111 | 1111 |  2 |   2 |   2
    | 1111 | 1111 | 22 |  22 |  22
    | 1111 | 1111 | 22 |  22 |  22
    | 1111 | 1111 |    | 222 | 222
(12 rows)

explain (costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 order by 1,2,3,4,5,6;
                     QUERY PLAN                      
-----------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Sort
         Sort Key: t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
         ->  Nested Loop Left Join
               ->  Seq Scan on t1
                     Filter: (a1 = 11)
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Seq Scan on t2
(11 rows)

explain (costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 or t1.a1 is null order by 1,2,3,4,5,6;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t1
                                       Filter: ((a1 = 11) OR (a1 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
                           ->  Nested Loop Left Anti Full Join
                                 Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t1
(22 rows)

explain (costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where (t1.a1=11 or t1.a1 is null) and (t2.a2>1 or t2.a2 is null) order by 1,2,3,4,5,6;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on t1
                                       Filter: ((a1 = 11) OR (a1 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
                           ->  Nested Loop Left Anti Full Join
                                 Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Seq Scan on t2
                                       Filter: ((a2 > 1) OR (a2 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t1
(24 rows)

explain (verbose,costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 order by 1,2,3,4,5,6;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                              QUERY PLAN                              
----------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
   Node/s: All datanodes
   ->  Sort
         Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
         Sort Key: t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
         ->  Nested Loop Left Join
               Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
               ->  Seq Scan on full_join_on_true_row_1.t1
                     Output: t1.a1, t1.b1, t1.c1, t1.samename
                     Distribute Key: t1.a1
                     Filter: (t1.a1 = 11)
               ->  Materialize
                     Output: t2.a2, t2.b2, t2.c2
                     ->  Streaming(type: BROADCAST)
                           Output: t2.a2, t2.b2, t2.c2
                           Spawn on: All datanodes
                           Consumer Nodes: datanode7
                           ->  Seq Scan on full_join_on_true_row_1.t2
                                 Output: t2.a2, t2.b2, t2.c2
                                 Distribute Key: t2.a2
(21 rows)

explain (verbose,costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where t1.a1=11 or t1.a1 is null order by 1,2,3,4,5,6;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
               ->  Result
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                       Distribute Key: full_join_on_true_row_1.t1.a1
                                       Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t1
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                   Distribute Key: full_join_on_true_row_1.t1.a1
(42 rows)

explain (verbose,costs off) select a1,b1,c1,a2,b2,c2 from t1 full join t2 on 1=1 where (t1.a1=11 or t1.a1 is null) and (t2.a2>1 or t2.a2 is null) order by 1,2,3,4,5,6;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                 
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         Sort Key: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.c1, subquery.a2, subquery.b2, subquery.c2
               ->  Result
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t1
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                       Distribute Key: full_join_on_true_row_1.t1.a1
                                       Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                 Filter: ((full_join_on_true_row_1.t1.a1 = 11) OR (full_join_on_true_row_1.t1.a1 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                       Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t1
                                                   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                                                   Distribute Key: full_join_on_true_row_1.t1.a1
(44 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(24 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 and t2.a2=22 order by 1,2,3,4,5,6,7,8,9;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Sort
         Sort Key: t1.b1, t1.c1, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         ->  Nested Loop Left Join
               ->  Nested Loop
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: datanode7
                                 ->  Seq Scan on t2
                                       Filter: (a2 = 22)
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Seq Scan on t3
(17 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 and (t2.a2=22 or t2.a2 is null) order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                       Filter: ((a2 = 22) OR (a2 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(26 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(48 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 and t2.a2=22 order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         Sort Key: t1.b1, t1.c1, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         ->  Nested Loop Left Join
               Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
               ->  Nested Loop
                     Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: t1.a1, t1.b1, t1.c1, t1.samename
                           Distribute Key: t1.a1
                           Filter: (t1.a1 = 11)
                     ->  Materialize
                           Output: t2.a2, t2.b2, t2.c2
                           ->  Streaming(type: BROADCAST)
                                 Output: t2.a2, t2.b2, t2.c2
                                 Spawn on: datanode7
                                 Consumer Nodes: datanode7
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: t2.a2, t2.b2, t2.c2
                                       Distribute Key: t2.a2
                                       Filter: (t2.a2 = 22)
               ->  Materialize
                     Output: t3.a3, t3.b3, t3.c3
                     ->  Streaming(type: BROADCAST)
                           Output: t3.a3, t3.b3, t3.c3
                           Spawn on: All datanodes
                           Consumer Nodes: datanode7
                           ->  Seq Scan on full_join_on_true_row_1.t3
                                 Output: t3.a3, t3.b3, t3.c3
                                 Distribute Key: t3.a3
(33 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3  from t1, t2 full join t3 on 1=1 where t1.a1=11 and (t2.a2=22 or t2.a2 is null) order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                       Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(50 rows)

-- Quals on JoinExpr
select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and sub.a2=22 order by 1,2,3,4,5,6,7,8,9;
 a1 | b1 | c1 | a2 | b2 | c2 | a3 | b3 | c3 
----+----+----+----+----+----+----+----+----
 11 | 11 | 11 | 22 | 22 | 22 |    |    |   
 11 | 11 | 11 | 22 | 22 | 22 |    |    |   
 11 | 11 | 11 | 22 | 22 | 22 |    |    |   
 11 | 11 | 11 | 22 | 22 | 22 |    |    |   
(4 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2=22 or sub.a2 is null) order by 1,2,3,4,5,6,7,8,9;
 a1 | b1 | c1 | a2 | b2  | c2  | a3 | b3 | c3 
----+----+----+----+-----+-----+----+----+----
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
(6 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
 a1 | b1 | c1 | a2 | b2  | c2  | a3 | b3 | c3 
----+----+----+----+-----+-----+----+----+----
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
(6 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and ( t1.a1>sub.a2 and sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
 a1 | b1 | c1 | a2 | b2  | c2  | a3 | b3 | c3 
----+----+----+----+-----+-----+----+----+----
 11 | 11 | 11 |    | 222 | 222 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
(2 rows)

select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, t2 full join t3 on 1=1  where t1.a1=11 and (t2.a2>t1.a1 or t2.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
 a1 | b1 | c1 | a2 | b2  | c2  | a3 | b3 | c3 
----+----+----+----+-----+-----+----+----+----
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 | 22 |  22 |  22 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
 11 | 11 | 11 |    | 222 | 222 |    |    |   
(6 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and sub.a2=22 order by 1,2,3,4,5,6,7,8,9;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Sort
         Sort Key: t1.b1, t1.c1, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         ->  Nested Loop Left Join
               ->  Nested Loop
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: datanode7
                                 ->  Seq Scan on t2
                                       Filter: (a2 = 22)
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Seq Scan on t3
(17 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2=22 or sub.a2 is null) order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                       Filter: ((a2 = 22) OR (a2 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(26 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Join Filter: ((full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(25 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and ( t1.a1>sub.a2 and sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Join Filter: (((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) AND (full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1)) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(25 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, t2 full join t3 on 1=1  where t1.a1=11 and (t2.a2>t1.a1 or t2.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                QUERY PLAN                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Join Filter: ((full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Spawn on: datanode7
                     ->  Seq Scan on t1
                           Filter: (a1 = 11)
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
(25 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and sub.a2=22 order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         Sort Key: t1.b1, t1.c1, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
         ->  Nested Loop Left Join
               Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2, t3.a3, t3.b3, t3.c3
               ->  Nested Loop
                     Output: t1.a1, t1.b1, t1.c1, t2.a2, t2.b2, t2.c2
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: t1.a1, t1.b1, t1.c1, t1.samename
                           Distribute Key: t1.a1
                           Filter: (t1.a1 = 11)
                     ->  Materialize
                           Output: t2.a2, t2.b2, t2.c2
                           ->  Streaming(type: BROADCAST)
                                 Output: t2.a2, t2.b2, t2.c2
                                 Spawn on: datanode7
                                 Consumer Nodes: datanode7
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: t2.a2, t2.b2, t2.c2
                                       Distribute Key: t2.a2
                                       Filter: (t2.a2 = 22)
               ->  Materialize
                     Output: t3.a3, t3.b3, t3.c3
                     ->  Streaming(type: BROADCAST)
                           Output: t3.a3, t3.b3, t3.c3
                           Spawn on: All datanodes
                           Consumer Nodes: datanode7
                           ->  Seq Scan on full_join_on_true_row_1.t3
                                 Output: t3.a3, t3.b3, t3.c3
                                 Distribute Key: t3.a3
(33 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2=22 or sub.a2 is null) order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                       Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 Filter: ((full_join_on_true_row_1.t2.a2 = 22) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(50 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and (sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               Join Filter: ((full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(49 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (t2 full join t3 on 1=1) sub where t1.a1=11 and ( t1.a1>sub.a2 and sub.a2>t1.a1 or sub.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               Join Filter: (((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) AND (full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1)) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(49 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, t2 full join t3 on 1=1  where t1.a1=11 and (t2.a2>t1.a1 or t2.a2 is null or t1.a1 is null) order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               Join Filter: ((full_join_on_true_row_1.t2.a2 > full_join_on_true_row_1.t1.a1) OR (full_join_on_true_row_1.t2.a2 IS NULL) OR (full_join_on_true_row_1.t1.a1 IS NULL))
               ->  Streaming(type: BROADCAST)
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     Spawn on: datanode7
                     Consumer Nodes: All datanodes
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Distribute Key: full_join_on_true_row_1.t1.a1
                           Filter: (full_join_on_true_row_1.t1.a1 = 11)
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
(49 rows)

-- Subquery  on 1=1
select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null order by 1,2,3,4,5,6,7,8,9;
 a1  |  b1  |  c1  | a2 | b2  | c2  | a3 | b3 | c3 
-----+------+------+----+-----+-----+----+----+----
   1 |    1 |    1 |    | 222 | 222 |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |   
  11 |   11 |   11 |  2 |   2 |   2 |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |   
  11 |   11 |   11 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 |  2 |   2 |   2 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 | 22 |  22 |  22 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
 111 |  111 |  111 |    | 222 | 222 |    |    |   
     | 1111 | 1111 |    | 222 | 222 |    |    |   
(18 rows)

select a1,b1,c1 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) order by 1,2,3;
 a1  |  b1  |  c1  
-----+------+------
   1 |    1 |    1
  11 |   11 |   11
  11 |   11 |   11
 111 |  111 |  111
 111 |  111 |  111
 111 |  111 |  111
     | 1111 | 1111
(7 rows)

explain  (costs off ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null order by 1,2,3,4,5,6,7,8,9;
                                                                                                                                               QUERY PLAN                                                                                                                                                
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 ->  Seq Scan on t2
                                       Filter: ((a2 > 1) OR (a2 IS NULL))
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t3
                           ->  Nested Loop Left Anti Full Join
                                 Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on t3
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t2
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Seq Scan on t1
(27 rows)

explain  (costs off ) select a1,b1,c1 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) order by 1,2,3;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
         ->  Nested Loop Semi Join
               Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
               ->  Seq Scan on t1
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Subquery Scan on subquery
                                 ->  Result
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   ->  Seq Scan on t2
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t3
                                             ->  Nested Loop Left Anti Full Join
                                                   ->  Seq Scan on t3
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t2
(26 rows)

explain  (costs off, verbose ) select a1,b1,c1,a2,b2,c2,a3,b3,c3 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null order by 1,2,3,4,5,6,7,8,9;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                 QUERY PLAN                                                                                                                                                  
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Merge Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
         ->  Nested Loop
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3
               Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
               ->  Result
                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 ->  Seq Scan on full_join_on_true_row_1.t2
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       Distribute Key: full_join_on_true_row_1.t2.a2
                                       Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t3
                                                   Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Distribute Key: full_join_on_true_row_1.t3.a3
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                 Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Seq Scan on full_join_on_true_row_1.t3
                                       Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       Distribute Key: full_join_on_true_row_1.t3.a3
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t2
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                   Distribute Key: full_join_on_true_row_1.t2.a2
               ->  Materialize
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                     ->  Streaming(type: BROADCAST)
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                           Spawn on: All datanodes
                           Consumer Nodes: All datanodes
                           ->  Seq Scan on full_join_on_true_row_1.t1
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
                                 Distribute Key: full_join_on_true_row_1.t1.a1
(52 rows)

explain  (costs off, verbose ) select a1,b1,c1 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) order by 1,2,3;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
   Merge Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
         Sort Key: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
         ->  Nested Loop Semi Join
               Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1
               Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
               ->  Seq Scan on full_join_on_true_row_1.t1
                     Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                     Distribute Key: full_join_on_true_row_1.t1.a1
               ->  Materialize
                     Output: subquery.a2
                     ->  Streaming(type: BROADCAST)
                           Output: subquery.a2
                           Spawn on: All datanodes
                           Consumer Nodes: All datanodes
                           ->  Subquery Scan on subquery
                                 Output: subquery.a2
                                 ->  Result
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t2
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         Distribute Key: full_join_on_true_row_1.t2.a2
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t3
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Distribute Key: full_join_on_true_row_1.t3.a3
                                             ->  Nested Loop Left Anti Full Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t3
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t2
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Distribute Key: full_join_on_true_row_1.t2.a2
(52 rows)

-- group by
select a1,sum(a2) from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by 1,2;
 a1  | sum 
-----+-----
   1 |    
  11 |   4
 111 | 138
     |    
(4 rows)

select sum(a1) from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by 1;
 sum 
-----
   1
  22
 333
    
(4 rows)

select a1,sum(a2) suma2 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by a1,suma2;
 a1  | suma2 
-----+-------
   1 |      
  11 |     4
 111 |   138
     |      
(4 rows)

select sum(a1) suma1 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by suma1;
 suma1 
-------
     1
    22
   333
      
(4 rows)

explain  (costs off ) select a1,sum(a2) from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by 1,2;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         ->  HashAggregate
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Streaming(type: REDISTRIBUTE)
                     Spawn on: All datanodes
                     ->  HashAggregate
                           Group By Key: full_join_on_true_row_1.t1.a1
                           ->  Nested Loop
                                 Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Result
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   ->  Seq Scan on t2
                                                         Filter: ((a2 > 1) OR (a2 IS NULL))
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t3
                                             ->  Nested Loop Left Anti Full Join
                                                   Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Seq Scan on t3
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t1
(33 rows)

explain  (costs off ) select sum(a1) from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by 1;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: (sum(full_join_on_true_row_1.t1.a1))
   Node/s: All datanodes
   ->  Sort
         Sort Key: (sum(full_join_on_true_row_1.t1.a1))
         ->  HashAggregate
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Nested Loop Semi Join
                     Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
                     ->  Seq Scan on t1
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Subquery Scan on subquery
                                       ->  Result
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         ->  Seq Scan on t2
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t3
                                                   ->  Nested Loop Left Anti Full Join
                                                         ->  Seq Scan on t3
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t2
(28 rows)

explain  (costs off ) select a1,sum(a2) suma2 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by a1,suma2;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         ->  HashAggregate
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Streaming(type: REDISTRIBUTE)
                     Spawn on: All datanodes
                     ->  HashAggregate
                           Group By Key: full_join_on_true_row_1.t1.a1
                           ->  Nested Loop
                                 Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Result
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   ->  Seq Scan on t2
                                                         Filter: ((a2 > 1) OR (a2 IS NULL))
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t3
                                             ->  Nested Loop Left Anti Full Join
                                                   Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Seq Scan on t3
                                                   ->  Materialize
                                                         ->  Streaming(type: BROADCAST)
                                                               Spawn on: All datanodes
                                                               ->  Seq Scan on t2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on t1
(33 rows)

explain  (costs off ) select sum(a1) suma2 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by a1,suma2;
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t1.a1))
   Node/s: All datanodes
   ->  Sort
         Sort Key: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t1.a1))
         ->  HashAggregate
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Nested Loop Semi Join
                     Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
                     ->  Seq Scan on t1
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Subquery Scan on subquery
                                       ->  Result
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         ->  Seq Scan on t2
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t3
                                                   ->  Nested Loop Left Anti Full Join
                                                         ->  Seq Scan on t3
                                                         ->  Materialize
                                                               ->  Streaming(type: BROADCAST)
                                                                     Spawn on: All datanodes
                                                                     ->  Seq Scan on t2
(28 rows)

explain  (costs off, verbose ) select a1,sum(a2) from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         ->  HashAggregate
               Output: full_join_on_true_row_1.t1.a1, pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2)))
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Streaming(type: REDISTRIBUTE)
                     Output: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t2.a2))
                     Distribute Key: full_join_on_true_row_1.t1.a1
                     Spawn on: All datanodes
                     Consumer Nodes: All datanodes
                     ->  HashAggregate
                           Output: full_join_on_true_row_1.t1.a1, sum(full_join_on_true_row_1.t2.a2)
                           Group By Key: full_join_on_true_row_1.t1.a1
                           ->  Nested Loop
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2
                                 Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Result
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t2
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         Distribute Key: full_join_on_true_row_1.t2.a2
                                                         Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t3
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Distribute Key: full_join_on_true_row_1.t3.a3
                                             ->  Nested Loop Left Anti Full Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Seq Scan on full_join_on_true_row_1.t3
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t2
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t1.a1
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t1
                                                   Output: full_join_on_true_row_1.t1.a1
                                                   Distribute Key: full_join_on_true_row_1.t1.a1
(63 rows)

explain  (costs off, verbose ) select sum(a1) from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by 1;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                             QUERY PLAN                                                                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (sum(full_join_on_true_row_1.t1.a1)), full_join_on_true_row_1.t1.a1
   Merge Sort Key: (sum(full_join_on_true_row_1.t1.a1))
   Node/s: All datanodes
   ->  Sort
         Output: (sum(full_join_on_true_row_1.t1.a1)), full_join_on_true_row_1.t1.a1
         Sort Key: (sum(full_join_on_true_row_1.t1.a1))
         ->  HashAggregate
               Output: sum(full_join_on_true_row_1.t1.a1), full_join_on_true_row_1.t1.a1
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Nested Loop Semi Join
                     Output: full_join_on_true_row_1.t1.a1
                     Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                           Distribute Key: full_join_on_true_row_1.t1.a1
                     ->  Materialize
                           Output: subquery.a2
                           ->  Streaming(type: BROADCAST)
                                 Output: subquery.a2
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Subquery Scan on subquery
                                       Output: subquery.a2
                                       ->  Result
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t2
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Distribute Key: full_join_on_true_row_1.t2.a2
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t3
                                                                           Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                           Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Nested Loop Left Anti Full Join
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t3
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Distribute Key: full_join_on_true_row_1.t3.a3
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t2
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           Distribute Key: full_join_on_true_row_1.t2.a2
(55 rows)

explain  (costs off, verbose ) select a1,sum(a2) suma2 from t1, (select *from t2 full join t3 on 1=1 where (t2.a2>1 or t2.a2 is null)) sub where t1.a1>sub.a2 or sub.a2 is null group by a1 order by a1,suma2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
   Node/s: All datanodes
   ->  Sort
         Output: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         Sort Key: full_join_on_true_row_1.t1.a1, (pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2))))
         ->  HashAggregate
               Output: full_join_on_true_row_1.t1.a1, pg_catalog.sum((sum(full_join_on_true_row_1.t2.a2)))
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Streaming(type: REDISTRIBUTE)
                     Output: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t2.a2))
                     Distribute Key: full_join_on_true_row_1.t1.a1
                     Spawn on: All datanodes
                     Consumer Nodes: All datanodes
                     ->  HashAggregate
                           Output: full_join_on_true_row_1.t1.a1, sum(full_join_on_true_row_1.t2.a2)
                           Group By Key: full_join_on_true_row_1.t1.a1
                           ->  Nested Loop
                                 Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2
                                 Join Filter: ((full_join_on_true_row_1.t1.a1 > full_join_on_true_row_1.t2.a2) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                 ->  Result
                                       Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                       ->  Append
                                             ->  Nested Loop Left Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   ->  Seq Scan on full_join_on_true_row_1.t2
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         Distribute Key: full_join_on_true_row_1.t2.a2
                                                         Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t3
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Distribute Key: full_join_on_true_row_1.t3.a3
                                             ->  Nested Loop Left Anti Full Join
                                                   Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                   Filter: ((full_join_on_true_row_1.t2.a2 > 1) OR (full_join_on_true_row_1.t2.a2 IS NULL))
                                                   ->  Seq Scan on full_join_on_true_row_1.t3
                                                         Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Materialize
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                         ->  Streaming(type: BROADCAST)
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Spawn on: All datanodes
                                                               Consumer Nodes: All datanodes
                                                               ->  Seq Scan on full_join_on_true_row_1.t2
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Distribute Key: full_join_on_true_row_1.t2.a2
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.t1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.t1.a1
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.t1
                                                   Output: full_join_on_true_row_1.t1.a1
                                                   Distribute Key: full_join_on_true_row_1.t1.a1
(63 rows)

explain  (costs off, verbose ) select sum(a1) suma2 from t1 where exists (select *from t2 full join t3 on 1=1 where (t2.a2>t1.a1 or t2.a2 is null)) group by a1 order by a1,suma2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t3.a3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                                                             QUERY PLAN                                                                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (sum(full_join_on_true_row_1.t1.a1)), full_join_on_true_row_1.t1.a1
   Merge Sort Key: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t1.a1))
   Node/s: All datanodes
   ->  Sort
         Output: (sum(full_join_on_true_row_1.t1.a1)), full_join_on_true_row_1.t1.a1
         Sort Key: full_join_on_true_row_1.t1.a1, (sum(full_join_on_true_row_1.t1.a1))
         ->  HashAggregate
               Output: sum(full_join_on_true_row_1.t1.a1), full_join_on_true_row_1.t1.a1
               Group By Key: full_join_on_true_row_1.t1.a1
               ->  Nested Loop Semi Join
                     Output: full_join_on_true_row_1.t1.a1
                     Join Filter: ((subquery.a2 > full_join_on_true_row_1.t1.a1) OR (subquery.a2 IS NULL))
                     ->  Seq Scan on full_join_on_true_row_1.t1
                           Output: full_join_on_true_row_1.t1.a1, full_join_on_true_row_1.t1.b1, full_join_on_true_row_1.t1.c1, full_join_on_true_row_1.t1.samename
                           Distribute Key: full_join_on_true_row_1.t1.a1
                     ->  Materialize
                           Output: subquery.a2
                           ->  Streaming(type: BROADCAST)
                                 Output: subquery.a2
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Subquery Scan on subquery
                                       Output: subquery.a2
                                       ->  Result
                                             Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                             ->  Append
                                                   ->  Nested Loop Left Join
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t2
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               Distribute Key: full_join_on_true_row_1.t2.a2
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t3
                                                                           Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                                           Distribute Key: full_join_on_true_row_1.t3.a3
                                                   ->  Nested Loop Left Anti Full Join
                                                         Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename, full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                         ->  Seq Scan on full_join_on_true_row_1.t3
                                                               Output: full_join_on_true_row_1.t3.a3, full_join_on_true_row_1.t3.b3, full_join_on_true_row_1.t3.c3, full_join_on_true_row_1.t3.samename
                                                               Distribute Key: full_join_on_true_row_1.t3.a3
                                                         ->  Materialize
                                                               Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                               ->  Streaming(type: BROADCAST)
                                                                     Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                     Spawn on: All datanodes
                                                                     Consumer Nodes: All datanodes
                                                                     ->  Seq Scan on full_join_on_true_row_1.t2
                                                                           Output: full_join_on_true_row_1.t2.a2, full_join_on_true_row_1.t2.b2, full_join_on_true_row_1.t2.c2, full_join_on_true_row_1.t2.samename
                                                                           Distribute Key: full_join_on_true_row_1.t2.a2
(55 rows)

-- Type not distributable
drop table if exists cidr1;
NOTICE:  table "cidr1" does not exist, skipping
drop table if exists cidr2;
NOTICE:  table "cidr2" does not exist, skipping
create table cidr1(a1 cidr, b1 cidr, d int);
create table cidr2(a2 cidr, b2 cidr, d int);
insert into cidr2 values('192.168.0.0/16', '192.168.0.0/16', 1);
insert into cidr2 values('100.100.0.0/16', '100.100.0.0/16', 1);
insert into cidr2 values('100.100.0.0/16', '100.100.0.0/16', 1);
insert into cidr2 values('2.2.0.0/16', '2.2.0.0/16', 1);
-- Nestloop
set enable_nestloop=on;
set enable_hashjoin=off;
set enable_mergejoin=off;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
 a1 | b1 |       a2       |       b2       
----+----+----------------+----------------
    |    | 2.2.0.0/16     | 2.2.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 192.168.0.0/16 | 192.168.0.0/16
(4 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
 a1 | sum 
----+-----
    |   4
(1 row)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
 a1 | sumd 
----+------
    |    4
(1 row)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on cidr1
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr2
                           ->  Nested Loop Left Anti Full Join
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on cidr2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr1
(22 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr1
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Nested Loop Left Anti Full Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr2
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(25 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr1
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Nested Loop Left Anti Full Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr2
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(25 rows)

explain (verbose,costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
               ->  Result
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on full_join_on_true_row_1.cidr1
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Distribute Key: full_join_on_true_row_1.cidr1.d
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on full_join_on_true_row_1.cidr2
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Distribute Key: full_join_on_true_row_1.cidr2.d
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
(42 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Nested Loop Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(47 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Nested Loop Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(47 rows)

-- Hashjoin
set enable_nestloop=off;
set enable_hashjoin=on;
set enable_mergejoin=off;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
 a1 | b1 |       a2       |       b2       
----+----+----------------+----------------
    |    | 2.2.0.0/16     | 2.2.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 192.168.0.0/16 | 192.168.0.0/16
(4 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
 a1 | sum 
----+-----
    |   4
(1 row)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
 a1 | sumd 
----+------
    |    4
(1 row)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Hash Right Join
                                 Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Spawn on: All datanodes
                                       ->  Seq Scan on cidr2
                                 ->  Hash
                                       ->  Seq Scan on cidr1
                           ->  Hash Right Anti Full Join
                                 Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Spawn on: All datanodes
                                       ->  Seq Scan on cidr1
                                 ->  Hash
                                       ->  Seq Scan on cidr2
(22 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Hash Right Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr2
                                             ->  Hash
                                                   ->  Seq Scan on cidr1
                                       ->  Hash Right Anti Full Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr1
                                             ->  Hash
                                                   ->  Seq Scan on cidr2
(25 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Hash Right Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr2
                                             ->  Hash
                                                   ->  Seq Scan on cidr1
                                       ->  Hash Right Anti Full Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr1
                                             ->  Hash
                                                   ->  Seq Scan on cidr2
(25 rows)

explain (verbose,costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
               ->  Result
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     ->  Append
                           ->  Hash Right Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Spawn on: All datanodes
                                       Consumer Nodes: All datanodes
                                       ->  Seq Scan on full_join_on_true_row_1.cidr2
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Distribute Key: full_join_on_true_row_1.cidr2.d
                                 ->  Hash
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       ->  Seq Scan on full_join_on_true_row_1.cidr1
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Distribute Key: full_join_on_true_row_1.cidr1.d
                           ->  Hash Right Anti Full Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Spawn on: All datanodes
                                       Consumer Nodes: All datanodes
                                       ->  Seq Scan on full_join_on_true_row_1.cidr1
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Distribute Key: full_join_on_true_row_1.cidr1.d
                                 ->  Hash
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       ->  Seq Scan on full_join_on_true_row_1.cidr2
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Distribute Key: full_join_on_true_row_1.cidr2.d
(42 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Hash Right Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                       ->  Hash Right Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
(47 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Hash Right Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                       ->  Hash Right Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
(47 rows)

-- Merge join
set enable_nestloop=off;
set enable_hashjoin=off;
set enable_mergejoin=on;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
 a1 | b1 |       a2       |       b2       
----+----+----------------+----------------
    |    | 2.2.0.0/16     | 2.2.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 100.100.0.0/16 | 100.100.0.0/16
    |    | 192.168.0.0/16 | 192.168.0.0/16
(4 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
 a1 | sum 
----+-----
    |   4
(1 row)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
 a1 | sumd 
----+------
    |    4
(1 row)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Merge Left Join
                                 Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Seq Scan on cidr1
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr2
                           ->  Merge Left Anti Full Join
                                 Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Seq Scan on cidr2
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr1
(28 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Merge Left Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on cidr1
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Merge Left Anti Full Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on cidr2
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(31 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Merge Left Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on cidr1
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Merge Left Anti Full Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on cidr2
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(31 rows)

explain (verbose,costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
               ->  Result
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     ->  Append
                           ->  Merge Left Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Seq Scan on full_join_on_true_row_1.cidr1
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Distribute Key: full_join_on_true_row_1.cidr1.d
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                           ->  Merge Left Anti Full Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Seq Scan on full_join_on_true_row_1.cidr2
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Distribute Key: full_join_on_true_row_1.cidr2.d
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
(50 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Merge Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Merge Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(55 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Merge Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Merge Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(55 rows)

insert into cidr1 values('192.168.0.0/16', '192.168.0.0/16', 1);
insert into cidr1 values('100.100.0.0/16', '100.100.0.0/16', 1);
insert into cidr1 values('100.100.0.0/16', '100.100.0.0/16', 1);
insert into cidr1 values('1.1.0.0/16', '1.1.0.0/16', 1);
set enable_nestloop=on;
set enable_hashjoin=off;
set enable_mergejoin=off;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
       a1       |       b1       |       a2       |       b2       
----------------+----------------+----------------+----------------
 1.1.0.0/16     | 1.1.0.0/16     |                | 
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16
                |                | 2.2.0.0/16     | 2.2.0.0/16
(7 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
       a1       | sum 
----------------+-----
 1.1.0.0/16     |    
 100.100.0.0/16 |   4
 192.168.0.0/16 |   1
                |   1
(4 rows)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
       a1       | sumd 
----------------+------
 1.1.0.0/16     |     
 100.100.0.0/16 |    4
 192.168.0.0/16 |    1
                |    1
(4 rows)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Nested Loop Left Join
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on cidr1
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr2
                           ->  Nested Loop Left Anti Full Join
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on cidr2
                                 ->  Materialize
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr1
(22 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr1
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Nested Loop Left Anti Full Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr2
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(25 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr1
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Nested Loop Left Anti Full Join
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on cidr2
                                             ->  Materialize
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(25 rows)

explain (verbose,costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
               ->  Result
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     ->  Append
                           ->  Nested Loop Left Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on full_join_on_true_row_1.cidr1
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Distribute Key: full_join_on_true_row_1.cidr1.d
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                           ->  Nested Loop Left Anti Full Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Seq Scan on full_join_on_true_row_1.cidr2
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Distribute Key: full_join_on_true_row_1.cidr2.d
                                 ->  Materialize
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
(42 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Nested Loop Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(47 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Nested Loop Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Nested Loop Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Join Filter: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Materialize
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(47 rows)

set enable_nestloop=off;
set enable_hashjoin=on;
set enable_mergejoin=off;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
       a1       |       b1       |       a2       |       b2       
----------------+----------------+----------------+----------------
 1.1.0.0/16     | 1.1.0.0/16     |                | 
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16
                |                | 2.2.0.0/16     | 2.2.0.0/16
(7 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
       a1       | sum 
----------------+-----
 1.1.0.0/16     |    
 100.100.0.0/16 |   4
 192.168.0.0/16 |   1
                |   1
(4 rows)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
       a1       | sumd 
----------------+------
 1.1.0.0/16     |     
 100.100.0.0/16 |    4
 192.168.0.0/16 |    1
                |    1
(4 rows)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Hash Right Join
                                 Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Spawn on: All datanodes
                                       ->  Seq Scan on cidr2
                                 ->  Hash
                                       ->  Seq Scan on cidr1
                           ->  Hash Right Anti Full Join
                                 Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Streaming(type: BROADCAST)
                                       Spawn on: All datanodes
                                       ->  Seq Scan on cidr1
                                 ->  Hash
                                       ->  Seq Scan on cidr2
(22 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Hash Right Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr2
                                             ->  Hash
                                                   ->  Seq Scan on cidr1
                                       ->  Hash Right Anti Full Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr1
                                             ->  Hash
                                                   ->  Seq Scan on cidr2
(25 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Hash Right Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr2
                                             ->  Hash
                                                   ->  Seq Scan on cidr1
                                       ->  Hash Right Anti Full Join
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Spawn on: All datanodes
                                                   ->  Seq Scan on cidr1
                                             ->  Hash
                                                   ->  Seq Scan on cidr2
(25 rows)

explain (verbose,costs off) select *from cidr1 full join cidr2 on a1=a2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                              QUERY PLAN                                                                                                              
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
   Node/s: All datanodes
   ->  Result
         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
         ->  Append
               ->  Hash Right Join
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                     ->  Streaming(type: BROADCAST)
                           Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                           Spawn on: All datanodes
                           Consumer Nodes: All datanodes
                           ->  Seq Scan on full_join_on_true_row_1.cidr2
                                 Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Distribute Key: full_join_on_true_row_1.cidr2.d
                     ->  Hash
                           Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                           ->  Seq Scan on full_join_on_true_row_1.cidr1
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                 Distribute Key: full_join_on_true_row_1.cidr1.d
               ->  Hash Right Anti Full Join
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                     ->  Streaming(type: BROADCAST)
                           Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                           Spawn on: All datanodes
                           Consumer Nodes: All datanodes
                           ->  Seq Scan on full_join_on_true_row_1.cidr1
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                 Distribute Key: full_join_on_true_row_1.cidr1.d
                     ->  Hash
                           Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                           ->  Seq Scan on full_join_on_true_row_1.cidr2
                                 Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Distribute Key: full_join_on_true_row_1.cidr2.d
(36 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Hash Right Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                       ->  Hash Right Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
(47 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Hash Right Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                       ->  Hash Right Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Hash Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Streaming(type: BROADCAST)
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Hash
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
(47 rows)

set enable_nestloop=off;
set enable_hashjoin=off;
set enable_mergejoin=on;
select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
       a1       |       b1       |       a2       |       b2       
----------------+----------------+----------------+----------------
 1.1.0.0/16     | 1.1.0.0/16     |                | 
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16 | 100.100.0.0/16
 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16 | 192.168.0.0/16
                |                | 2.2.0.0/16     | 2.2.0.0/16
(7 rows)

select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
       a1       | sum 
----------------+-----
 1.1.0.0/16     |    
 100.100.0.0/16 |   4
 192.168.0.0/16 |   1
                |   1
(4 rows)

select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
       a1       | sumd 
----------------+------
 1.1.0.0/16     |     
 100.100.0.0/16 |    4
 192.168.0.0/16 |    1
                |    1
(4 rows)

explain (costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               ->  Result
                     ->  Append
                           ->  Merge Left Join
                                 Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Seq Scan on cidr1
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr2
                           ->  Merge Left Anti Full Join
                                 Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Seq Scan on cidr2
                                 ->  Sort
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Spawn on: All datanodes
                                             ->  Seq Scan on cidr1
(28 rows)

explain (costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Merge Left Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on cidr1
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Merge Left Anti Full Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on cidr2
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(31 rows)

explain (costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
                                                                  QUERY PLAN                                                                   
-----------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Node/s: All datanodes
               ->  HashAggregate
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           ->  Result
                                 ->  Append
                                       ->  Merge Left Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on cidr1
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr2
                                       ->  Merge Left Anti Full Join
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on cidr2
                                             ->  Sort
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Spawn on: All datanodes
                                                         ->  Seq Scan on cidr1
(31 rows)

explain (verbose,costs off) select a1,b1,a2,b2 from cidr1 full join cidr2 on a1=a2 order by 1,2,3,4;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                    QUERY PLAN                                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Merge Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
   Node/s: All datanodes
   ->  Sort
         Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         Sort Key: subquery.a1, subquery.b1, subquery.a2, subquery.b2
         ->  Subquery Scan on subquery
               Output: subquery.a1, subquery.b1, subquery.a2, subquery.b2
               ->  Result
                     Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                     ->  Append
                           ->  Merge Left Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Seq Scan on full_join_on_true_row_1.cidr1
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Distribute Key: full_join_on_true_row_1.cidr1.d
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Distribute Key: full_join_on_true_row_1.cidr2.d
                           ->  Merge Left Anti Full Join
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                       Sort Key: full_join_on_true_row_1.cidr2.a2
                                       ->  Seq Scan on full_join_on_true_row_1.cidr2
                                             Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Distribute Key: full_join_on_true_row_1.cidr2.d
                                 ->  Sort
                                       Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                       Sort Key: full_join_on_true_row_1.cidr1.a1
                                       ->  Streaming(type: BROADCAST)
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                             Spawn on: All datanodes
                                             Consumer Nodes: All datanodes
                                             ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Distribute Key: full_join_on_true_row_1.cidr1.d
(50 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) from cidr1 full join cidr2 on a1=a2 group by a1 order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Merge Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Merge Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(55 rows)

explain (verbose,costs off) select a1, sum(cidr2.d) sumd from cidr1 full join cidr2 on a1=a2 group by a1 order by a1,sumd;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr2.d, full_join_on_true_row_1.cidr2.a2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                          QUERY PLAN                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   Sort Key: subquery.a1, (pg_catalog.sum((sum(subquery.d))))
   ->  HashAggregate
         Output: subquery.a1, pg_catalog.sum((sum(subquery.d)))
         Group By Key: subquery.a1
         ->  Streaming (type: GATHER)
               Output: subquery.a1, (sum(subquery.d))
               Node/s: All datanodes
               ->  HashAggregate
                     Output: subquery.a1, sum(subquery.d)
                     Group By Key: subquery.a1
                     ->  Subquery Scan on subquery
                           Output: subquery.a1, subquery.d
                           ->  Result
                                 Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                 ->  Append
                                       ->  Merge Left Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr1.a1)::inet = (full_join_on_true_row_1.cidr2.a2)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Distribute Key: full_join_on_true_row_1.cidr1.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                               Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                               Distribute Key: full_join_on_true_row_1.cidr2.d
                                       ->  Merge Left Anti Full Join
                                             Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d, full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                             Merge Cond: ((full_join_on_true_row_1.cidr2.a2)::inet = (full_join_on_true_row_1.cidr1.a1)::inet)
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                   Sort Key: full_join_on_true_row_1.cidr2.a2
                                                   ->  Seq Scan on full_join_on_true_row_1.cidr2
                                                         Output: full_join_on_true_row_1.cidr2.a2, full_join_on_true_row_1.cidr2.b2, full_join_on_true_row_1.cidr2.d
                                                         Distribute Key: full_join_on_true_row_1.cidr2.d
                                             ->  Sort
                                                   Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                   Sort Key: full_join_on_true_row_1.cidr1.a1
                                                   ->  Streaming(type: BROADCAST)
                                                         Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                         Spawn on: All datanodes
                                                         Consumer Nodes: All datanodes
                                                         ->  Seq Scan on full_join_on_true_row_1.cidr1
                                                               Output: full_join_on_true_row_1.cidr1.a1, full_join_on_true_row_1.cidr1.b1, full_join_on_true_row_1.cidr1.d
                                                               Distribute Key: full_join_on_true_row_1.cidr1.d
(55 rows)

drop table if exists t1;
drop table if exists t;
NOTICE:  table "t" does not exist, skipping
create table t(a float, b float, c float, d int);
create table t1(a float, b float, c float, d int);
insert into t values (-1.1, -1.1, -1.1, -1);
insert into t values (-2.2, -2.2, -2.2, -2);
insert into t values (-2.2, -2.2, -2.2, -2);
insert into t values (1.1, 1.1, 1.1, 1);
insert into t values (2.2, 2.2, 2.2, 2);
insert into t values (2.2, 2.2, 2.2, 2);
insert into t1 values (-10.1, -10.1, -10.1, -10);
insert into t1 values (-20.2, -20.2, -20.2, -20);
insert into t1 values (-20.2, -20.2, -20.2, -20);
insert into t1 values (1.1, 1.1, 1.1, 1);
insert into t1 values (2.2, 2.2, 2.2, 2);
insert into t1 values (2.2, 2.2, 2.2, 2);
set enable_nestloop=on;
set enable_hashjoin=off;
set enable_mergejoin=off;
explain (verbose,costs off) select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t.a, full_join_on_true_row_1.t.b, full_join_on_true_row_1.t1.a, full_join_on_true_row_1.t1.b, full_join_on_true_row_1.t1.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t.b, (sum(s1.cc))
   Merge Sort Key: t.b, (sum(s1.cc))
   Node/s: All datanodes
   ->  Sort
         Output: t.b, (sum(s1.cc))
         Sort Key: t.b, (sum(s1.cc))
         ->  HashAggregate
               Output: t.b, sum(s1.cc)
               Group By Key: t.b
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t.b, s1.cc
                     Distribute Key: t.b
                     Spawn on: All datanodes
                     Consumer Nodes: All datanodes
                     ->  Hash Full Join
                           Output: t.b, s1.cc
                           Hash Cond: (t.b = s1.b)
                           ->  Streaming(type: REDISTRIBUTE)
                                 Output: t.b
                                 Distribute Key: t.b
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t
                                       Output: t.b
                                       Distribute Key: t.a
                           ->  Hash
                                 Output: s1.cc, s1.b
                                 ->  Subquery Scan on s1
                                       Output: s1.cc, s1.b
                                       ->  HashAggregate
                                             Output: t1.b, count(t1.c)
                                             Group By Key: t1.b
                                             ->  Streaming(type: REDISTRIBUTE)
                                                   Output: t1.b, t1.c
                                                   Distribute Key: t1.b
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t1
                                                         Output: t1.b, t1.c
                                                         Distribute Key: t1.a
(41 rows)

select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
  b   | sum 
------+-----
 -2.2 |    
 -1.1 |    
  1.1 |   1
  2.2 |   4
      |   3
(5 rows)

set enable_nestloop=off;
set enable_hashjoin=on;
set enable_mergejoin=off;
explain (verbose,costs off) select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t.a, full_join_on_true_row_1.t.b, full_join_on_true_row_1.t1.a, full_join_on_true_row_1.t1.b, full_join_on_true_row_1.t1.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t.b, (sum(s1.cc))
   Merge Sort Key: t.b, (sum(s1.cc))
   Node/s: All datanodes
   ->  Sort
         Output: t.b, (sum(s1.cc))
         Sort Key: t.b, (sum(s1.cc))
         ->  HashAggregate
               Output: t.b, sum(s1.cc)
               Group By Key: t.b
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t.b, s1.cc
                     Distribute Key: t.b
                     Spawn on: All datanodes
                     Consumer Nodes: All datanodes
                     ->  Hash Full Join
                           Output: t.b, s1.cc
                           Hash Cond: (t.b = s1.b)
                           ->  Streaming(type: REDISTRIBUTE)
                                 Output: t.b
                                 Distribute Key: t.b
                                 Spawn on: All datanodes
                                 Consumer Nodes: All datanodes
                                 ->  Seq Scan on full_join_on_true_row_1.t
                                       Output: t.b
                                       Distribute Key: t.a
                           ->  Hash
                                 Output: s1.cc, s1.b
                                 ->  Subquery Scan on s1
                                       Output: s1.cc, s1.b
                                       ->  HashAggregate
                                             Output: t1.b, count(t1.c)
                                             Group By Key: t1.b
                                             ->  Streaming(type: REDISTRIBUTE)
                                                   Output: t1.b, t1.c
                                                   Distribute Key: t1.b
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t1
                                                         Output: t1.b, t1.c
                                                         Distribute Key: t1.a
(41 rows)

select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
  b   | sum 
------+-----
 -2.2 |    
 -1.1 |    
  1.1 |   1
  2.2 |   4
      |   3
(5 rows)

set enable_nestloop=off;
set enable_hashjoin=off;
set enable_mergejoin=on;
explain (verbose,costs off) select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
WARNING:  Statistics in some tables or columns(full_join_on_true_row_1.t.a, full_join_on_true_row_1.t.b, full_join_on_true_row_1.t1.a, full_join_on_true_row_1.t1.b, full_join_on_true_row_1.t1.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: t.b, (sum(s1.cc))
   Merge Sort Key: t.b, (sum(s1.cc))
   Node/s: All datanodes
   ->  Sort
         Output: t.b, (sum(s1.cc))
         Sort Key: t.b, (sum(s1.cc))
         ->  HashAggregate
               Output: t.b, sum(s1.cc)
               Group By Key: t.b
               ->  Streaming(type: REDISTRIBUTE)
                     Output: t.b, s1.cc
                     Distribute Key: t.b
                     Spawn on: All datanodes
                     Consumer Nodes: All datanodes
                     ->  Merge Full Join
                           Output: t.b, s1.cc
                           Merge Cond: (t.b = s1.b)
                           ->  Sort
                                 Output: t.b
                                 Sort Key: t.b
                                 ->  Streaming(type: REDISTRIBUTE)
                                       Output: t.b
                                       Distribute Key: t.b
                                       Spawn on: All datanodes
                                       Consumer Nodes: All datanodes
                                       ->  Seq Scan on full_join_on_true_row_1.t
                                             Output: t.b
                                             Distribute Key: t.a
                           ->  Sort
                                 Output: s1.cc, s1.b
                                 Sort Key: s1.b
                                 ->  Subquery Scan on s1
                                       Output: s1.cc, s1.b
                                       ->  HashAggregate
                                             Output: t1.b, count(t1.c)
                                             Group By Key: t1.b
                                             ->  Streaming(type: REDISTRIBUTE)
                                                   Output: t1.b, t1.c
                                                   Distribute Key: t1.b
                                                   Spawn on: All datanodes
                                                   Consumer Nodes: All datanodes
                                                   ->  Seq Scan on full_join_on_true_row_1.t1
                                                         Output: t1.b, t1.c
                                                         Distribute Key: t1.a
(45 rows)

select t.b, sum(cc) from t full join (select b, count(c) as cc from t1 group by b) s1 on s1.b=t.b group by t.b order by 1,2;
  b   | sum 
------+-----
 -2.2 |    
 -1.1 |    
  1.1 |   1
  2.2 |   4
      |   3
(5 rows)

drop schema full_join_on_true_row_1 CASCADE;
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to table t2
drop cascades to table t3
drop cascades to table t4
drop cascades to table cidr1
drop cascades to table cidr2
drop cascades to table t
drop cascades to table t1
