--
-- RULES
-- From Jan's original setup_ruletest.sql and run_ruletest.sql
-- - thomas 1998-09-13
--
--
-- Tables and rules for the view test
--
create table rtest_t1 (a int4, b int4) distribute by roundrobin;
create table rtest_t2 (a int4, b int4);
create table rtest_t3 (a int4, b int4);
create view rtest_v1 as select * from rtest_t1;
create rule rtest_v1_ins as on insert to rtest_v1 do instead
	insert into rtest_t1 values (new.a, new.b);
create rule rtest_v1_upd as on update to rtest_v1 do instead
	update rtest_t1 set a = new.a, b = new.b
	where a = old.a;
create rule rtest_v1_del as on delete to rtest_v1 do instead
	delete from rtest_t1 where a = old.a;
-- Test comments
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
ERROR:  rule "rtest_v1_bad" for relation "rtest_v1" does not exist
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
--
-- Tables and rules for the constraint update/delete test
--
-- Note:
-- 	Now that we have multiple action rule support, we check
-- 	both possible syntaxes to define them (The last action
--  can but must not have a semicolon at the end).
--
create table rtest_system (sysname text, sysdesc text) distribute by roundrobin;
create table rtest_interface (sysname text, ifname text) distribute by roundrobin;
create table rtest_person (pname text, pdesc text) distribute by roundrobin;
create table rtest_admin (pname text, sysname text) distribute by roundrobin;
create rule rtest_sys_upd as on update to rtest_system do also (
	update rtest_interface set sysname = new.sysname
		where sysname = old.sysname;
	update rtest_admin set sysname = new.sysname
		where sysname = old.sysname
	);
create rule rtest_sys_del as on delete to rtest_system do also (
	delete from rtest_interface where sysname = old.sysname;
	delete from rtest_admin where sysname = old.sysname;
	);
create rule rtest_pers_upd as on update to rtest_person do also
	update rtest_admin set pname = new.pname where pname = old.pname;
create rule rtest_pers_del as on delete to rtest_person do also
	delete from rtest_admin where pname = old.pname;
--
-- Tables and rules for the logging test
--
create table rtest_emp (ename char(20), salary money) distribute by roundrobin;
create table rtest_emplog (ename char(20), who name, action char(10), newsal money, oldsal money) distribute by roundrobin;
create table rtest_empmass (ename char(20), salary money) distribute by roundrobin;
create rule rtest_emp_ins as on insert to rtest_emp do
	insert into rtest_emplog values (new.ename, current_user,
			'hired', new.salary, '0.00');
create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
	insert into rtest_emplog values (new.ename, current_user,
			'honored', new.salary, old.salary);
create rule rtest_emp_del as on delete to rtest_emp do
	insert into rtest_emplog values (old.ename, current_user,
			'fired', '0.00', old.salary);
--
-- Tables and rules for the multiple cascaded qualified instead
-- rule test
--
create table rtest_t4 (a int4, b text);
create table rtest_t5 (a int4, b text);
create table rtest_t6 (a int4, b text);
create table rtest_t7 (a int4, b text);
create table rtest_t8 (a int4, b text);
create table rtest_t9 (a int4, b text);
create rule rtest_t4_ins1 as on insert to rtest_t4
		where new.a >= 10 and new.a < 20 do instead
	insert into rtest_t5 values (new.a, new.b);
create rule rtest_t4_ins2 as on insert to rtest_t4
		where new.a >= 20 and new.a < 30 do
	insert into rtest_t6 values (new.a, new.b);
create rule rtest_t5_ins as on insert to rtest_t5
		where new.a > 15 do
	insert into rtest_t7 values (new.a, new.b);
create rule rtest_t6_ins as on insert to rtest_t6
		where new.a > 25 do instead
	insert into rtest_t8 values (new.a, new.b);
--
-- Tables and rules for the rule fire order test
--
-- As of PG 7.3, the rules should fire in order by name, regardless
-- of INSTEAD attributes or creation order.
--
create table rtest_order1 (a int4);
create table rtest_order2 (a int4, b int4, c text);
create sequence rtest_seq;
create rule rtest_order_r3 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 3 - this should run 3rd');
create rule rtest_order_r4 as on insert to rtest_order1
		where a < 100 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 4 - this should run 4th');
create rule rtest_order_r2 as on insert to rtest_order1 do
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 2 - this should run 2nd');
create rule rtest_order_r1 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 1 - this should run 1st');
--
-- Tables and rules for the instead nothing test
--
create table rtest_nothn1 (a int4, b text);
create table rtest_nothn2 (a int4, b text);
create table rtest_nothn3 (a int4, b text);
create table rtest_nothn4 (a int4, b text);
create rule rtest_nothn_r1 as on insert to rtest_nothn1
	where new.a >= 10 and new.a < 20 do instead nothing;
create rule rtest_nothn_r2 as on insert to rtest_nothn1
	where new.a >= 30 and new.a < 40 do instead nothing;
create rule rtest_nothn_r3 as on insert to rtest_nothn2
	where new.a >= 100 do instead
	insert into rtest_nothn3 values (new.a, new.b);
create rule rtest_nothn_r4 as on insert to rtest_nothn2
	do instead nothing;
--
-- Tests on a view that is select * of a table
-- and has insert/update/delete instead rules to
-- behave close like the real table.
--
--
-- We need test date later
--
insert into rtest_t2 values (1, 21);
insert into rtest_t2 values (2, 22);
insert into rtest_t2 values (3, 23);
insert into rtest_t3 values (1, 31);
insert into rtest_t3 values (2, 32);
insert into rtest_t3 values (3, 33);
insert into rtest_t3 values (4, 34);
insert into rtest_t3 values (5, 35);
-- insert values
insert into rtest_v1 values (1, 11);
insert into rtest_v1 values (2, 12);
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 11
 2 | 12
(2 rows)

-- delete with constant expression
delete from rtest_v1 where a = 1;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 2 | 12
(1 row)

insert into rtest_v1 values (1, 11);
delete from rtest_v1 where b = 12;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 11
(1 row)

insert into rtest_v1 values (2, 12);
insert into rtest_v1 values (2, 13);
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 11
 2 | 12
 2 | 13
(3 rows)

** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
\p
** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
\r
delete from rtest_v1 where b = 12;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 11
(1 row)

delete from rtest_v1;
-- insert select
insert into rtest_v1 select * from rtest_t2;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 22
 3 | 23
(3 rows)

delete from rtest_v1;
-- same with swapped targetlist
insert into rtest_v1 (b, a) select b, a from rtest_t2;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 22
 3 | 23
(3 rows)

-- now with only one target attribute
insert into rtest_v1 (a) select a from rtest_t3;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 1 |   
 2 | 22
 2 |   
 3 | 23
 3 |   
 4 |   
 5 |   
(8 rows)

select * from rtest_v1 where b isnull order by a, b;
 a | b 
---+---
 1 |  
 2 |  
 3 |  
 4 |  
 5 |  
(5 rows)

-- let attribute a differ (must be done on rtest_t1 - see above)
update rtest_t1 set a = a + 10 where b isnull;
delete from rtest_v1 where b isnull;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 22
 3 | 23
(3 rows)

-- now updates with constant expression
update rtest_v1 set b = 42 where a = 2;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 42
 3 | 23
(3 rows)

update rtest_v1 set b = 99 where b = 42;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 99
 3 | 23
(3 rows)

update rtest_v1 set b = 88 where b < 50;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 88
 2 | 99
 3 | 88
(3 rows)

delete from rtest_v1;
insert into rtest_v1 select rtest_t2.a, rtest_t3.b
    from rtest_t2, rtest_t3
    where rtest_t2.a = rtest_t3.a;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 31
 2 | 32
 3 | 33
(3 rows)

-- updates in a mergejoin
update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 2 | 22
 3 | 23
(3 rows)

insert into rtest_v1 select * from rtest_t3;
select * from rtest_v1 order by a, b;
 a | b  
---+----
 1 | 21
 1 | 31
 2 | 22
 2 | 32
 3 | 23
 3 | 33
 4 | 34
 5 | 35
(8 rows)

update rtest_t1 set a = a + 10 where b > 30;
select * from rtest_v1 order by a, b;
 a  | b  
----+----
  1 | 21
  2 | 22
  3 | 23
 11 | 31
 12 | 32
 13 | 33
 14 | 34
 15 | 35
(8 rows)

update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
select * from rtest_v1 order by a, b;
 a  | b  
----+----
  1 | 21
  2 | 22
  3 | 23
 21 | 31
 22 | 32
 23 | 33
 24 | 34
 25 | 35
(8 rows)

--
-- Test for constraint updates/deletes
--
insert into rtest_system values ('orion', 'Linux Jan Wieck');
insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
insert into rtest_system values ('neptun', 'Fileserver');
insert into rtest_interface values ('orion', 'eth0');
insert into rtest_interface values ('orion', 'eth1');
insert into rtest_interface values ('notjw', 'eth0');
insert into rtest_interface values ('neptun', 'eth0');
insert into rtest_person values ('jw', 'Jan Wieck');
insert into rtest_person values ('bm', 'Bruce Momjian');
insert into rtest_admin values ('jw', 'orion');
insert into rtest_admin values ('jw', 'notjw');
insert into rtest_admin values ('bm', 'neptun');
update rtest_system set sysname = 'pluto' where sysname = 'neptun';
select * from rtest_interface order by sysname, ifname;
 sysname | ifname 
---------+--------
 notjw   | eth0
 orion   | eth0
 orion   | eth1
 pluto   | eth0
(4 rows)

select * from rtest_admin order by pname, sysname;
 pname | sysname 
-------+---------
 bm    | pluto
 jw    | notjw
 jw    | orion
(3 rows)

update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
-- Note: use ORDER BY here to ensure consistent output across all systems.
-- The above UPDATE affects two rows with equal keys, so they could be
-- updated in either order depending on the whim of the local qsort().
select * from rtest_admin order by pname, sysname;
 pname  | sysname 
--------+---------
 bm     | pluto
 jwieck | notjw
 jwieck | orion
(3 rows)

delete from rtest_system where sysname = 'orion';
select * from rtest_interface order by sysname, ifname;
 sysname | ifname 
---------+--------
 notjw   | eth0
 pluto   | eth0
(2 rows)

select * from rtest_admin order by pname, sysname;
 pname  | sysname 
--------+---------
 bm     | pluto
 jwieck | notjw
(2 rows)

--
-- Rule qualification test
--
insert into rtest_emp values ('wiecc', '5000.00');
insert into rtest_emp values ('gates', '80000.00');
update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
update rtest_emp set salary = '7000.00' where ename = 'wieck';
delete from rtest_emp where ename = 'gates';
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
        ename         | matches user |   action   |   newsal   |   oldsal   
----------------------+--------------+------------+------------+------------
 gates                | t            | fired      |      $0.00 | $80,000.00
 gates                | t            | hired      | $80,000.00 |      $0.00
 wiecc                | t            | hired      |  $5,000.00 |      $0.00
 wieck                | t            | honored    |  $6,000.00 |  $5,000.00
 wieck                | t            | honored    |  $7,000.00 |  $6,000.00
(5 rows)

insert into rtest_empmass values ('meyer', '4000.00');
insert into rtest_empmass values ('maier', '5000.00');
insert into rtest_empmass values ('mayr', '6000.00');
insert into rtest_emp select * from rtest_empmass;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
        ename         | matches user |   action   |   newsal   |   oldsal   
----------------------+--------------+------------+------------+------------
 gates                | t            | fired      |      $0.00 | $80,000.00
 gates                | t            | hired      | $80,000.00 |      $0.00
 maier                | t            | hired      |  $5,000.00 |      $0.00
 mayr                 | t            | hired      |  $6,000.00 |      $0.00
 meyer                | t            | hired      |  $4,000.00 |      $0.00
 wiecc                | t            | hired      |  $5,000.00 |      $0.00
 wieck                | t            | honored    |  $6,000.00 |  $5,000.00
 wieck                | t            | honored    |  $7,000.00 |  $6,000.00
(8 rows)

update rtest_empmass set salary = salary + '1000.00';
update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
        ename         | matches user |   action   |   newsal   |   oldsal   
----------------------+--------------+------------+------------+------------
 gates                | t            | fired      |      $0.00 | $80,000.00
 gates                | t            | hired      | $80,000.00 |      $0.00
 maier                | t            | hired      |  $5,000.00 |      $0.00
 maier                | t            | honored    |  $6,000.00 |  $5,000.00
 mayr                 | t            | hired      |  $6,000.00 |      $0.00
 mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
 meyer                | t            | hired      |  $4,000.00 |      $0.00
 meyer                | t            | honored    |  $5,000.00 |  $4,000.00
 wiecc                | t            | hired      |  $5,000.00 |      $0.00
 wieck                | t            | honored    |  $6,000.00 |  $5,000.00
 wieck                | t            | honored    |  $7,000.00 |  $6,000.00
(11 rows)

delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
        ename         | matches user |   action   |   newsal   |   oldsal   
----------------------+--------------+------------+------------+------------
 gates                | t            | fired      |      $0.00 | $80,000.00
 gates                | t            | hired      | $80,000.00 |      $0.00
 maier                | t            | fired      |      $0.00 |  $6,000.00
 maier                | t            | hired      |  $5,000.00 |      $0.00
 maier                | t            | honored    |  $6,000.00 |  $5,000.00
 mayr                 | t            | fired      |      $0.00 |  $7,000.00
 mayr                 | t            | hired      |  $6,000.00 |      $0.00
 mayr                 | t            | honored    |  $7,000.00 |  $6,000.00
 meyer                | t            | fired      |      $0.00 |  $5,000.00
 meyer                | t            | hired      |  $4,000.00 |      $0.00
 meyer                | t            | honored    |  $5,000.00 |  $4,000.00
 wiecc                | t            | hired      |  $5,000.00 |      $0.00
 wieck                | t            | honored    |  $6,000.00 |  $5,000.00
 wieck                | t            | honored    |  $7,000.00 |  $6,000.00
(14 rows)

--
-- Multiple cascaded qualified instead rule test
--
insert into rtest_t4 values (1, 'Record should go to rtest_t4');
insert into rtest_t4 values (2, 'Record should go to rtest_t4');
insert into rtest_t4 values (10, 'Record should go to rtest_t5');
insert into rtest_t4 values (15, 'Record should go to rtest_t5');
insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
insert into rtest_t4 values (30, 'Record should go to rtest_t4');
insert into rtest_t4 values (40, 'Record should go to rtest_t4');
select * from rtest_t4 order by a, b;
 a  |                  b                  
----+-------------------------------------
  1 | Record should go to rtest_t4
  2 | Record should go to rtest_t4
 20 | Record should go to rtest_t4 and t6
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
 30 | Record should go to rtest_t4
 40 | Record should go to rtest_t4
(7 rows)

select * from rtest_t5 order by a, b;
 a  |                  b                  
----+-------------------------------------
 10 | Record should go to rtest_t5
 15 | Record should go to rtest_t5
 19 | Record should go to rtest_t5 and t7
(3 rows)

select * from rtest_t6 order by a, b;
 a  |                  b                  
----+-------------------------------------
 20 | Record should go to rtest_t4 and t6
(1 row)

select * from rtest_t7 order by a, b;
 a  |                  b                  
----+-------------------------------------
 19 | Record should go to rtest_t5 and t7
(1 row)

select * from rtest_t8 order by a, b;
 a  |                  b                  
----+-------------------------------------
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
(2 rows)

delete from rtest_t4;
delete from rtest_t5;
delete from rtest_t6;
delete from rtest_t7;
delete from rtest_t8;
insert into rtest_t9 values (1, 'Record should go to rtest_t4');
insert into rtest_t9 values (2, 'Record should go to rtest_t4');
insert into rtest_t9 values (10, 'Record should go to rtest_t5');
insert into rtest_t9 values (15, 'Record should go to rtest_t5');
insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
insert into rtest_t9 values (30, 'Record should go to rtest_t4');
insert into rtest_t9 values (40, 'Record should go to rtest_t4');
insert into rtest_t4 select * from rtest_t9 where a < 20;
select * from rtest_t4 order by a, b;
 a |              b               
---+------------------------------
 1 | Record should go to rtest_t4
 2 | Record should go to rtest_t4
(2 rows)

select * from rtest_t5 order by a, b;
 a  |                  b                  
----+-------------------------------------
 10 | Record should go to rtest_t5
 15 | Record should go to rtest_t5
 19 | Record should go to rtest_t5 and t7
(3 rows)

select * from rtest_t6 order by a, b;
 a | b 
---+---
(0 rows)

select * from rtest_t7 order by a, b;
 a  |                  b                  
----+-------------------------------------
 19 | Record should go to rtest_t5 and t7
(1 row)

select * from rtest_t8 order by a, b;
 a | b 
---+---
(0 rows)

insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
select * from rtest_t4 order by a, b;
 a  |                  b                  
----+-------------------------------------
  1 | Record should go to rtest_t4
  2 | Record should go to rtest_t4
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
(4 rows)

select * from rtest_t5 order by a, b;
 a  |                  b                  
----+-------------------------------------
 10 | Record should go to rtest_t5
 15 | Record should go to rtest_t5
 19 | Record should go to rtest_t5 and t7
(3 rows)

select * from rtest_t6 order by a, b;
 a | b 
---+---
(0 rows)

select * from rtest_t7 order by a, b;
 a  |                  b                  
----+-------------------------------------
 19 | Record should go to rtest_t5 and t7
(1 row)

select * from rtest_t8 order by a, b;
 a  |                  b                  
----+-------------------------------------
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
(2 rows)

insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
select * from rtest_t4 order by a, b;
 a  |                  b                  
----+-------------------------------------
  1 | Record should go to rtest_t4
  2 | Record should go to rtest_t4
 21 | Record should go to rtest_t4 and t6
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
 31 | Record should go to rtest_t4
 41 | Record should go to rtest_t4
(7 rows)

select * from rtest_t5 order by a, b;
 a  |                  b                  
----+-------------------------------------
 10 | Record should go to rtest_t5
 15 | Record should go to rtest_t5
 19 | Record should go to rtest_t5 and t7
(3 rows)

select * from rtest_t6 order by a, b;
 a  |                  b                  
----+-------------------------------------
 21 | Record should go to rtest_t4 and t6
(1 row)

select * from rtest_t7 order by a, b;
 a  |                  b                  
----+-------------------------------------
 19 | Record should go to rtest_t5 and t7
(1 row)

select * from rtest_t8 order by a, b;
 a  |                  b                  
----+-------------------------------------
 26 | Record should go to rtest_t4 and t8
 28 | Record should go to rtest_t4 and t8
(2 rows)

--
-- Check that the ordering of rules fired is correct
--
insert into rtest_order1 values (1);
select * from rtest_order2 order by a, b, c;
 a | b |              c               
---+---+------------------------------
 1 | 1 | rule 1 - this should run 1st
 1 | 2 | rule 2 - this should run 2nd
 1 | 3 | rule 3 - this should run 3rd
 1 | 4 | rule 4 - this should run 4th
(4 rows)

--
-- Check if instead nothing w/without qualification works
--
insert into rtest_nothn1 values (1, 'want this');
insert into rtest_nothn1 values (2, 'want this');
insert into rtest_nothn1 values (10, 'don''t want this');
insert into rtest_nothn1 values (19, 'don''t want this');
insert into rtest_nothn1 values (20, 'want this');
insert into rtest_nothn1 values (29, 'want this');
insert into rtest_nothn1 values (30, 'don''t want this');
insert into rtest_nothn1 values (39, 'don''t want this');
insert into rtest_nothn1 values (40, 'want this');
insert into rtest_nothn1 values (50, 'want this');
insert into rtest_nothn1 values (60, 'want this');
select * from rtest_nothn1 order by a, b;
 a  |     b     
----+-----------
  1 | want this
  2 | want this
 20 | want this
 29 | want this
 40 | want this
 50 | want this
 60 | want this
(7 rows)

insert into rtest_nothn2 values (10, 'too small');
insert into rtest_nothn2 values (50, 'too small');
insert into rtest_nothn2 values (100, 'OK');
insert into rtest_nothn2 values (200, 'OK');
select * from rtest_nothn2 order by a, b;
 a | b 
---+---
(0 rows)

select * from rtest_nothn3 order by a, b;
  a  | b  
-----+----
 100 | OK
 200 | OK
(2 rows)

delete from rtest_nothn1;
delete from rtest_nothn2;
delete from rtest_nothn3;
insert into rtest_nothn4 values (1, 'want this');
insert into rtest_nothn4 values (2, 'want this');
insert into rtest_nothn4 values (10, 'don''t want this');
insert into rtest_nothn4 values (19, 'don''t want this');
insert into rtest_nothn4 values (20, 'want this');
insert into rtest_nothn4 values (29, 'want this');
insert into rtest_nothn4 values (30, 'don''t want this');
insert into rtest_nothn4 values (39, 'don''t want this');
insert into rtest_nothn4 values (40, 'want this');
insert into rtest_nothn4 values (50, 'want this');
insert into rtest_nothn4 values (60, 'want this');
insert into rtest_nothn1 select * from rtest_nothn4;
select * from rtest_nothn1 order by a, b;
 a  |     b     
----+-----------
  1 | want this
  2 | want this
 20 | want this
 29 | want this
 40 | want this
 50 | want this
 60 | want this
(7 rows)

delete from rtest_nothn4;
insert into rtest_nothn4 values (10, 'too small');
insert into rtest_nothn4 values (50, 'too small');
insert into rtest_nothn4 values (100, 'OK');
insert into rtest_nothn4 values (200, 'OK');
insert into rtest_nothn2 select * from rtest_nothn4;
select * from rtest_nothn2 order by a, b;
 a | b 
---+---
(0 rows)

select * from rtest_nothn3 order by a, b;
  a  | b  
-----+----
 100 | OK
 200 | OK
(2 rows)

create table rtest_view1 (a int4, b text, v bool);
create table rtest_view2 (a int4);
create table rtest_view3 (a int4, b text);
create table rtest_view4 (a int4, b text, c int4);
create view rtest_vview1 as select a, b from rtest_view1 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
create view rtest_vview2 as select a, b from rtest_view1 where v;
create view rtest_vview3 as select a, b from rtest_vview2 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
	from rtest_view1 X, rtest_view2 Y
	where X.a = Y.a
	group by X.a, X.b;
create function rtest_viewfunc1(int4) returns int4 as
	'select count(*)::int4 from rtest_view2 where a = $1'
	language sql;
create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
	from rtest_view1;
insert into rtest_view1 values (1, 'item 1', 't');
insert into rtest_view1 values (2, 'item 2', 't');
insert into rtest_view1 values (3, 'item 3', 't');
insert into rtest_view1 values (4, 'item 4', 'f');
insert into rtest_view1 values (5, 'item 5', 't');
insert into rtest_view1 values (6, 'item 6', 'f');
insert into rtest_view1 values (7, 'item 7', 't');
insert into rtest_view1 values (8, 'item 8', 't');
insert into rtest_view2 values (2);
insert into rtest_view2 values (2);
insert into rtest_view2 values (4);
insert into rtest_view2 values (5);
insert into rtest_view2 values (7);
insert into rtest_view2 values (7);
insert into rtest_view2 values (7);
insert into rtest_view2 values (7);
select * from rtest_vview1 order by a, b;
 a |   b    
---+--------
 2 | item 2
 4 | item 4
 5 | item 5
 7 | item 7
(4 rows)

select * from rtest_vview2 order by a, b;
 a |   b    
---+--------
 1 | item 1
 2 | item 2
 3 | item 3
 5 | item 5
 7 | item 7
 8 | item 8
(6 rows)

select * from rtest_vview3 order by a, b;
 a |   b    
---+--------
 2 | item 2
 5 | item 5
 7 | item 7
(3 rows)

select * from rtest_vview4 order by a, b;
 a |   b    | refcount 
---+--------+----------
 2 | item 2 |        2
 4 | item 4 |        1
 5 | item 5 |        1
 7 | item 7 |        4
(4 rows)

select * from rtest_vview5 order by a, b;
 a |   b    | refcount 
---+--------+----------
 1 | item 1 |        0
 2 | item 2 |        2
 3 | item 3 |        0
 4 | item 4 |        1
 5 | item 5 |        1
 6 | item 6 |        0
 7 | item 7 |        4
 8 | item 8 |        0
(8 rows)

insert into rtest_view3 select * from rtest_vview1 where a < 7;
select * from rtest_view3 order by a, b;
 a |   b    
---+--------
 2 | item 2
 4 | item 4
 5 | item 5
(3 rows)

delete from rtest_view3;
insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
select * from rtest_view3 order by a, b;
 a |   b    
---+--------
 1 | item 1
 3 | item 3
 7 | item 7
 8 | item 8
(4 rows)

delete from rtest_view3;
insert into rtest_view3 select * from rtest_vview3;
select * from rtest_view3 order by a, b;
 a |   b    
---+--------
 2 | item 2
 5 | item 5
 7 | item 7
(3 rows)

delete from rtest_view3;
insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
select * from rtest_view4 order by a, b;
 a |   b    | c 
---+--------+---
 2 | item 2 | 2
 4 | item 4 | 1
 5 | item 5 | 1
(3 rows)

delete from rtest_view4;
insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
select * from rtest_view4 order by a, b;
 a |   b    | c 
---+--------+---
 3 | item 3 | 0
 6 | item 6 | 0
 8 | item 8 | 0
(3 rows)

delete from rtest_view4;
--
-- Test for computations in views
--
create table rtest_comp (
	part	text,
	unit	char(4),
	size	float
);
create table rtest_unitfact (
	unit	char(4),
	factor	float
);
create view rtest_vcomp as
	select X.part, (X.size * Y.factor) as size_in_cm
			from rtest_comp X, rtest_unitfact Y
			where X.unit = Y.unit;
insert into rtest_unitfact values ('m', 100.0);
insert into rtest_unitfact values ('cm', 1.0);
insert into rtest_unitfact values ('inch', 2.54);
insert into rtest_comp values ('p1', 'm', 5.0);
insert into rtest_comp values ('p2', 'm', 3.0);
insert into rtest_comp values ('p3', 'cm', 5.0);
insert into rtest_comp values ('p4', 'cm', 15.0);
insert into rtest_comp values ('p5', 'inch', 7.0);
insert into rtest_comp values ('p6', 'inch', 4.4);
select * from rtest_vcomp order by part;
 part | size_in_cm 
------+------------
 p1   |        500
 p2   |        300
 p3   |          5
 p4   |         15
 p5   |      17.78
 p6   |     11.176
(6 rows)

select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
 part | size_in_cm 
------+------------
 p1   |        500
 p2   |        300
 p5   |      17.78
 p4   |         15
 p6   |     11.176
(5 rows)

--
-- In addition run the (slightly modified) queries from the
-- programmers manual section on the rule system.
--
CREATE TABLE shoe_data (
	shoename   char(10),      -- primary key
	sh_avail   integer,       -- available # of pairs
	slcolor    char(10),      -- preferred shoelace color
	slminlen   float,         -- miminum shoelace length
	slmaxlen   float,         -- maximum shoelace length
	slunit     char(8)        -- length unit
) distribute by roundrobin;
CREATE TABLE shoelace_data (
	sl_name    char(10),      -- primary key
	sl_avail   integer,       -- available # of pairs
	sl_color   char(10),      -- shoelace color
	sl_len     float,         -- shoelace length
	sl_unit    char(8)        -- length unit
) distribute by roundrobin;
CREATE TABLE unit (
	un_name    char(8),       -- the primary key
	un_fact    float          -- factor to transform to cm
) distribute by roundrobin;
CREATE VIEW shoe AS
	SELECT sh.shoename,
		   sh.sh_avail,
		   sh.slcolor,
		   sh.slminlen,
		   sh.slminlen * un.un_fact AS slminlen_cm,
		   sh.slmaxlen,
		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
		   sh.slunit
	  FROM shoe_data sh, unit un
	 WHERE sh.slunit = un.un_name;
CREATE VIEW shoelace AS
	SELECT s.sl_name,
		   s.sl_avail,
		   s.sl_color,
		   s.sl_len,
		   s.sl_unit,
		   s.sl_len * u.un_fact AS sl_len_cm
	  FROM shoelace_data s, unit u
	 WHERE s.sl_unit = u.un_name;
CREATE VIEW shoe_ready AS
	SELECT rsh.shoename,
		   rsh.sh_avail,
		   rsl.sl_name,
		   rsl.sl_avail,
		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
	  FROM shoe rsh, shoelace rsl
	 WHERE rsl.sl_color = rsh.slcolor
	   AND rsl.sl_len_cm >= rsh.slminlen_cm
	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
INSERT INTO unit VALUES ('cm', 1.0);
INSERT INTO unit VALUES ('m', 100.0);
INSERT INTO unit VALUES ('inch', 2.54);
INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
-- SELECTs in doc
SELECT * FROM shoelace ORDER BY sl_name;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl1        |        5 | black      |     80 | cm       |        80
 sl2        |        6 | black      |    100 | cm       |       100
 sl3        |        0 | black      |     35 | inch     |      88.9
 sl4        |        8 | black      |     40 | inch     |     101.6
 sl5        |        4 | brown      |      1 | m        |       100
 sl6        |        0 | brown      |     .9 | m        |        90
 sl7        |        7 | brown      |     60 | cm       |        60
 sl8        |        1 | brown      |     40 | inch     |     101.6
(8 rows)

SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
  shoename  | sh_avail |  sl_name   | sl_avail | total_avail 
------------+----------+------------+----------+-------------
 sh1        |        2 | sl1        |        5 |           2
 sh3        |        4 | sl7        |        7 |           4
(2 rows)

    CREATE TABLE shoelace_log (
        sl_name    char(10),      -- shoelace changed
        sl_avail   integer,       -- new available value
        log_who    name,          -- who did it
        log_when   timestamp      -- when
    );
-- Want "log_who" to be CURRENT_USER,
-- but that is non-portable for the regression test
-- - thomas 1999-02-21
    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        'Al Bundy',
                                        'epoch'
                                    );
UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
SELECT * FROM shoelace_log;
  sl_name   | sl_avail | log_who  |         log_when         
------------+----------+----------+--------------------------
 sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
(1 row)

    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit);
    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name;
    CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name;
    CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    );
    CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    );
    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name;
INSERT INTO shoelace_arrive VALUES ('sl3', 10);
INSERT INTO shoelace_arrive VALUES ('sl6', 20);
INSERT INTO shoelace_arrive VALUES ('sl8', 20);
SELECT * FROM shoelace ORDER BY sl_name;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl1        |        5 | black      |     80 | cm       |        80
 sl2        |        6 | black      |    100 | cm       |       100
 sl3        |        0 | black      |     35 | inch     |      88.9
 sl4        |        8 | black      |     40 | inch     |     101.6
 sl5        |        4 | brown      |      1 | m        |       100
 sl6        |        0 | brown      |     .9 | m        |        90
 sl7        |        6 | brown      |     60 | cm       |        60
 sl8        |        1 | brown      |     40 | inch     |     101.6
(8 rows)

insert into shoelace_ok select * from shoelace_arrive;
SELECT * FROM shoelace ORDER BY sl_name;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl1        |        5 | black      |     80 | cm       |        80
 sl2        |        6 | black      |    100 | cm       |       100
 sl3        |       10 | black      |     35 | inch     |      88.9
 sl4        |        8 | black      |     40 | inch     |     101.6
 sl5        |        4 | brown      |      1 | m        |       100
 sl6        |       20 | brown      |     .9 | m        |        90
 sl7        |        6 | brown      |     60 | cm       |        60
 sl8        |       21 | brown      |     40 | inch     |     101.6
(8 rows)

SELECT * FROM shoelace_log ORDER BY sl_name;
  sl_name   | sl_avail | log_who  |         log_when         
------------+----------+----------+--------------------------
 sl3        |       10 | Al Bundy | Thu Jan 01 00:00:00 1970
 sl6        |       20 | Al Bundy | Thu Jan 01 00:00:00 1970
 sl7        |        6 | Al Bundy | Thu Jan 01 00:00:00 1970
 sl8        |       21 | Al Bundy | Thu Jan 01 00:00:00 1970
(4 rows)

    CREATE VIEW shoelace_obsolete AS
	SELECT * FROM shoelace WHERE NOT EXISTS
	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
    CREATE VIEW shoelace_candelete AS
	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl9        |        0 | pink       |     35 | inch     |      88.9
 sl10       |     1000 | magenta    |     40 | inch     |     101.6
(2 rows)

SELECT * FROM shoelace_candelete;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl9        |        0 | pink       |     35 | inch     |      88.9
(1 row)

DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_candelete
             WHERE sl_name = shoelace.sl_name);
SELECT * FROM shoelace ORDER BY sl_name;
  sl_name   | sl_avail |  sl_color  | sl_len | sl_unit  | sl_len_cm 
------------+----------+------------+--------+----------+-----------
 sl1        |        5 | black      |     80 | cm       |        80
 sl10       |     1000 | magenta    |     40 | inch     |     101.6
 sl2        |        6 | black      |    100 | cm       |       100
 sl3        |       10 | black      |     35 | inch     |      88.9
 sl4        |        8 | black      |     40 | inch     |     101.6
 sl5        |        4 | brown      |      1 | m        |       100
 sl6        |       20 | brown      |     .9 | m        |        90
 sl7        |        6 | brown      |     60 | cm       |        60
 sl8        |       21 | brown      |     40 | inch     |     101.6
(9 rows)

SELECT * FROM shoe ORDER BY shoename;
  shoename  | sh_avail |  slcolor   | slminlen | slminlen_cm | slmaxlen | slmaxlen_cm |  slunit  
------------+----------+------------+----------+-------------+----------+-------------+----------
 sh1        |        2 | black      |       70 |          70 |       90 |          90 | cm      
 sh2        |        0 | black      |       30 |        76.2 |       40 |       101.6 | inch    
 sh3        |        4 | brown      |       50 |          50 |       65 |          65 | cm      
 sh4        |        3 | brown      |       40 |       101.6 |       50 |         127 | inch    
(4 rows)

SELECT count(*) FROM shoe;
 count 
-------
     4
(1 row)

--
-- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
--
create table foo (f1 int);
create table foo2 (f1 int);
create rule foorule as on insert to foo where f1 < 100
do instead nothing;
insert into foo values(1);
insert into foo values(1001);
select * from foo order by f1;
  f1  
------
 1001
(1 row)

drop rule foorule on foo;
-- this should fail because f1 is not exposed for unqualified reference:
create rule foorule as on insert to foo where f1 < 100
do instead insert into foo2 values (f1);
ERROR:  column "f1" does not exist
LINE 2: do instead insert into foo2 values (f1);
                                            ^
-- this is the correct way:
create rule foorule as on insert to foo where f1 < 100
do instead insert into foo2 values (new.f1);
insert into foo values(2);
insert into foo values(100);
select * from foo order by f1;
  f1  
------
  100
 1001
(2 rows)

select * from foo2 order by f1;
 f1 
----
  2
(1 row)

drop rule foorule on foo;
drop table foo;
drop table foo2;
--
-- Test rules containing INSERT ... SELECT, which is a very ugly special
-- case as of 7.1.  Example is based on bug report from Joel Burton.
--
create table pparent (pid int, txt text);
insert into pparent values (1,'parent1');
insert into pparent values (2,'parent2');
create table cchild (pid int, descrip text);
insert into cchild values (1,'descrip1');
create view vview as
  select pparent.pid, txt, descrip from
    pparent left join cchild using (pid);
create rule rrule as
  on update to vview do instead
(
  insert into cchild (pid, descrip)
    select old.pid, new.descrip where old.descrip isnull;
  update cchild set descrip = new.descrip where cchild.pid = old.pid;
);
select * from vview order by pid;
 pid |   txt   | descrip  
-----+---------+----------
   1 | parent1 | descrip1
   2 | parent2 | 
(2 rows)

update vview set descrip='test1' where pid=1;
select * from vview order by pid;
 pid |   txt   | descrip 
-----+---------+---------
   1 | parent1 | test1
   2 | parent2 | 
(2 rows)

update vview set descrip='test2' where pid=2;
select * from vview order by pid;
 pid |   txt   | descrip 
-----+---------+---------
   1 | parent1 | test1
   2 | parent2 | test2
(2 rows)

update vview set descrip='test3' where pid=3;
select * from vview order by pid;
 pid |   txt   | descrip 
-----+---------+---------
   1 | parent1 | test1
   2 | parent2 | test2
(2 rows)

select * from cchild order by pid;
 pid | descrip 
-----+---------
   1 | test1
   2 | test2
(2 rows)

drop rule rrule on vview;
drop view vview;
drop table pparent;
drop table cchild;
--
-- Check that ruleutils are working
--
SELECT viewname, definition FROM pg_views WHERE schemaname <> 'information_schema' ORDER BY viewname;
            viewname             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   definition                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 all_all_tables                  | SELECT ad.rolname AS owner, cs.relname AS table_name, ts.spcname AS tablespace_name FROM ((pg_class cs LEFT JOIN pg_authid ad ON ((ad.oid = cs.relowner))) LEFT JOIN pg_tablespace ts ON ((cs.reltablespace = ts.oid))) WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'f'::"char"])) AND ((pg_has_role(cs.relowner, 'usage'::text) OR has_table_privilege(cs.oid, 'select, insert, update, delete, truncate, references, trigger'::text)) OR has_any_column_privilege(cs.oid, 'select, insert, update, references'::text)));
 all_all_tables                  | SELECT ad.rolname AS owner, cs.relname AS table_name, ts.spcname AS tablespace_name FROM ((pg_class cs LEFT JOIN pg_authid ad ON ((ad.oid = cs.relowner))) LEFT JOIN pg_tablespace ts ON ((cs.reltablespace = ts.oid))) WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 't'::"char", 'f'::"char"])) AND ((pg_has_role(cs.relowner, 'usage'::text) OR has_table_privilege(cs.oid, 'select, insert, update, delete, truncate, references, trigger'::text)) OR has_any_column_privilege(cs.oid, 'select, insert, update, references'::text)));
 all_col_comments                | SELECT dba_tab_columns.column_name, dba_tab_columns.table_name, dba_tab_columns.owner, dba_tab_columns.comments FROM dba_tab_columns;
 all_col_comments                | SELECT dba_tab_columns.column_name, dba_tab_columns.table_name, dba_tab_columns.owner, dba_tab_columns.comments FROM dba_tab_columns;
 all_dependencies                | SELECT NULL::character varying(30) AS owner, NULL::character varying(30) AS name, NULL::character varying(17) AS type, NULL::character varying(30) AS referenced_owner, NULL::character varying(64) AS referenced_name, NULL::character varying(17) AS referenced_type, NULL::character varying(128) AS referenced_link_name, NULL::numeric AS schemaid, NULL::character varying(4) AS dependency_type FROM dual;
 all_dependencies                | SELECT NULL::character varying(30) AS owner, NULL::character varying(30) AS name, NULL::character varying(17) AS type, NULL::character varying(30) AS referenced_owner, NULL::character varying(64) AS referenced_name, NULL::character varying(17) AS referenced_type, NULL::character varying(128) AS referenced_link_name, NULL::numeric AS schemaid, NULL::character varying(4) AS dependency_type FROM dual;
 all_objects                     | ((((SELECT pg_get_userbyid(cs.relowner) AS owner, cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'table'::name WHEN (cs.relkind = 'i'::"char") THEN 'index'::name WHEN (cs.relkind = 'S'::"char") THEN 'sequence'::name WHEN (cs.relkind = 'v'::"char") THEN 'view'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) UNION SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name, pc.oid AS object_id, 'procedure'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, re.rulename AS object_name, re.oid AS object_id, 'rule'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class)))) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, tr.tgname AS object_name, tr.oid AS object_id, 'trigger'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid)))) UNION SELECT pg_get_userbyid(te.typowner) AS owner, te.typname AS object_name, te.oid AS object_id, 'type'::name AS object_type, te.typnamespace AS namespace FROM pg_type te) UNION SELECT pg_get_userbyid(op.oprowner) AS owner, op.oprname AS object_name, op.oid AS object_id, 'operator'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op;
 all_objects                     | ((((SELECT pg_get_userbyid(cs.relowner) AS owner, cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'table'::name WHEN (cs.relkind = 'i'::"char") THEN 'index'::name WHEN (cs.relkind = 'S'::"char") THEN 'sequence'::name WHEN (cs.relkind = 'v'::"char") THEN 'view'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) UNION SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name, pc.oid AS object_id, 'procedure'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, re.rulename AS object_name, re.oid AS object_id, 'rule'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class)))) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, tr.tgname AS object_name, tr.oid AS object_id, 'trigger'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid)))) UNION SELECT pg_get_userbyid(te.typowner) AS owner, te.typname AS object_name, te.oid AS object_id, 'type'::name AS object_type, te.typnamespace AS namespace FROM pg_type te) UNION SELECT pg_get_userbyid(op.oprowner) AS owner, op.oprname AS object_name, op.oid AS object_id, 'operator'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op;
 all_procedures                  | SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name FROM pg_proc pc WHERE (pg_has_role(pc.proowner, 'USAGE'::text) OR has_function_privilege(pc.oid, 'EXECUTE'::text));
 all_procedures                  | SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name FROM pg_proc pc WHERE (pg_has_role(pc.proowner, 'USAGE'::text) OR has_function_privilege(pc.oid, 'EXECUTE'::text));
 all_sequences                   | SELECT ns.rolname AS sequence_owner, cs.relname AS sequence_name, (pg_sequence_parameters(cs.oid)).minimum_value AS min_value, (pg_sequence_parameters(cs.oid)).maximum_value AS max_value, (pg_sequence_parameters(cs.oid)).increment AS increment_by, CASE WHEN (pg_sequence_parameters(cs.oid)).cycle_option THEN 'y'::character(1) ELSE 'n'::character(1) END AS cycle_flag FROM (pg_class cs LEFT JOIN pg_authid ns ON ((cs.relowner = ns.oid))) WHERE (((cs.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(ns.oid))) AND (pg_has_role(cs.relowner, 'USAGE'::text) OR has_sequence_privilege(cs.oid, 'SELECT, UPDATE, USAGE'::text)));
 all_sequences                   | SELECT ns.rolname AS sequence_owner, cs.relname AS sequence_name, (pg_sequence_parameters(cs.oid)).minimum_value AS min_value, (pg_sequence_parameters(cs.oid)).maximum_value AS max_value, (pg_sequence_parameters(cs.oid)).increment AS increment_by, CASE WHEN (pg_sequence_parameters(cs.oid)).cycle_option THEN 'y'::character(1) ELSE 'n'::character(1) END AS cycle_flag FROM (pg_class cs LEFT JOIN pg_authid ns ON ((cs.relowner = ns.oid))) WHERE (((cs.relkind = 'S'::"char") AND (NOT pg_is_other_temp_schema(ns.oid))) AND (pg_has_role(cs.relowner, 'USAGE'::text) OR has_sequence_privilege(cs.oid, 'SELECT, UPDATE, USAGE'::text)));
 all_source                      | SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS name, 'procedure'::name AS type, pc.prosrc AS text FROM pg_proc pc WHERE (pg_has_role(pc.proowner, 'USAGE'::text) OR has_function_privilege(pc.oid, 'EXECUTE'::text));
 all_source                      | SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS name, 'procedure'::name AS type, pc.prosrc AS text FROM pg_proc pc WHERE (pg_has_role(pc.proowner, 'USAGE'::text) OR has_function_privilege(pc.oid, 'EXECUTE'::text));
 all_tab_columns                 | SELECT dba_tab_columns.owner, dba_tab_columns.table_name, dba_tab_columns.column_name, dba_tab_columns.data_type, dba_tab_columns.column_id, dba_tab_columns.data_length FROM dba_tab_columns;
 all_tab_columns                 | SELECT dba_tab_columns.owner, dba_tab_columns.table_name, dba_tab_columns.column_name, dba_tab_columns.data_type, dba_tab_columns.column_id, dba_tab_columns.data_length FROM dba_tab_columns;
 all_tables                      | SELECT ad.rolname AS owner, cs.relname AS table_name, ts.spcname AS tablespace_name, CASE WHEN ((cs.relpersistence = 't'::"char") OR (cs.relpersistence = 'g'::"char")) THEN 'y'::character(1) ELSE 'n'::character(1) END AS temporary, 'no'::character varying AS dropped FROM ((pg_class cs LEFT JOIN pg_authid ad ON ((ad.oid = cs.relowner))) LEFT JOIN pg_tablespace ts ON ((ts.oid = cs.reltablespace))) WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) AND ((pg_has_role(cs.relowner, 'usage'::text) OR has_table_privilege(cs.oid, 'select, insert, update, delete, truncate, references, trigger'::text)) OR has_any_column_privilege(cs.oid, 'select, insert, update, references'::text)));
 all_tables                      | SELECT ad.rolname AS owner, cs.relname AS table_name, ts.spcname AS tablespace_name, CASE WHEN ((cs.relpersistence = 't'::"char") OR (cs.relpersistence = 'g'::"char")) THEN 'y'::character(1) ELSE 'n'::character(1) END AS temporary, 'no'::character varying AS dropped FROM ((pg_class cs LEFT JOIN pg_authid ad ON ((ad.oid = cs.relowner))) LEFT JOIN pg_tablespace ts ON ((ts.oid = cs.reltablespace))) WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) AND ((pg_has_role(cs.relowner, 'usage'::text) OR has_table_privilege(cs.oid, 'select, insert, update, delete, truncate, references, trigger'::text)) OR has_any_column_privilege(cs.oid, 'select, insert, update, references'::text)));
 all_users                       | SELECT ad.rolname AS username, ad.oid AS user_id FROM pg_authid ad;
 all_users                       | SELECT ad.rolname AS username, ad.oid AS user_id FROM pg_authid ad;
 all_views                       | SELECT pg_get_userbyid(c.relowner) AS owner, c.relname AS view_name, length(pg_get_viewdef(c.oid)) AS text_length, pg_get_viewdef(c.oid) AS text FROM pg_class c WHERE (c.relkind = 'v'::"char");
 all_views                       | SELECT pg_get_userbyid(c.relowner) AS owner, c.relname AS view_name, length(pg_get_viewdef(c.oid)) AS text_length, pg_get_viewdef(c.oid) AS text FROM pg_class c WHERE (c.relkind = 'v'::"char");
 dba_data_files                  | SELECT pg_tablespace.spcname AS tablespace_name, (pg_tablespace_size(pg_tablespace.spcname))::double precision AS bytes FROM pg_tablespace;
 dba_data_files                  | SELECT pg_tablespace.spcname AS tablespace_name, (pg_tablespace_size(pg_tablespace.spcname))::double precision AS bytes FROM pg_tablespace;
 dba_ind_partitions              | SELECT (a.rolname)::character varying(64) AS index_owner, (n.nspname)::character varying(64) AS schema, (ci.relname)::character varying(64) AS index_name, (pi.relname)::character varying(64) AS partition_name, pi.indisusable AS index_partition_usable, array_to_string(pt.boundaries, ','::text, 'MAXVALUE'::text) AS high_value, CASE WHEN (pi.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (pi.reltablespace = spc.oid)) END AS def_tablespace_name FROM pg_class ci, pg_partition pi, pg_partition pt, pg_authid a, pg_namespace n WHERE ((((((ci.parttype = 'p'::"char") AND (ci.relkind = 'i'::"char")) AND (ci.oid = pi.parentid)) AND (pi.indextblid = pt.oid)) AND (ci.relowner = a.oid)) AND (ci.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), (ci.relname)::character varying(64), (pi.relname)::character varying(64), array_to_string(pt.boundaries, ','::text, 'MAXVALUE'::text), CASE WHEN (pi.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (pi.reltablespace = spc.oid)) END;
 dba_ind_partitions              | SELECT (a.rolname)::character varying(64) AS index_owner, (n.nspname)::character varying(64) AS schema, (ci.relname)::character varying(64) AS index_name, (pi.relname)::character varying(64) AS partition_name, pi.indisusable AS index_partition_usable, array_to_string(pt.boundaries, ','::text, 'MAXVALUE'::text) AS high_value, CASE WHEN (pi.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (pi.reltablespace = spc.oid)) END AS def_tablespace_name FROM pg_class ci, pg_partition pi, pg_partition pt, pg_authid a, pg_namespace n WHERE ((((((ci.parttype = 'p'::"char") AND (ci.relkind = 'i'::"char")) AND (ci.oid = pi.parentid)) AND (pi.indextblid = pt.oid)) AND (ci.relowner = a.oid)) AND (ci.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), (ci.relname)::character varying(64), (pi.relname)::character varying(64), array_to_string(pt.boundaries, ','::text, 'MAXVALUE'::text), CASE WHEN (pi.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (pi.reltablespace = spc.oid)) END;
 dba_indexes                     | SELECT (n.rolname)::character varying(64) AS owner, (c.relname)::character varying(64) AS index_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'i'::"char");
 dba_indexes                     | SELECT (n.rolname)::character varying(64) AS owner, (c.relname)::character varying(64) AS index_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'i'::"char");
 dba_objects                     | ((((SELECT pg_get_userbyid(cs.relowner) AS owner, cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'TABLE'::name WHEN (cs.relkind = 'i'::"char") THEN 'INDEX'::name WHEN (cs.relkind = 'S'::"char") THEN 'SEQUENCE'::name WHEN (cs.relkind = 'v'::"char") THEN 'VIEW'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) UNION SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name, pc.oid AS object_id, 'PROCEDURE'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, re.rulename AS object_name, re.oid AS object_id, 'RULE'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class)))) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, tr.tgname AS object_name, tr.oid AS object_id, 'TRIGGER'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid)))) UNION SELECT pg_get_userbyid(te.typowner) AS owner, te.typname AS object_name, te.oid AS object_id, 'TYPE'::name AS object_type, te.typnamespace AS namespace FROM pg_type te) UNION SELECT pg_get_userbyid(op.oprowner) AS owner, op.oprname AS object_name, op.oid AS object_id, 'OPERATOR'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op;
 dba_objects                     | ((((SELECT pg_get_userbyid(cs.relowner) AS owner, cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'TABLE'::name WHEN (cs.relkind = 'i'::"char") THEN 'INDEX'::name WHEN (cs.relkind = 'S'::"char") THEN 'SEQUENCE'::name WHEN (cs.relkind = 'v'::"char") THEN 'VIEW'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) UNION SELECT pg_get_userbyid(pc.proowner) AS owner, pc.proname AS object_name, pc.oid AS object_id, 'PROCEDURE'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, re.rulename AS object_name, re.oid AS object_id, 'RULE'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class)))) UNION SELECT pg_get_userbyid(cs.relowner) AS owner, tr.tgname AS object_name, tr.oid AS object_id, 'TRIGGER'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid)))) UNION SELECT pg_get_userbyid(te.typowner) AS owner, te.typname AS object_name, te.oid AS object_id, 'TYPE'::name AS object_type, te.typnamespace AS namespace FROM pg_type te) UNION SELECT pg_get_userbyid(op.oprowner) AS owner, op.oprname AS object_name, op.oid AS object_id, 'OPERATOR'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op;
 dba_part_indexes                | SELECT (a.rolname)::character varying(64) AS index_owner, (n.nspname)::character varying(64) AS schema, (ci.relname)::character varying(64) AS index_name, (ct.relname)::character varying(64) AS table_name, CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END AS partitioning_type, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = ct.oid) AND (ps.parttype = 'p'::"char"))) AS partition_count, CASE WHEN (ci.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (ci.reltablespace = spc.oid)) END AS def_tablespace_name, array_length(p.partkey, 1) AS partitioning_key_count FROM pg_class ct, pg_class ci, pg_index i, pg_partition p, pg_authid a, pg_namespace n WHERE ((((((((ci.parttype = 'p'::"char") AND (ci.relkind = 'i'::"char")) AND (ci.oid = i.indexrelid)) AND (ct.oid = i.indrelid)) AND (ct.oid = p.parentid)) AND (p.parttype = 'r'::"char")) AND (ci.relowner = a.oid)) AND (ci.relnamespace = n.oid)) ORDER BY (ct.relname)::character varying(64), (n.nspname)::character varying(64), (ci.relname)::character varying(64), CASE WHEN (ci.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (ci.reltablespace = spc.oid)) END, (a.rolname)::character varying(64);
 dba_part_indexes                | SELECT (a.rolname)::character varying(64) AS index_owner, (n.nspname)::character varying(64) AS schema, (ci.relname)::character varying(64) AS index_name, (ct.relname)::character varying(64) AS table_name, CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END AS partitioning_type, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = ct.oid) AND (ps.parttype = 'p'::"char"))) AS partition_count, CASE WHEN (ci.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (ci.reltablespace = spc.oid)) END AS def_tablespace_name, array_length(p.partkey, 1) AS partitioning_key_count FROM pg_class ct, pg_class ci, pg_index i, pg_partition p, pg_authid a, pg_namespace n WHERE ((((((((ci.parttype = 'p'::"char") AND (ci.relkind = 'i'::"char")) AND (ci.oid = i.indexrelid)) AND (ct.oid = i.indrelid)) AND (ct.oid = p.parentid)) AND (p.parttype = 'r'::"char")) AND (ci.relowner = a.oid)) AND (ci.relnamespace = n.oid)) ORDER BY (ct.relname)::character varying(64), (n.nspname)::character varying(64), (ci.relname)::character varying(64), CASE WHEN (ci.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (ci.reltablespace = spc.oid)) END, (a.rolname)::character varying(64);
 dba_part_tables                 | SELECT (a.rolname)::character varying(64) AS table_owner, (n.nspname)::character varying(64) AS schema, (c.relname)::character varying(64) AS table_name, CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END AS partitioning_type, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = c.oid) AND (ps.parttype = 'p'::"char"))) AS partition_count, CASE WHEN (c.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (c.reltablespace = spc.oid)) END AS def_tablespace_name, array_length(p.partkey, 1) AS partitioning_key_count FROM pg_class c, pg_partition p, pg_authid a, pg_namespace n WHERE ((((((c.parttype = 'p'::"char") AND (c.relkind = 'r'::"char")) AND (c.oid = p.parentid)) AND (p.parttype = 'r'::"char")) AND (c.relowner = a.oid)) AND (c.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = c.oid) AND (ps.parttype = 'p'::"char"))), CASE WHEN (c.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (c.reltablespace = spc.oid)) END, array_length(p.partkey, 1);
 dba_part_tables                 | SELECT (a.rolname)::character varying(64) AS table_owner, (n.nspname)::character varying(64) AS schema, (c.relname)::character varying(64) AS table_name, CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END AS partitioning_type, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = c.oid) AND (ps.parttype = 'p'::"char"))) AS partition_count, CASE WHEN (c.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (c.reltablespace = spc.oid)) END AS def_tablespace_name, array_length(p.partkey, 1) AS partitioning_key_count FROM pg_class c, pg_partition p, pg_authid a, pg_namespace n WHERE ((((((c.parttype = 'p'::"char") AND (c.relkind = 'r'::"char")) AND (c.oid = p.parentid)) AND (p.parttype = 'r'::"char")) AND (c.relowner = a.oid)) AND (c.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), CASE WHEN (p.partstrategy = 'r'::"char") THEN 'RANGE'::text WHEN (p.partstrategy = 'i'::"char") THEN 'INTERVAL'::text ELSE (p.partstrategy)::text END, (SELECT count(*) AS count FROM pg_partition ps WHERE ((ps.parentid = c.oid) AND (ps.parttype = 'p'::"char"))), CASE WHEN (c.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (c.reltablespace = spc.oid)) END, array_length(p.partkey, 1);
 dba_procedures                  | SELECT (n.rolname)::character varying(64) AS owner, (f.proname)::character varying(64) AS object_name, f.pronargs AS argument_number FROM (pg_proc f LEFT JOIN pg_authid n ON ((n.oid = f.proowner)));
 dba_procedures                  | SELECT (n.rolname)::character varying(64) AS owner, (f.proname)::character varying(64) AS object_name, f.pronargs AS argument_number FROM (pg_proc f LEFT JOIN pg_authid n ON ((n.oid = f.proowner)));
 dba_sequences                   | SELECT (n.rolname)::character varying(64) AS sequence_owner, (c.relname)::character varying(64) AS sequence_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'S'::"char");
 dba_sequences                   | SELECT (n.rolname)::character varying(64) AS sequence_owner, (c.relname)::character varying(64) AS sequence_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'S'::"char");
 dba_source                      | SELECT (n.rolname)::character varying(64) AS owner, (f.proname)::character varying(64) AS name, f.prosrc AS text FROM (pg_proc f LEFT JOIN pg_authid n ON ((n.oid = f.proowner)));
 dba_source                      | SELECT (n.rolname)::character varying(64) AS owner, (f.proname)::character varying(64) AS name, f.prosrc AS text FROM (pg_proc f LEFT JOIN pg_authid n ON ((n.oid = f.proowner)));
 dba_tab_columns                 | SELECT tbl.owner, tbl.table_name, tbl.column_name, tbl.data_type, tbl.column_id, tbl.data_length, tbl.comments FROM (SELECT tmp.attrelid, tmp.attnum, tmp.owner, tmp.table_name, tmp.column_name, tmp.data_type, tmp.column_id, tmp.data_length, des.description AS comments FROM ((SELECT col.attrelid, col.attnum, (owner.rolname)::character varying(64) AS owner, (tbl.relname)::character varying(64) AS table_name, (col.attname)::character varying(64) AS column_name, (pg_type.typname)::character varying(128) AS data_type, (col.attnum)::integer AS column_id, CASE ((col.attlen < 0) AND (col.atttypid = (1043)::oid)) WHEN true THEN (col.atttypmod - 4) ELSE (col.attlen)::integer END AS data_length FROM pg_attribute col, pg_class tbl, pg_authid owner, pg_type WHERE (((((col.attrelid = tbl.oid) AND (tbl.relowner = owner.oid)) AND (col.atttypid = pg_type.oid)) AND (col.attnum > 0)) AND (tbl.relkind = 'r'::"char"))) tmp LEFT JOIN pg_description des ON (((tmp.attrelid = des.objoid) AND (tmp.attnum = des.objsubid))))) tbl;
 dba_tab_columns                 | SELECT tbl.owner, tbl.table_name, tbl.column_name, tbl.data_type, tbl.column_id, tbl.data_length, tbl.comments FROM (SELECT tmp.attrelid, tmp.attnum, tmp.owner, tmp.table_name, tmp.column_name, tmp.data_type, tmp.column_id, tmp.data_length, des.description AS comments FROM ((SELECT col.attrelid, col.attnum, (owner.rolname)::character varying(64) AS owner, (tbl.relname)::character varying(64) AS table_name, (col.attname)::character varying(64) AS column_name, (pg_type.typname)::character varying(128) AS data_type, (col.attnum)::integer AS column_id, CASE ((col.attlen < 0) AND (col.atttypid = (1043)::oid)) WHEN true THEN (col.atttypmod - 4) ELSE (col.attlen)::integer END AS data_length FROM pg_attribute col, pg_class tbl, pg_authid owner, pg_type WHERE (((((col.attrelid = tbl.oid) AND (tbl.relowner = owner.oid)) AND (col.atttypid = pg_type.oid)) AND (col.attnum > 0)) AND (tbl.relkind = 'r'::"char"))) tmp LEFT JOIN pg_description des ON (((tmp.attrelid = des.objoid) AND (tmp.attnum = des.objsubid))))) tbl;
 dba_tab_partitions              | SELECT (a.rolname)::character varying(64) AS table_owner, (n.nspname)::character varying(64) AS schema, (c.relname)::character varying(64) AS table_name, (p.relname)::character varying(64) AS partition_name, array_to_string(p.boundaries, ','::text, 'MAXVALUE'::text) AS high_value, CASE WHEN (p.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (p.reltablespace = spc.oid)) END AS tablespace_name FROM pg_class c, pg_partition p, pg_authid a, pg_namespace n WHERE ((((p.parentid = c.oid) AND (p.parttype = 'p'::"char")) AND (c.relowner = a.oid)) AND (c.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), (c.relname)::character varying(64), (p.relname)::character varying(64), array_to_string(p.boundaries, ','::text, 'MAXVALUE'::text), CASE WHEN (p.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (p.reltablespace = spc.oid)) END;
 dba_tab_partitions              | SELECT (a.rolname)::character varying(64) AS table_owner, (n.nspname)::character varying(64) AS schema, (c.relname)::character varying(64) AS table_name, (p.relname)::character varying(64) AS partition_name, array_to_string(p.boundaries, ','::text, 'MAXVALUE'::text) AS high_value, CASE WHEN (p.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (p.reltablespace = spc.oid)) END AS tablespace_name FROM pg_class c, pg_partition p, pg_authid a, pg_namespace n WHERE ((((p.parentid = c.oid) AND (p.parttype = 'p'::"char")) AND (c.relowner = a.oid)) AND (c.relnamespace = n.oid)) ORDER BY (a.rolname)::character varying(64), (n.nspname)::character varying(64), (c.relname)::character varying(64), (p.relname)::character varying(64), array_to_string(p.boundaries, ','::text, 'MAXVALUE'::text), CASE WHEN (p.reltablespace = (0)::oid) THEN ('DEFAULT TABLESPACE'::text)::name ELSE (SELECT spc.spcname FROM pg_tablespace spc WHERE (p.reltablespace = spc.oid)) END;
 dba_tables                      | SELECT tbl.owner, tbl.table_name, tbl.tablespace_name, tbl.status, tbl.temporary, tbl.dropped FROM (SELECT (c.rolname)::character varying(64) AS owner, (a.relname)::character varying(64) AS table_name, (b.spcname)::character varying(64) AS tablespace_name, 'valid'::character varying(8) AS status, CASE WHEN ((a.relpersistence = 't'::"char") OR (a.relpersistence = 'g'::"char")) THEN 'y'::character(1) ELSE 'n'::character(1) END AS temporary, 'no'::character varying AS dropped FROM pg_class a, pg_tablespace b, pg_authid c WHERE ((((a.reltablespace = b.oid) OR ((a.reltablespace = (0)::oid) AND (b.spcname = 'pg_default'::name))) AND (a.relowner = c.oid)) AND (a.relkind = 'r'::"char"))) tbl ORDER BY tbl.owner, tbl.table_name;
 dba_tables                      | SELECT tbl.owner, tbl.table_name, tbl.tablespace_name, tbl.status, tbl.temporary, tbl.dropped FROM (SELECT (c.rolname)::character varying(64) AS owner, (a.relname)::character varying(64) AS table_name, (b.spcname)::character varying(64) AS tablespace_name, 'valid'::character varying(8) AS status, CASE WHEN ((a.relpersistence = 't'::"char") OR (a.relpersistence = 'g'::"char")) THEN 'y'::character(1) ELSE 'n'::character(1) END AS temporary, 'no'::character varying AS dropped FROM pg_class a, pg_tablespace b, pg_authid c WHERE ((((a.reltablespace = b.oid) OR ((a.reltablespace = (0)::oid) AND (b.spcname = 'pg_default'::name))) AND (a.relowner = c.oid)) AND (a.relkind = 'r'::"char"))) tbl ORDER BY tbl.owner, tbl.table_name;
 dba_tablespaces                 | SELECT (pg_tablespace.spcname)::character varying(64) AS tablespace_name FROM pg_tablespace;
 dba_tablespaces                 | SELECT (pg_tablespace.spcname)::character varying(64) AS tablespace_name FROM pg_tablespace;
 dba_triggers                    | SELECT (t.tgname)::character varying(64) AS trigger_name, (c.relname)::character varying(64) AS table_name, (n.rolname)::character varying(64) AS table_owner FROM ((pg_trigger t LEFT JOIN pg_class c ON ((t.tgrelid = c.oid))) LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'r'::"char");
 dba_triggers                    | SELECT (t.tgname)::character varying(64) AS trigger_name, (c.relname)::character varying(64) AS table_name, (n.rolname)::character varying(64) AS table_owner FROM ((pg_trigger t LEFT JOIN pg_class c ON ((t.tgrelid = c.oid))) LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'r'::"char");
 dba_users                       | SELECT (pg_authid.rolname)::character varying(64) AS username FROM pg_authid;
 dba_users                       | SELECT (pg_authid.rolname)::character varying(64) AS username FROM pg_authid;
 dba_views                       | SELECT (n.rolname)::character varying(64) AS owner, (c.relname)::character varying(64) AS view_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'v'::"char");
 dba_views                       | SELECT (n.rolname)::character varying(64) AS owner, (c.relname)::character varying(64) AS view_name FROM (pg_class c LEFT JOIN pg_authid n ON ((n.oid = c.relowner))) WHERE (c.relkind = 'v'::"char");
 dual                            | SELECT 'X'::text AS dummy;
 gs_stat_db_cu                   | SELECT DISTINCT gs_get_stat_db_cu.node_name1, gs_get_stat_db_cu.db_name, gs_get_stat_db_cu.mem_hit, gs_get_stat_db_cu.hdd_sync_read, gs_get_stat_db_cu.hdd_asyn_read FROM gs_get_stat_db_cu() gs_get_stat_db_cu(node_name1, db_name, mem_hit, hdd_sync_read, hdd_asyn_read);
 gs_stat_session_cu              | SELECT DISTINCT gs_get_stat_session_cu.node_name1, gs_get_stat_session_cu.mem_hit, gs_get_stat_session_cu.hdd_sync_read, gs_get_stat_session_cu.hdd_asyn_read FROM gs_get_stat_session_cu() gs_get_stat_session_cu(node_name1, mem_hit, hdd_sync_read, hdd_asyn_read);
 iexit                           | SELECT ih.name, ih.thepath, interpt_pp(ih.thepath, r.thepath) AS exit FROM ihighway ih, ramp r WHERE (ih.thepath ## r.thepath);
 pg_available_extension_versions | SELECT e.name, e.version, (x.extname IS NOT NULL) AS installed, e.superuser, e.relocatable, e.schema, e.requires, e.comment FROM (pg_available_extension_versions() e(name, version, superuser, relocatable, schema, requires, comment) LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));
 pg_available_extensions         | SELECT e.name, e.default_version, x.extversion AS installed_version, e.comment FROM (pg_available_extensions() e(name, default_version, comment) LEFT JOIN pg_extension x ON ((e.name = x.extname)));
 pg_comm_recv_stream             | SELECT s.node_name, s.local_tid, s.remote_name, s.remote_tid, s.idx, s.sid, s.tcp_sock, s.state, s.query_id, s.plan_id, s.pn_id, send_smp, recv_smp, s.recv_bytes, s."time", s.speed, s.quota, s.buff_usize FROM pg_comm_recv_stream() s(node_name, local_tid, remote_name, remote_tid, idx, sid, tcp_sock, state, query_id, plan_id, pn_id, send_smp, recv_smp, recv_bytes, "time", speed, quota, buff_usize);
 pg_comm_send_stream             | SELECT s.node_name, s.local_tid, s.remote_name, s.remote_tid, s.idx, s.sid, s.tcp_sock, s.state, s.query_id, s.plan_id, s.pn_id, send_smp, recv_smp, s.send_bytes, s."time", s.speed, s.quota, s.wait_quota FROM pg_comm_send_stream() s(node_name, local_tid, remote_name, remote_tid, idx, sid, tcp_sock, state, query_id, plan_id, pn_id, send_smp, recv_smp, send_bytes, "time", speed, quota, wait_quota);
 pg_comm_status                  | SELECT s.node_name, s.recv_speed, s.send_speed, s.mem_used FROM pg_comm_status() s(node_name, recv_speed, min_recv_idx, max_recv_idx, send_speed, min_send_idx, max_send_idx, mem_used);
 pg_control_group_config         | SELECT pg_control_group_config.pg_control_group_config FROM pg_control_group_config() pg_control_group_config(pg_control_group_config);
 pg_cursors                      | SELECT c.name, c.statement, c.is_holdable, c.is_binary, c.is_scrollable, c.creation_time FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);
 pg_get_invalid_backends         | SELECT c.pid, c.node_name, s.datname AS dbname, s.backend_start, s.query FROM (pg_pool_validate(false) c(pid, node_name) LEFT JOIN pg_stat_activity s ON ((c.pid = s.pid)));
 pg_get_senders_catchup_time     | SELECT w.pid, w.sender_pid AS lwpid, w.local_role, w.peer_role, w.state, 'Wal'::text AS type, w.catchup_start, w.catchup_end FROM pg_stat_get_wal_senders() w(pid, sender_pid, local_role, peer_role, peer_state, state, catchup_start, catchup_end, sender_sent_location, sender_write_location, sender_flush_location, sender_replay_location, receiver_received_location, receiver_write_location, receiver_flush_location, receiver_replay_location, sync_percent, sync_state, sync_priority, sync_most_available, channel) UNION ALL SELECT d.pid, d.sender_pid AS lwpid, d.local_role, d.peer_role, d.state, 'Data'::text AS type, d.catchup_start, d.catchup_end FROM pg_stat_get_data_senders() d(pid, sender_pid, local_role, peer_role, state, catchup_start, catchup_end, queue_size, queue_lower_tail, queue_header, queue_upper_tail, send_position, receive_position);
 pg_group                        | SELECT pg_authid.rolname AS groname, pg_authid.oid AS grosysid, ARRAY(SELECT pg_auth_members.member FROM pg_auth_members WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist FROM pg_authid WHERE (NOT pg_authid.rolcanlogin);
 pg_gtt_attached_pids| SELECT n.nspname AS schemaname,
    c.relname AS tablename,
    s.relid,
    s.pid
   FROM (pg_class c
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))),
    LATERAL pg_gtt_attached_pid(c.oid) s(relid, pid)
  WHERE ((c.relpersistence = 'g'::"char") AND (c.relkind = ANY (ARRAY['r'::"char", 'S'::"char"])) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));
pg_gtt_relstats| SELECT n.nspname AS schemaname,
    c.relname AS tablename,
    s.relfilenode,
    s.relpages,
    s.reltuples,
    s.relallvisible,
    s.relfrozenxid,
    s.relminmxid
   FROM (pg_class c
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))),
    LATERAL pg_get_gtt_relstats(c.oid) s(relfilenode, relpages, reltuples, relallvisible, relfrozenxid, relminmxid)
  WHERE ((c.relpersistence = 'g'::"char") AND (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char", 'i'::"char", 't'::"char"])) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));
pg_gtt_stats| SELECT n.nspname AS schemaname,
    c.relname AS tablename,
    a.attname,
    s.stainherit AS inherited,
    s.stanullfrac AS null_frac,
    s.stawidth AS avg_width,
    s.stadistinct AS n_distinct,
        CASE
            WHEN (s.stakind1 = 1) THEN s.stavalues1
            WHEN (s.stakind2 = 1) THEN s.stavalues2
            WHEN (s.stakind3 = 1) THEN s.stavalues3
            WHEN (s.stakind4 = 1) THEN s.stavalues4
            WHEN (s.stakind5 = 1) THEN s.stavalues5
            ELSE NULL::text[]
        END AS most_common_vals,
        CASE
            WHEN (s.stakind1 = 1) THEN s.stanumbers1
            WHEN (s.stakind2 = 1) THEN s.stanumbers2
            WHEN (s.stakind3 = 1) THEN s.stanumbers3
            WHEN (s.stakind4 = 1) THEN s.stanumbers4
            WHEN (s.stakind5 = 1) THEN s.stanumbers5
            ELSE NULL::real[]
        END AS most_common_freqs,
        CASE
            WHEN (s.stakind1 = 2) THEN s.stavalues1
            WHEN (s.stakind2 = 2) THEN s.stavalues2
            WHEN (s.stakind3 = 2) THEN s.stavalues3
            WHEN (s.stakind4 = 2) THEN s.stavalues4
            WHEN (s.stakind5 = 2) THEN s.stavalues5
            ELSE NULL::text[]
        END AS histogram_bounds,
        CASE
            WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]
            WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]
            WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]
            WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]
            WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]
            ELSE NULL::real
        END AS correlation,
        CASE
            WHEN (s.stakind1 = 4) THEN s.stavalues1
            WHEN (s.stakind2 = 4) THEN s.stavalues2
            WHEN (s.stakind3 = 4) THEN s.stavalues3
            WHEN (s.stakind4 = 4) THEN s.stavalues4
            WHEN (s.stakind5 = 4) THEN s.stavalues5
            ELSE NULL::text[]
        END AS most_common_elems,
        CASE
            WHEN (s.stakind1 = 4) THEN s.stanumbers1
            WHEN (s.stakind2 = 4) THEN s.stanumbers2
            WHEN (s.stakind3 = 4) THEN s.stanumbers3
            WHEN (s.stakind4 = 4) THEN s.stanumbers4
            WHEN (s.stakind5 = 4) THEN s.stanumbers5
            ELSE NULL::real[]
        END AS most_common_elem_freqs,
        CASE
            WHEN (s.stakind1 = 5) THEN s.stanumbers1
            WHEN (s.stakind2 = 5) THEN s.stanumbers2
            WHEN (s.stakind3 = 5) THEN s.stanumbers3
            WHEN (s.stakind4 = 5) THEN s.stanumbers4
            WHEN (s.stakind5 = 5) THEN s.stanumbers5
            ELSE NULL::real[]
        END AS elem_count_histogram
   FROM ((pg_class c
     JOIN pg_attribute a ON ((c.oid = a.attrelid)))
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))),
    LATERAL pg_get_gtt_statistics(c.oid, (a.attnum)::integer, ''::text) s(starelid, staattnum, stainherit, stanullfrac, stawidth, stadistinct, stakind1, stakind2, stakind3, stakind4, stakind5, staop1, staop2, staop3, staop4, staop5, stacoll1, stacoll2, stacoll3, stacoll4, stac
  WHERE ((c.relpersistence = 'g'::"char") AND (c.relkind = ANY (ARRAY['r'::"char", 'p'::"char", 'i'::"char", 't'::"char"])) AND (NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));
 pg_indexes                      | SELECT n.nspname AS schemaname, c.relname AS tablename, i.relname AS indexname, t.spcname AS tablespace, pg_get_indexdef(i.oid) AS indexdef FROM ((((pg_index x JOIN pg_class c ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace))) WHERE ((c.relkind = 'r'::"char") AND (i.relkind = 'i'::"char"));
 pg_locks                        | SELECT l.locktype, l.database, l.relation, l.page, l.tuple, l.virtualxid, l.transactionid, l.classid, l.objid, l.objsubid, l.virtualtransaction, l.pid, l.mode, l.granted, l.fastpath FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath);
 pg_node_env                     | SELECT s.node_name, s.host, s.process, s.port, s.installpath, s.datapath, s.log_directory FROM pg_stat_get_env() s(node_name, host, process, port, installpath, datapath, log_directory);
 pg_os_threads                   | SELECT s.node_name, s.pid, s.lwpid, s.thread_name, s.creation_time FROM pg_stat_get_thread() s(node_name, pid, lwpid, thread_name, creation_time);
 pg_pooler_status                | SELECT s.database_name AS database, s.user_name, s.tid, s.node_oid, d.node_name, s.in_use, s.pgoptions FROM pgxc_node d, pg_stat_get_pooler_status() s(database_name, user_name, tid, pgoptions, node_oid, in_use) WHERE (d.oid = (s.node_oid)::oid);
 pg_prepared_statements          | SELECT p.name, p.statement, p.prepare_time, p.parameter_types, p.from_sql FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, from_sql);
 pg_prepared_xacts               | SELECT p.transaction, p.gid, p.prepared, u.rolname AS owner, d.datname AS database FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid) LEFT JOIN pg_authid u ON ((p.ownerid = u.oid))) LEFT JOIN pg_database d ON ((p.dbid = d.oid)));
 pg_replication_slots            | SELECT l.slot_name, l.slot_type, l.datoid, d.datname AS database, l.active, l.xmin, l.restart_lsn, l.dummy_standby FROM (pg_get_replication_slots() l(slot_name, slot_type, datoid, active, xmin, restart_lsn, dummy_standby) LEFT JOIN pg_database d ON ((l.datoid = d.oid)));
 pg_roles                        | SELECT pg_authid.rolname, pg_authid.rolsuper, pg_authid.rolinherit, pg_authid.rolcreaterole, pg_authid.rolcreatedb, pg_authid.rolcatupdate, pg_authid.rolcanlogin, pg_authid.rolreplication, pg_authid.rolauditadmin, pg_authid.rolsystemadmin, pg_authid.rolconnlimit, '********'::text AS rolpassword, pg_authid.rolvalidbegin, pg_authid.rolvaliduntil, pg_authid.rolrespool, s.setconfig AS rolconfig, pg_authid.oid FROM (pg_authid LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));
 pg_rules                        | SELECT n.nspname AS schemaname, c.relname AS tablename, r.rulename, pg_get_ruledef(r.oid) AS definition FROM ((pg_rewrite r JOIN pg_class c ON ((c.oid = r.ev_class))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (r.rulename <> '_RETURN'::name);
 pg_running_xacts                | SELECT pg_get_running_xacts.handle, pg_get_running_xacts.gxid, pg_get_running_xacts.state, pg_get_running_xacts.node, pg_get_running_xacts.xmin, pg_get_running_xacts.vacuum, pg_get_running_xacts.timeline, pg_get_running_xacts.prepare_xid, pg_get_running_xacts.pid FROM pg_get_running_xacts() pg_get_running_xacts(handle, gxid, state, node, xmin, vacuum, timeline, prepare_xid, pid);
 pg_seclabels                    | ((((((((SELECT l.objoid, l.classoid, l.objsubid, CASE WHEN (rel.relkind = 'r'::"char") THEN 'table'::text WHEN (rel.relkind = 'v'::"char") THEN 'view'::text WHEN (rel.relkind = 'S'::"char") THEN 'sequence'::text WHEN (rel.relkind = 'f'::"char") THEN 'foreign table'::text ELSE NULL::text END AS objtype, rel.relnamespace AS objnamespace, CASE WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text) ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text)) END AS objname, l.provider, l.label FROM ((pg_seclabel l JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid)))) JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid))) WHERE (l.objsubid = 0) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, 'column'::text AS objtype, rel.relnamespace AS objnamespace, ((CASE WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text) ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((rel.relname)::text)) END || '.'::text) || (att.attname)::text) AS objname, l.provider, l.label FROM (((pg_seclabel l JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid)))) JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum)))) JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid))) WHERE (l.objsubid <> 0)) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, CASE WHEN (pro.proisagg = true) THEN 'aggregate'::text WHEN (pro.proisagg = false) THEN 'function'::text ELSE NULL::text END AS objtype, pro.pronamespace AS objnamespace, (((CASE WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text) ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((pro.proname)::text)) END || '('::text) || pg_get_function_arguments(pro.oid)) || ')'::text) AS objname, l.provider, l.label FROM ((pg_seclabel l JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid)))) JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid))) WHERE (l.objsubid = 0)) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, CASE WHEN (typ.typtype = 'd'::"char") THEN 'domain'::text ELSE 'type'::text END AS objtype, typ.typnamespace AS objnamespace, CASE WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text) ELSE ((quote_ident((nsp.nspname)::text) || '.'::text) || quote_ident((typ.typname)::text)) END AS objname, l.provider, l.label FROM ((pg_seclabel l JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid)))) JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid))) WHERE (l.objsubid = 0)) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, 'large object'::text AS objtype, NULL::oid AS objnamespace, (l.objoid)::text AS objname, l.provider, l.label FROM (pg_seclabel l JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid))) WHERE ((l.classoid = ('pg_largeobject'::regclass)::oid) AND (l.objsubid = 0))) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, 'language'::text AS objtype, NULL::oid AS objnamespace, quote_ident((lan.lanname)::text) AS objname, l.provider, l.label FROM (pg_seclabel l JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid)))) WHERE (l.objsubid = 0)) UNION ALL SELECT l.objoid, l.classoid, l.objsubid, 'schema'::text AS objtype, nsp.oid AS objnamespace, quote_ident((nsp.nspname)::text) AS objname, l.provider, l.label FROM (pg_seclabel l JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid)))) WHERE (l.objsubid = 0)) UNION ALL SELECT l.objoid, l.classoid, 0 AS objsubid, 'database'::text AS objtype, NULL::oid AS objnamespace, quote_ident((dat.datname)::text) AS objname, l.provider, l.label FROM (pg_shseclabel l JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))) UNION ALL SELECT l.objoid, l.classoid, 0 AS objsubid, 'tablespace'::text AS objtype, NULL::oid AS objnamespace, quote_ident((spc.spcname)::text) AS objname, l.provider, l.label FROM (pg_shseclabel l JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))) UNION ALL SELECT l.objoid, l.classoid, 0 AS objsubid, 'role'::text AS objtype, NULL::oid AS objnamespace, quote_ident((rol.rolname)::text) AS objname, l.provider, l.label FROM (pg_shseclabel l JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));
 pg_session_wlmstat              | SELECT s.datid, d.datname, s.threadid, s.threadpid AS processid, s.usesysid, s.appname, u.rolname AS usename, s.priority, s.attribute, s.block_time, s.elapsed_time, s.total_cpu_time, s.skew_percent AS cpu_skew_percent, s.current_cgroup AS control_group, s.current_status AS status, s.enqueue_state AS enqueue, u.rolrespool AS resource_pool, s.query FROM pg_database d, pg_stat_get_session_wlmstat(NULL::integer) s(datid, threadid, threadpid, usesysid, appname, query, priority, block_time, elapsed_time, total_cpu_time, skew_percent, current_cgroup, current_status, enqueue_state, attribute), pg_authid u WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));
 pg_settings                     | SELECT a.name, a.setting, a.unit, a.category, a.short_desc, a.extra_desc, a.context, a.vartype, a.source, a.min_val, a.max_val, a.enumvals, a.boot_val, a.reset_val, a.sourcefile, a.sourceline FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline);
 pg_shadow                       | SELECT pg_authid.rolname AS usename, pg_authid.oid AS usesysid, pg_authid.rolcreatedb AS usecreatedb, pg_authid.rolsuper AS usesuper, pg_authid.rolcatupdate AS usecatupd, pg_authid.rolreplication AS userepl, pg_authid.rolpassword AS passwd, (pg_authid.rolvalidbegin)::abstime AS valbegin, (pg_authid.rolvaliduntil)::abstime AS valuntil, pg_authid.rolrespool AS respool, s.setconfig AS useconfig FROM (pg_authid LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid)))) WHERE pg_authid.rolcanlogin;
 pg_shared_memory_detail         | SELECT pg_shared_memory_detail.contextname, pg_shared_memory_detail.level, pg_shared_memory_detail.parent, pg_shared_memory_detail.totalsize, pg_shared_memory_detail.freesize, pg_shared_memory_detail.usedsize FROM pg_shared_memory_detail() pg_shared_memory_detail(contextname, level, parent, totalsize, freesize, usedsize);
 pg_stat_activity                | SELECT s.datid, d.datname, s.pid, s.usesysid, u.rolname AS usename, s.application_name, s.client_addr, s.client_hostname, s.client_port, s.backend_start, s.xact_start, s.query_start, s.state_change, s.waiting, s.enqueue, s.state, u.rolrespool AS resource_pool, s.query FROM pg_database d, pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, enqueue), pg_authid u WHERE ((s.datid = d.oid) AND (s.usesysid = u.oid));
 pg_stat_all_indexes             | SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, pg_stat_get_numscans(i.oid) AS idx_scan, pg_stat_get_tuples_returned(i.oid) AS idx_tup_read, pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"]));
 pg_stat_all_tables              | SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, pg_stat_get_numscans(c.oid) AS seq_scan, pg_stat_get_tuples_returned(c.oid) AS seq_tup_read, (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan, ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch, pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins, pg_stat_get_tuples_updated(c.oid) AS n_tup_upd, pg_stat_get_tuples_deleted(c.oid) AS n_tup_del, pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd, pg_stat_get_live_tuples(c.oid) AS n_live_tup, pg_stat_get_dead_tuples(c.oid) AS n_dead_tup, pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum, pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum, pg_stat_get_last_analyze_time(c.oid) AS last_analyze, pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze, pg_stat_get_vacuum_count(c.oid) AS vacuum_count, pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count, pg_stat_get_analyze_count(c.oid) AS analyze_count, pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count FROM ((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])) GROUP BY c.oid, n.nspname, c.relname;
 pg_stat_bgwriter                | SELECT pg_stat_get_bgwriter_timed_checkpoints() AS checkpoints_timed, pg_stat_get_bgwriter_requested_checkpoints() AS checkpoints_req, pg_stat_get_checkpoint_write_time() AS checkpoint_write_time, pg_stat_get_checkpoint_sync_time() AS checkpoint_sync_time, pg_stat_get_bgwriter_buf_written_checkpoints() AS buffers_checkpoint, pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean, pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean, pg_stat_get_buf_written_backend() AS buffers_backend, pg_stat_get_buf_fsync_backend() AS buffers_backend_fsync, pg_stat_get_buf_alloc() AS buffers_alloc, pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;
 pg_stat_database                | SELECT d.oid AS datid, d.datname, pg_stat_get_db_numbackends(d.oid) AS numbackends, pg_stat_get_db_xact_commit(d.oid) AS xact_commit, pg_stat_get_db_xact_rollback(d.oid) AS xact_rollback, (pg_stat_get_db_blocks_fetched(d.oid) - pg_stat_get_db_blocks_hit(d.oid)) AS blks_read, pg_stat_get_db_blocks_hit(d.oid) AS blks_hit, pg_stat_get_db_tuples_returned(d.oid) AS tup_returned, pg_stat_get_db_tuples_fetched(d.oid) AS tup_fetched, pg_stat_get_db_tuples_inserted(d.oid) AS tup_inserted, pg_stat_get_db_tuples_updated(d.oid) AS tup_updated, pg_stat_get_db_tuples_deleted(d.oid) AS tup_deleted, pg_stat_get_db_conflict_all(d.oid) AS conflicts, pg_stat_get_db_temp_files(d.oid) AS temp_files, pg_stat_get_db_temp_bytes(d.oid) AS temp_bytes, pg_stat_get_db_deadlocks(d.oid) AS deadlocks, pg_stat_get_db_blk_read_time(d.oid) AS blk_read_time, pg_stat_get_db_blk_write_time(d.oid) AS blk_write_time, pg_stat_get_mem_mbytes_reserved(d.oid) AS mem_mbytes_reserved, pg_stat_get_db_stat_reset_time(d.oid) AS stats_reset FROM pg_database d;
 pg_stat_database_conflicts      | SELECT d.oid AS datid, d.datname, pg_stat_get_db_conflict_tablespace(d.oid) AS confl_tablespace, pg_stat_get_db_conflict_lock(d.oid) AS confl_lock, pg_stat_get_db_conflict_snapshot(d.oid) AS confl_snapshot, pg_stat_get_db_conflict_bufferpin(d.oid) AS confl_bufferpin, pg_stat_get_db_conflict_startup_deadlock(d.oid) AS confl_deadlock FROM pg_database d;
 pg_stat_replication             | SELECT s.pid, s.usesysid, u.rolname AS usename, s.application_name, s.client_addr, s.client_hostname, s.client_port, s.backend_start, w.state, w.sender_sent_location, w.receiver_write_location, w.receiver_flush_location, w.receiver_replay_location, w.sync_priority, w.sync_state FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, enqueue), pg_authid u, pg_stat_get_wal_senders() w(pid, sender_pid, local_role, peer_role, peer_state, state, catchup_start, catchup_end, sender_sent_location, sender_write_location, sender_flush_location, sender_replay_location, receiver_received_location, receiver_write_location, receiver_flush_location, receiver_replay_location, sync_percent, sync_state, sync_priority, sync_most_available, channel) WHERE ((s.usesysid = u.oid) AND (s.pid = w.sender_pid));
 pg_stat_sys_indexes             | SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE ((pg_stat_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_indexes.schemaname ~ '^pg_toast'::text));
 pg_stat_sys_tables              | SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del, pg_stat_all_tables.n_tup_hot_upd, pg_stat_all_tables.n_live_tup, pg_stat_all_tables.n_dead_tup, pg_stat_all_tables.last_vacuum, pg_stat_all_tables.last_autovacuum, pg_stat_all_tables.last_analyze, pg_stat_all_tables.last_autoanalyze, pg_stat_all_tables.vacuum_count, pg_stat_all_tables.autovacuum_count, pg_stat_all_tables.analyze_count, pg_stat_all_tables.autoanalyze_count FROM pg_stat_all_tables WHERE ((pg_stat_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_all_tables.schemaname ~ '^pg_toast'::text));
 pg_stat_user_functions          | SELECT p.oid AS funcid, n.nspname AS schemaname, p.proname AS funcname, pg_stat_get_function_calls(p.oid) AS calls, pg_stat_get_function_total_time(p.oid) AS total_time, pg_stat_get_function_self_time(p.oid) AS self_time FROM (pg_proc p LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace))) WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));
 pg_stat_user_indexes            | SELECT pg_stat_all_indexes.relid, pg_stat_all_indexes.indexrelid, pg_stat_all_indexes.schemaname, pg_stat_all_indexes.relname, pg_stat_all_indexes.indexrelname, pg_stat_all_indexes.idx_scan, pg_stat_all_indexes.idx_tup_read, pg_stat_all_indexes.idx_tup_fetch FROM pg_stat_all_indexes WHERE ((pg_stat_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_indexes.schemaname !~ '^pg_toast'::text));
 pg_stat_user_tables             | SELECT pg_stat_all_tables.relid, pg_stat_all_tables.schemaname, pg_stat_all_tables.relname, pg_stat_all_tables.seq_scan, pg_stat_all_tables.seq_tup_read, pg_stat_all_tables.idx_scan, pg_stat_all_tables.idx_tup_fetch, pg_stat_all_tables.n_tup_ins, pg_stat_all_tables.n_tup_upd, pg_stat_all_tables.n_tup_del, pg_stat_all_tables.n_tup_hot_upd, pg_stat_all_tables.n_live_tup, pg_stat_all_tables.n_dead_tup, pg_stat_all_tables.last_vacuum, pg_stat_all_tables.last_autovacuum, pg_stat_all_tables.last_analyze, pg_stat_all_tables.last_autoanalyze, pg_stat_all_tables.vacuum_count, pg_stat_all_tables.autovacuum_count, pg_stat_all_tables.analyze_count, pg_stat_all_tables.autoanalyze_count FROM pg_stat_all_tables WHERE ((pg_stat_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_all_tables.schemaname !~ '^pg_toast'::text));
 pg_stat_xact_all_tables         | SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, pg_stat_get_xact_numscans(c.oid) AS seq_scan, pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read, (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan, ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_xact_tuples_fetched(c.oid)) AS idx_tup_fetch, pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins, pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd, pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del, pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd FROM ((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])) GROUP BY c.oid, n.nspname, c.relname;
 pg_stat_xact_sys_tables         | SELECT pg_stat_xact_all_tables.relid, pg_stat_xact_all_tables.schemaname, pg_stat_xact_all_tables.relname, pg_stat_xact_all_tables.seq_scan, pg_stat_xact_all_tables.seq_tup_read, pg_stat_xact_all_tables.idx_scan, pg_stat_xact_all_tables.idx_tup_fetch, pg_stat_xact_all_tables.n_tup_ins, pg_stat_xact_all_tables.n_tup_upd, pg_stat_xact_all_tables.n_tup_del, pg_stat_xact_all_tables.n_tup_hot_upd FROM pg_stat_xact_all_tables WHERE ((pg_stat_xact_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_stat_xact_all_tables.schemaname ~ '^pg_toast'::text));
 pg_stat_xact_user_functions     | SELECT p.oid AS funcid, n.nspname AS schemaname, p.proname AS funcname, pg_stat_get_xact_function_calls(p.oid) AS calls, pg_stat_get_xact_function_total_time(p.oid) AS total_time, pg_stat_get_xact_function_self_time(p.oid) AS self_time FROM (pg_proc p LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace))) WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));
 pg_stat_xact_user_tables        | SELECT pg_stat_xact_all_tables.relid, pg_stat_xact_all_tables.schemaname, pg_stat_xact_all_tables.relname, pg_stat_xact_all_tables.seq_scan, pg_stat_xact_all_tables.seq_tup_read, pg_stat_xact_all_tables.idx_scan, pg_stat_xact_all_tables.idx_tup_fetch, pg_stat_xact_all_tables.n_tup_ins, pg_stat_xact_all_tables.n_tup_upd, pg_stat_xact_all_tables.n_tup_del, pg_stat_xact_all_tables.n_tup_hot_upd FROM pg_stat_xact_all_tables WHERE ((pg_stat_xact_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_stat_xact_all_tables.schemaname !~ '^pg_toast'::text));
 pg_statio_all_indexes           | SELECT c.oid AS relid, i.oid AS indexrelid, n.nspname AS schemaname, c.relname, i.relname AS indexrelname, (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read, pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit FROM (((pg_class c JOIN pg_index x ON ((c.oid = x.indrelid))) JOIN pg_class i ON ((i.oid = x.indexrelid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"]));
 pg_statio_all_sequences         | SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read, pg_stat_get_blocks_hit(c.oid) AS blks_hit FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'S'::"char");
 pg_statio_all_tables            | SELECT c.oid AS relid, n.nspname AS schemaname, c.relname, (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read, pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit, (sum((pg_stat_get_blocks_fetched(i.indexrelid) - pg_stat_get_blocks_hit(i.indexrelid))))::bigint AS idx_blks_read, (sum(pg_stat_get_blocks_hit(i.indexrelid)))::bigint AS idx_blks_hit, (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read, pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit, (pg_stat_get_blocks_fetched(x.oid) - pg_stat_get_blocks_hit(x.oid)) AS tidx_blks_read, pg_stat_get_blocks_hit(x.oid) AS tidx_blks_hit FROM ((((pg_class c LEFT JOIN pg_index i ON ((c.oid = i.indrelid))) LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid))) LEFT JOIN pg_class x ON ((t.reltoastidxid = x.oid))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])) GROUP BY c.oid, n.nspname, c.relname, t.oid, x.oid;
 pg_statio_sys_indexes           | SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE ((pg_statio_all_indexes.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_indexes.schemaname ~ '^pg_toast'::text));
 pg_statio_sys_sequences         | SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE ((pg_statio_all_sequences.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_sequences.schemaname ~ '^pg_toast'::text));
 pg_statio_sys_tables            | SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE ((pg_statio_all_tables.schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (pg_statio_all_tables.schemaname ~ '^pg_toast'::text));
 pg_statio_user_indexes          | SELECT pg_statio_all_indexes.relid, pg_statio_all_indexes.indexrelid, pg_statio_all_indexes.schemaname, pg_statio_all_indexes.relname, pg_statio_all_indexes.indexrelname, pg_statio_all_indexes.idx_blks_read, pg_statio_all_indexes.idx_blks_hit FROM pg_statio_all_indexes WHERE ((pg_statio_all_indexes.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_indexes.schemaname !~ '^pg_toast'::text));
 pg_statio_user_sequences        | SELECT pg_statio_all_sequences.relid, pg_statio_all_sequences.schemaname, pg_statio_all_sequences.relname, pg_statio_all_sequences.blks_read, pg_statio_all_sequences.blks_hit FROM pg_statio_all_sequences WHERE ((pg_statio_all_sequences.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_sequences.schemaname !~ '^pg_toast'::text));
 pg_statio_user_tables           | SELECT pg_statio_all_tables.relid, pg_statio_all_tables.schemaname, pg_statio_all_tables.relname, pg_statio_all_tables.heap_blks_read, pg_statio_all_tables.heap_blks_hit, pg_statio_all_tables.idx_blks_read, pg_statio_all_tables.idx_blks_hit, pg_statio_all_tables.toast_blks_read, pg_statio_all_tables.toast_blks_hit, pg_statio_all_tables.tidx_blks_read, pg_statio_all_tables.tidx_blks_hit FROM pg_statio_all_tables WHERE ((pg_statio_all_tables.schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (pg_statio_all_tables.schemaname !~ '^pg_toast'::text));
 pg_stats                        | SELECT n.nspname AS schemaname, c.relname AS tablename, a.attname, s.stainherit AS inherited, s.stanullfrac AS null_frac, s.stawidth AS avg_width, s.stadistinct AS n_distinct, s.stadndistinct AS n_dndistinct, CASE WHEN (s.stakind1 = 1) THEN s.stavalues1 WHEN (s.stakind2 = 1) THEN s.stavalues2 WHEN (s.stakind3 = 1) THEN s.stavalues3 WHEN (s.stakind4 = 1) THEN s.stavalues4 WHEN (s.stakind5 = 1) THEN s.stavalues5 ELSE NULL::anyarray END AS most_common_vals, CASE WHEN (s.stakind1 = 1) THEN s.stanumbers1 WHEN (s.stakind2 = 1) THEN s.stanumbers2 WHEN (s.stakind3 = 1) THEN s.stanumbers3 WHEN (s.stakind4 = 1) THEN s.stanumbers4 WHEN (s.stakind5 = 1) THEN s.stanumbers5 ELSE NULL::real[] END AS most_common_freqs, CASE WHEN (s.stakind1 = 2) THEN s.stavalues1 WHEN (s.stakind2 = 2) THEN s.stavalues2 WHEN (s.stakind3 = 2) THEN s.stavalues3 WHEN (s.stakind4 = 2) THEN s.stavalues4 WHEN (s.stakind5 = 2) THEN s.stavalues5 ELSE NULL::anyarray END AS histogram_bounds, CASE WHEN (s.stakind1 = 3) THEN s.stanumbers1[1] WHEN (s.stakind2 = 3) THEN s.stanumbers2[1] WHEN (s.stakind3 = 3) THEN s.stanumbers3[1] WHEN (s.stakind4 = 3) THEN s.stanumbers4[1] WHEN (s.stakind5 = 3) THEN s.stanumbers5[1] ELSE NULL::real END AS correlation, CASE WHEN (s.stakind1 = 4) THEN s.stavalues1 WHEN (s.stakind2 = 4) THEN s.stavalues2 WHEN (s.stakind3 = 4) THEN s.stavalues3 WHEN (s.stakind4 = 4) THEN s.stavalues4 WHEN (s.stakind5 = 4) THEN s.stavalues5 ELSE NULL::anyarray END AS most_common_elems, CASE WHEN (s.stakind1 = 4) THEN s.stanumbers1 WHEN (s.stakind2 = 4) THEN s.stanumbers2 WHEN (s.stakind3 = 4) THEN s.stanumbers3 WHEN (s.stakind4 = 4) THEN s.stanumbers4 WHEN (s.stakind5 = 4) THEN s.stanumbers5 ELSE NULL::real[] END AS most_common_elem_freqs, CASE WHEN (s.stakind1 = 5) THEN s.stanumbers1 WHEN (s.stakind2 = 5) THEN s.stanumbers2 WHEN (s.stakind3 = 5) THEN s.stanumbers3 WHEN (s.stakind4 = 5) THEN s.stanumbers4 WHEN (s.stakind5 = 5) THEN s.stanumbers5 ELSE NULL::real[] END AS elem_count_histogram FROM (((pg_statistic s JOIN pg_class c ON (((c.oid = s.starelid) AND (s.starelkind = 'c'::"char")))) JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum)))) LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text));
 pg_tables                       | SELECT n.nspname AS schemaname, c.relname AS tablename, pg_get_userbyid(c.relowner) AS tableowner, t.spcname AS tablespace, c.relhasindex AS hasindexes, c.relhasrules AS hasrules, c.relhastriggers AS hastriggers FROM ((pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace))) WHERE (c.relkind = 'r'::"char");
 pg_thread_wait_status           | SELECT s.node_name, CASE WHEN (s.datid = (0)::oid) THEN ('postgres'::text)::name ELSE (SELECT d.datname FROM pg_database d WHERE (d.oid = s.datid)) END AS db_name, t.lwpid, s.thread_name, s.cn_pid, s.pid, s.ppid, s.plevel, s.status AS wait_status, s.query FROM (pg_stat_get_status(NULL::bigint) s(datid, pid, query, status, node_name, cn_pid, ppid, plevel, thread_name) JOIN pg_stat_get_thread() t(node_name, pid, lwpid, thread_name, creation_time) ON ((s.pid = t.pid)));
 pg_timezone_abbrevs             | SELECT pg_timezone_abbrevs.abbrev, pg_timezone_abbrevs.utc_offset, pg_timezone_abbrevs.is_dst FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);
 pg_timezone_names               | SELECT pg_timezone_names.name, pg_timezone_names.abbrev, pg_timezone_names.utc_offset, pg_timezone_names.is_dst FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);
 pg_total_memory_detail          | SELECT pv_total_memory_detail.nodename, pv_total_memory_detail.memorytype, pv_total_memory_detail.memorymbytes FROM pv_total_memory_detail() pv_total_memory_detail(nodename, memorytype, memorymbytes);
 pg_user                         | SELECT pg_shadow.usename, pg_shadow.usesysid, pg_shadow.usecreatedb, pg_shadow.usesuper, pg_shadow.usecatupd, pg_shadow.userepl, '********'::text AS passwd, pg_shadow.valbegin, pg_shadow.valuntil, pg_shadow.respool, pg_shadow.useconfig FROM pg_shadow;
 pg_user_mappings                | SELECT u.oid AS umid, s.oid AS srvid, s.srvname, u.umuser, CASE WHEN (u.umuser = (0)::oid) THEN 'public'::name ELSE a.rolname END AS usename, CASE WHEN (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text)) THEN u.umoptions ELSE NULL::text[] END AS umoptions FROM ((pg_user_mapping u LEFT JOIN pg_authid a ON ((a.oid = u.umuser))) JOIN pg_foreign_server s ON ((u.umserver = s.oid)));
 pg_views                        | SELECT n.nspname AS schemaname, c.relname AS viewname, pg_get_userbyid(c.relowner) AS viewowner, pg_get_viewdef(c.oid) AS definition FROM (pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) WHERE (c.relkind = 'v'::"char");
 pg_wlm_statistics               | SELECT pg_stat_get_wlm_statistics.statement, pg_stat_get_wlm_statistics.block_time, pg_stat_get_wlm_statistics.elapsed_time, pg_stat_get_wlm_statistics.total_cpu_time, pg_stat_get_wlm_statistics.qualification_time, pg_stat_get_wlm_statistics.skew_percent AS cpu_skew_percent, pg_stat_get_wlm_statistics.control_group, pg_stat_get_wlm_statistics.status, pg_stat_get_wlm_statistics.action FROM pg_stat_get_wlm_statistics(NULL::integer) pg_stat_get_wlm_statistics(statement, block_time, elapsed_time, total_cpu_time, qualification_time, skew_percent, control_group, status, action);
 pgxc_comm_recv_stream           | SELECT DISTINCT pgxc_comm_recv_stream.node_name, pgxc_comm_recv_stream.local_tid, pgxc_comm_recv_stream.remote_name, pgxc_comm_recv_stream.remote_tid, pgxc_comm_recv_stream.idx, pgxc_comm_recv_stream.sid, pgxc_comm_recv_stream.tcp_sock, pgxc_comm_recv_stream.state, pgxc_comm_recv_stream.query_id, pgxc_comm_recv_stream.plan_id, pgxc_comm_recv_stream.pn_id, pgxc_comm_recv_stream.send_smp, pgxc_comm_recv_stream.recv_smp, pgxc_comm_recv_stream.recv_bytes, pgxc_comm_recv_stream."time", pgxc_comm_recv_stream.speed, pgxc_comm_recv_stream.quota, pgxc_comm_recv_stream.buff_usize FROM pgxc_comm_recv_stream() pgxc_comm_recv_stream(node_name, local_tid, remote_name, remote_tid, idx, sid, tcp_sock, state, query_id, plan_id, pn_id, send_smp, recv_smp, recv_bytes, "time", speed, quota, buff_usize);
 pgxc_comm_send_stream           | SELECT DISTINCT pgxc_comm_send_stream.node_name, pgxc_comm_send_stream.local_tid, pgxc_comm_send_stream.remote_name, pgxc_comm_send_stream.remote_tid, pgxc_comm_send_stream.idx, pgxc_comm_send_stream.sid, pgxc_comm_send_stream.tcp_sock, pgxc_comm_send_stream.state, pgxc_comm_send_stream.query_id, pgxc_comm_send_stream.plan_id, pgxc_comm_send_stream.pn_id, pgxc_comm_recv_stream.send_smp, pgxc_comm_recv_stream.recv_smp, pgxc_comm_send_stream.send_bytes, pgxc_comm_send_stream."time", pgxc_comm_send_stream.speed, pgxc_comm_send_stream.quota, pgxc_comm_send_stream.wait_quota FROM pgxc_comm_send_stream() pgxc_comm_send_stream(node_name, local_tid, remote_name, remote_tid, idx, sid, tcp_sock, state, query_id, plan_id, pn_id, send_smp, recv_smp, send_bytes, "time", speed, quota, wait_quota);
 pgxc_comm_status                | SELECT DISTINCT pgxc_comm_status.node_name, pgxc_comm_status.recv_speed, pgxc_comm_status.send_speed, pgxc_comm_status.mem_used FROM pgxc_comm_status() pgxc_comm_status(node_name, recv_speed, send_speed, mem_used);
 pgxc_node_env                   | SELECT DISTINCT pgxc_get_node_env.node_name, pgxc_get_node_env.host, pgxc_get_node_env.process, pgxc_get_node_env.port, pgxc_get_node_env.installpath, pgxc_get_node_env.datapath, pgxc_get_node_env.log_directory FROM pgxc_get_node_env() pgxc_get_node_env(node_name, host, process, port, installpath, datapath, log_directory);
 pgxc_os_threads                 | SELECT DISTINCT pgxc_get_os_threads.node_name, pgxc_get_os_threads.pid, pgxc_get_os_threads.lwpid, pgxc_get_os_threads.thread_name, pgxc_get_os_threads.creation_time FROM pgxc_get_os_threads() pgxc_get_os_threads(node_name, pid, lwpid, thread_name, creation_time);
 pgxc_prepared_xacts             | SELECT DISTINCT pgxc_prepared_xact.pgxc_prepared_xact FROM pgxc_prepared_xact() pgxc_prepared_xact(pgxc_prepared_xact);
 pgxc_running_xacts              | SELECT DISTINCT pgxc_get_running_xacts.handle, pgxc_get_running_xacts.gxid, pgxc_get_running_xacts.state, pgxc_get_running_xacts.node, pgxc_get_running_xacts.xmin, pgxc_get_running_xacts.vacuum, pgxc_get_running_xacts.timeline, pgxc_get_running_xacts.prepare_xid, pgxc_get_running_xacts.pid FROM pgxc_get_running_xacts() pgxc_get_running_xacts(handle, gxid, state, node, xmin, vacuum, timeline, prepare_xid, pid);
 pgxc_thread_wait_status         | SELECT pgxc_get_thread_wait_status.node_name, pgxc_get_thread_wait_status.db_name, pgxc_get_thread_wait_status.lwpid, pgxc_get_thread_wait_status.thread_name, pgxc_get_thread_wait_status.cn_pid, pgxc_get_thread_wait_status.pid, pgxc_get_thread_wait_status.ppid, pgxc_get_thread_wait_status.plevel, CASE WHEN (substr(pgxc_get_thread_wait_status.wait_status, 1, 11) = 'wait node: '::text) THEN ('wait node: '::text || ((SELECT pgxc_node.node_name FROM pgxc_node WHERE ((pgxc_node.oid)::text = "substring"(pgxc_get_thread_wait_status.wait_status, 12))))::text) ELSE pgxc_get_thread_wait_status.wait_status END AS wait_status, pgxc_get_thread_wait_status.query FROM pgxc_get_thread_wait_status() pgxc_get_thread_wait_status(node_name, db_name, lwpid, thread_name, cn_pid, pid, ppid, plevel, wait_status, query);
 pgxc_total_memory_detail        | SELECT DISTINCT pgxc_total_memory_detail.nodename, pgxc_total_memory_detail.memorytype, pgxc_total_memory_detail.memorymbytes FROM pgxc_total_memory_detail() pgxc_total_memory_detail(nodename, memorytype, memorymbytes);
 pv_file_stat                    | SELECT pg_stat_get_file_stat.filenum, pg_stat_get_file_stat.dbid, pg_stat_get_file_stat.spcid, pg_stat_get_file_stat.phyrds, pg_stat_get_file_stat.phywrts, pg_stat_get_file_stat.phyblkrd, pg_stat_get_file_stat.phyblkwrt, pg_stat_get_file_stat.readtim, pg_stat_get_file_stat.writetim, pg_stat_get_file_stat.avgiotim, pg_stat_get_file_stat.lstiotim, pg_stat_get_file_stat.miniotim, pg_stat_get_file_stat.maxiowtm FROM pg_stat_get_file_stat() pg_stat_get_file_stat(filenum, dbid, spcid, phyrds, phywrts, phyblkrd, phyblkwrt, readtim, writetim, avgiotim, lstiotim, miniotim, maxiowtm);
 pv_os_run_info                  | SELECT pv_os_run_info.id, pv_os_run_info.name, pv_os_run_info.value, pv_os_run_info.comments, pv_os_run_info.cumulative FROM pv_os_run_info() pv_os_run_info(id, name, value, comments, cumulative);
 pv_redo_stat                    | SELECT pg_stat_get_redo_stat.phywrts, pg_stat_get_redo_stat.phyblkwrt, pg_stat_get_redo_stat.writetim, pg_stat_get_redo_stat.avgiotim, pg_stat_get_redo_stat.lstiotim, pg_stat_get_redo_stat.miniotim, pg_stat_get_redo_stat.maxiowtm FROM pg_stat_get_redo_stat() pg_stat_get_redo_stat(phywrts, phyblkwrt, writetim, avgiotim, lstiotim, miniotim, maxiowtm);
 pv_session_memory               | SELECT pv_session_memory.sessid, pv_session_memory.init_mem, pv_session_memory.used_mem, pv_session_memory.peak_mem FROM pv_session_memory() pv_session_memory(sessid, init_mem, used_mem, peak_mem);
 pv_session_memory_detail        | SELECT pv_session_memory_detail.sessid, pv_session_memory_detail.sesstype, pv_session_memory_detail.contextname, pv_session_memory_detail.level, pv_session_memory_detail.parent, pv_session_memory_detail.totalsize, pv_session_memory_detail.freesize, pv_session_memory_detail.usedsize FROM pv_session_memory_detail() pv_session_memory_detail(sessid, sesstype, contextname, level, parent, totalsize, freesize, usedsize);
 pv_session_stat                 | SELECT pv_session_stat.sessid, pv_session_stat.statid, pv_session_stat.statname, pv_session_stat.statunit, pv_session_stat.value FROM pv_session_stat() pv_session_stat(sessid, statid, statname, statunit, value);
 pv_session_time                 | SELECT pv_session_time.sessid, pv_session_time.stat_id, pv_session_time.stat_name, pv_session_time.value FROM pv_session_time() pv_session_time(sessid, stat_id, stat_name, value);
 pv_total_memory_detail          | SELECT pv_total_memory_detail.nodename, pv_total_memory_detail.memorytype, pv_total_memory_detail.memorymbytes FROM pv_total_memory_detail() pv_total_memory_detail(nodename, memorytype, memorymbytes);
 rtest_v1                        | SELECT rtest_t1.a, rtest_t1.b FROM rtest_t1;
 rtest_vcomp                     | SELECT x.part, (x.size * y.factor) AS size_in_cm FROM rtest_comp x, rtest_unitfact y WHERE (x.unit = y.unit);
 rtest_vview1                    | SELECT x.a, x.b FROM rtest_view1 x WHERE (0 < (SELECT count(*) AS count FROM rtest_view2 y WHERE (y.a = x.a)));
 rtest_vview2                    | SELECT rtest_view1.a, rtest_view1.b FROM rtest_view1 WHERE rtest_view1.v;
 rtest_vview3                    | SELECT x.a, x.b FROM rtest_vview2 x WHERE (0 < (SELECT count(*) AS count FROM rtest_view2 y WHERE (y.a = x.a)));
 rtest_vview4                    | SELECT x.a, x.b, count(y.a) AS refcount FROM rtest_view1 x, rtest_view2 y WHERE (x.a = y.a) GROUP BY x.a, x.b;
 rtest_vview5                    | SELECT rtest_view1.a, rtest_view1.b, rtest_viewfunc1(rtest_view1.a) AS refcount FROM rtest_view1;
 shoe                            | SELECT sh.shoename, sh.sh_avail, sh.slcolor, sh.slminlen, (sh.slminlen * un.un_fact) AS slminlen_cm, sh.slmaxlen, (sh.slmaxlen * un.un_fact) AS slmaxlen_cm, sh.slunit FROM shoe_data sh, unit un WHERE (sh.slunit = un.un_name);
 shoe_ready                      | SELECT rsh.shoename, rsh.sh_avail, rsl.sl_name, rsl.sl_avail, int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail FROM shoe rsh, shoelace rsl WHERE (((rsl.sl_color = rsh.slcolor) AND (rsl.sl_len_cm >= rsh.slminlen_cm)) AND (rsl.sl_len_cm <= rsh.slmaxlen_cm));
 shoelace                        | SELECT s.sl_name, s.sl_avail, s.sl_color, s.sl_len, s.sl_unit, (s.sl_len * u.un_fact) AS sl_len_cm FROM shoelace_data s, unit u WHERE (s.sl_unit = u.un_name);
 shoelace_candelete              | SELECT shoelace_obsolete.sl_name, shoelace_obsolete.sl_avail, shoelace_obsolete.sl_color, shoelace_obsolete.sl_len, shoelace_obsolete.sl_unit, shoelace_obsolete.sl_len_cm FROM shoelace_obsolete WHERE (shoelace_obsolete.sl_avail = 0);
 shoelace_obsolete               | SELECT shoelace.sl_name, shoelace.sl_avail, shoelace.sl_color, shoelace.sl_len, shoelace.sl_unit, shoelace.sl_len_cm FROM shoelace WHERE (NOT (EXISTS (SELECT shoe.shoename FROM shoe WHERE (shoe.slcolor = shoelace.sl_color))));
 street                          | SELECT r.name, r.thepath, c.cname FROM ONLY road r, real_city c WHERE (c.outline ## r.thepath);
 toyemp                          | SELECT emp.name, emp.age, emp.location, (12 * emp.salary) AS annualsal FROM emp;
 user_ind_partitions             | SELECT dba_ind_partitions.index_owner, dba_ind_partitions.schema, dba_ind_partitions.index_name, dba_ind_partitions.partition_name, dba_ind_partitions.index_partition_usable, dba_ind_partitions.high_value, dba_ind_partitions.def_tablespace_name FROM dba_ind_partitions WHERE ((dba_ind_partitions.index_owner)::name = "current_user"());
 user_ind_partitions             | SELECT dba_ind_partitions.index_owner, dba_ind_partitions.schema, dba_ind_partitions.index_name, dba_ind_partitions.partition_name, dba_ind_partitions.index_partition_usable, dba_ind_partitions.high_value, dba_ind_partitions.def_tablespace_name FROM dba_ind_partitions WHERE ((dba_ind_partitions.index_owner)::name = "current_user"());
 user_indexes                    | SELECT dba_indexes.owner, dba_indexes.index_name FROM dba_indexes WHERE ((dba_indexes.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_indexes                    | SELECT dba_indexes.owner, dba_indexes.index_name FROM dba_indexes WHERE ((dba_indexes.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_objects                    | ((((SELECT cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'table'::name WHEN (cs.relkind = 'i'::"char") THEN 'index'::name WHEN (cs.relkind = 'S'::"char") THEN 'sequence'::name WHEN (cs.relkind = 'v'::"char") THEN 'view'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) AND ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT pc.proname AS object_name, pc.oid AS object_id, 'procedure'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc WHERE ((pg_get_userbyid(pc.proowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT re.rulename AS object_name, re.oid AS object_id, 'rule'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class))) WHERE ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT tr.tgname AS object_name, tr.oid AS object_id, 'trigger'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid))) WHERE ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT te.typname AS object_name, te.oid AS object_id, 'type'::name AS object_type, te.typnamespace AS namespace FROM pg_type te WHERE ((pg_get_userbyid(te.typowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT op.oprname AS object_name, op.oid AS object_id, 'operator'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op WHERE ((pg_get_userbyid(op.oprowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_objects                    | ((((SELECT cs.relname AS object_name, cs.oid AS object_id, CASE WHEN (cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char"])) THEN 'table'::name WHEN (cs.relkind = 'i'::"char") THEN 'index'::name WHEN (cs.relkind = 'S'::"char") THEN 'sequence'::name WHEN (cs.relkind = 'v'::"char") THEN 'view'::name ELSE NULL::name END AS object_type, cs.relnamespace AS namespace FROM pg_class cs WHERE ((cs.relkind = ANY (ARRAY['r'::"char", 'f'::"char", 'i'::"char", 'S'::"char", 'v'::"char"])) AND ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT pc.proname AS object_name, pc.oid AS object_id, 'procedure'::name AS object_type, pc.pronamespace AS namespace FROM pg_proc pc WHERE ((pg_get_userbyid(pc.proowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT re.rulename AS object_name, re.oid AS object_id, 'rule'::name AS object_type, cs.relnamespace AS namespace FROM (pg_rewrite re LEFT JOIN pg_class cs ON ((cs.oid = re.ev_class))) WHERE ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT tr.tgname AS object_name, tr.oid AS object_id, 'trigger'::name AS object_type, cs.relnamespace AS namespace FROM (pg_trigger tr LEFT JOIN pg_class cs ON ((cs.oid = tr.tgrelid))) WHERE ((pg_get_userbyid(cs.relowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT te.typname AS object_name, te.oid AS object_id, 'type'::name AS object_type, te.typnamespace AS namespace FROM pg_type te WHERE ((pg_get_userbyid(te.typowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text))) UNION SELECT op.oprname AS object_name, op.oid AS object_id, 'operator'::name AS object_type, op.oprnamespace AS namespace FROM pg_operator op WHERE ((pg_get_userbyid(op.oprowner))::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_part_indexes               | SELECT dba_part_indexes.index_owner, dba_part_indexes.schema, dba_part_indexes.index_name, dba_part_indexes.table_name, dba_part_indexes.partitioning_type, dba_part_indexes.partition_count, dba_part_indexes.def_tablespace_name, dba_part_indexes.partitioning_key_count FROM dba_part_indexes WHERE ((dba_part_indexes.index_owner)::name = "current_user"());
 user_part_indexes               | SELECT dba_part_indexes.index_owner, dba_part_indexes.schema, dba_part_indexes.index_name, dba_part_indexes.table_name, dba_part_indexes.partitioning_type, dba_part_indexes.partition_count, dba_part_indexes.def_tablespace_name, dba_part_indexes.partitioning_key_count FROM dba_part_indexes WHERE ((dba_part_indexes.index_owner)::name = "current_user"());
 user_part_tables                | SELECT dba_part_tables.table_owner, dba_part_tables.schema, dba_part_tables.table_name, dba_part_tables.partitioning_type, dba_part_tables.partition_count, dba_part_tables.def_tablespace_name, dba_part_tables.partitioning_key_count FROM dba_part_tables WHERE ((dba_part_tables.table_owner)::name = "current_user"());
 user_part_tables                | SELECT dba_part_tables.table_owner, dba_part_tables.schema, dba_part_tables.table_name, dba_part_tables.partitioning_type, dba_part_tables.partition_count, dba_part_tables.def_tablespace_name, dba_part_tables.partitioning_key_count FROM dba_part_tables WHERE ((dba_part_tables.table_owner)::name = "current_user"());
 user_procedures                 | SELECT dba_procedures.owner, dba_procedures.object_name, dba_procedures.argument_number FROM dba_procedures WHERE ((dba_procedures.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_procedures                 | SELECT dba_procedures.owner, dba_procedures.object_name, dba_procedures.argument_number FROM dba_procedures WHERE ((dba_procedures.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_sequences                  | SELECT dba_sequences.sequence_owner, dba_sequences.sequence_name FROM dba_sequences WHERE ((dba_sequences.sequence_owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_sequences                  | SELECT dba_sequences.sequence_owner, dba_sequences.sequence_name FROM dba_sequences WHERE ((dba_sequences.sequence_owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_source                     | SELECT dba_source.owner, dba_source.name, dba_source.text FROM dba_source WHERE ((dba_source.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_source                     | SELECT dba_source.owner, dba_source.name, dba_source.text FROM dba_source WHERE ((dba_source.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_tab_columns                | SELECT dba_tab_columns.owner, dba_tab_columns.table_name, dba_tab_columns.column_name, dba_tab_columns.data_type, dba_tab_columns.column_id, dba_tab_columns.data_length, dba_tab_columns.comments FROM dba_tab_columns WHERE ((dba_tab_columns.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_tab_columns                | SELECT dba_tab_columns.owner, dba_tab_columns.table_name, dba_tab_columns.column_name, dba_tab_columns.data_type, dba_tab_columns.column_id, dba_tab_columns.data_length, dba_tab_columns.comments FROM dba_tab_columns WHERE ((dba_tab_columns.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_tab_partitions             | SELECT dba_tab_partitions.table_owner, dba_tab_partitions.schema, dba_tab_partitions.table_name, dba_tab_partitions.partition_name, dba_tab_partitions.high_value, dba_tab_partitions.tablespace_name FROM dba_tab_partitions WHERE ((dba_tab_partitions.table_owner)::name = "current_user"());
 user_tab_partitions             | SELECT dba_tab_partitions.table_owner, dba_tab_partitions.schema, dba_tab_partitions.table_name, dba_tab_partitions.partition_name, dba_tab_partitions.high_value, dba_tab_partitions.tablespace_name FROM dba_tab_partitions WHERE ((dba_tab_partitions.table_owner)::name = "current_user"());
 user_tables                     | SELECT dba_tables.owner, dba_tables.table_name, dba_tables.tablespace_name, dba_tables.status, dba_tables.temporary, dba_tables.dropped FROM dba_tables WHERE ((dba_tables.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_tables                     | SELECT dba_tables.owner, dba_tables.table_name, dba_tables.tablespace_name, dba_tables.status, dba_tables.temporary, dba_tables.dropped FROM dba_tables WHERE ((dba_tables.owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_triggers                   | SELECT dba_triggers.trigger_name, dba_triggers.table_name, dba_triggers.table_owner FROM dba_triggers WHERE ((dba_triggers.table_owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_triggers                   | SELECT dba_triggers.trigger_name, dba_triggers.table_name, dba_triggers.table_owner FROM dba_triggers WHERE ((dba_triggers.table_owner)::text = sys_context('USERENV'::text, 'CURRENT_USER'::text));
 user_views                      | SELECT dba_views.owner, dba_views.view_name FROM dba_views WHERE ((dba_views.owner)::text = sys_context('userenv'::text, 'current_user'::text));
 user_views                      | SELECT dba_views.owner, dba_views.view_name FROM dba_views WHERE ((dba_views.owner)::text = sys_context('userenv'::text, 'current_user'::text));
 v$session                       | SELECT sa.pid AS sid, 0 AS "serial#", sa.usesysid AS "user#", ad.rolname AS username FROM (pg_stat_get_activity(NULL::integer) sa(datid, pid, usesysid, application_name, state, query, waiting, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, enqueue) LEFT JOIN pg_authid ad ON ((sa.usesysid = ad.oid))) WHERE (sa.application_name <> 'JobScheduler'::text);
 v$session_longops               | SELECT sa.pid AS sid, 0 AS "serial#", NULL::integer AS sofar, NULL::integer AS totalwork FROM pg_stat_activity sa WHERE (sa.application_name <> 'JobScheduler'::text);
(178 rows)

SELECT tablename, rulename, definition FROM pg_rules
	ORDER BY tablename, rulename;
   tablename   |    rulename     |                                                                                                                                  definition                                                                                                                                   
---------------+-----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 pg_settings   | pg_settings_n   | CREATE RULE pg_settings_n AS ON UPDATE TO pg_settings DO INSTEAD NOTHING;
 pg_settings   | pg_settings_u   | CREATE RULE pg_settings_u AS ON UPDATE TO pg_settings WHERE (new.name = old.name) DO SELECT set_config(old.name, new.setting, false) AS set_config;
 rtest_emp     | rtest_emp_del   | CREATE RULE rtest_emp_del AS ON DELETE TO rtest_emp DO INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal) VALUES (old.ename, "current_user"(), 'fired'::bpchar, '$0.00'::money, old.salary);
 rtest_emp     | rtest_emp_ins   | CREATE RULE rtest_emp_ins AS ON INSERT TO rtest_emp DO INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal) VALUES (new.ename, "current_user"(), 'hired'::bpchar, new.salary, '$0.00'::money);
 rtest_emp     | rtest_emp_upd   | CREATE RULE rtest_emp_upd AS ON UPDATE TO rtest_emp WHERE (new.salary <> old.salary) DO INSERT INTO rtest_emplog (ename, who, action, newsal, oldsal) VALUES (new.ename, "current_user"(), 'honored'::bpchar, new.salary, old.salary);
 rtest_nothn1  | rtest_nothn_r1  | CREATE RULE rtest_nothn_r1 AS ON INSERT TO rtest_nothn1 WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD NOTHING;
 rtest_nothn1  | rtest_nothn_r2  | CREATE RULE rtest_nothn_r2 AS ON INSERT TO rtest_nothn1 WHERE ((new.a >= 30) AND (new.a < 40)) DO INSTEAD NOTHING;
 rtest_nothn2  | rtest_nothn_r3  | CREATE RULE rtest_nothn_r3 AS ON INSERT TO rtest_nothn2 WHERE (new.a >= 100) DO INSTEAD INSERT INTO rtest_nothn3 (a, b) VALUES (new.a, new.b);
 rtest_nothn2  | rtest_nothn_r4  | CREATE RULE rtest_nothn_r4 AS ON INSERT TO rtest_nothn2 DO INSTEAD NOTHING;
 rtest_order1  | rtest_order_r1  | CREATE RULE rtest_order_r1 AS ON INSERT TO rtest_order1 DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 1 - this should run 1st'::text);
 rtest_order1  | rtest_order_r2  | CREATE RULE rtest_order_r2 AS ON INSERT TO rtest_order1 DO INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 2 - this should run 2nd'::text);
 rtest_order1  | rtest_order_r3  | CREATE RULE rtest_order_r3 AS ON INSERT TO rtest_order1 DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 3 - this should run 3rd'::text);
 rtest_order1  | rtest_order_r4  | CREATE RULE rtest_order_r4 AS ON INSERT TO rtest_order1 WHERE (new.a < 100) DO INSTEAD INSERT INTO rtest_order2 (a, b, c) VALUES (new.a, nextval('rtest_seq'::regclass), 'rule 4 - this should run 4th'::text);
 rtest_person  | rtest_pers_del  | CREATE RULE rtest_pers_del AS ON DELETE TO rtest_person DO DELETE FROM rtest_admin WHERE (rtest_admin.pname = old.pname);
 rtest_person  | rtest_pers_upd  | CREATE RULE rtest_pers_upd AS ON UPDATE TO rtest_person DO UPDATE rtest_admin SET pname = new.pname WHERE (rtest_admin.pname = old.pname);
 rtest_system  | rtest_sys_del   | CREATE RULE rtest_sys_del AS ON DELETE TO rtest_system DO (DELETE FROM rtest_interface WHERE (rtest_interface.sysname = old.sysname); DELETE FROM rtest_admin WHERE (rtest_admin.sysname = old.sysname); );
 rtest_system  | rtest_sys_upd   | CREATE RULE rtest_sys_upd AS ON UPDATE TO rtest_system DO (UPDATE rtest_interface SET sysname = new.sysname WHERE (rtest_interface.sysname = old.sysname); UPDATE rtest_admin SET sysname = new.sysname WHERE (rtest_admin.sysname = old.sysname); );
 rtest_t4      | rtest_t4_ins1   | CREATE RULE rtest_t4_ins1 AS ON INSERT TO rtest_t4 WHERE ((new.a >= 10) AND (new.a < 20)) DO INSTEAD INSERT INTO rtest_t5 (a, b) VALUES (new.a, new.b);
 rtest_t4      | rtest_t4_ins2   | CREATE RULE rtest_t4_ins2 AS ON INSERT TO rtest_t4 WHERE ((new.a >= 20) AND (new.a < 30)) DO INSERT INTO rtest_t6 (a, b) VALUES (new.a, new.b);
 rtest_t5      | rtest_t5_ins    | CREATE RULE rtest_t5_ins AS ON INSERT TO rtest_t5 WHERE (new.a > 15) DO INSERT INTO rtest_t7 (a, b) VALUES (new.a, new.b);
 rtest_t6      | rtest_t6_ins    | CREATE RULE rtest_t6_ins AS ON INSERT TO rtest_t6 WHERE (new.a > 25) DO INSTEAD INSERT INTO rtest_t8 (a, b) VALUES (new.a, new.b);
 rtest_v1      | rtest_v1_del    | CREATE RULE rtest_v1_del AS ON DELETE TO rtest_v1 DO INSTEAD DELETE FROM rtest_t1 WHERE (rtest_t1.a = old.a);
 rtest_v1      | rtest_v1_ins    | CREATE RULE rtest_v1_ins AS ON INSERT TO rtest_v1 DO INSTEAD INSERT INTO rtest_t1 (a, b) VALUES (new.a, new.b);
 rtest_v1      | rtest_v1_upd    | CREATE RULE rtest_v1_upd AS ON UPDATE TO rtest_v1 DO INSTEAD UPDATE rtest_t1 SET a = new.a, b = new.b WHERE (rtest_t1.a = old.a);
 shoelace      | shoelace_del    | CREATE RULE shoelace_del AS ON DELETE TO shoelace DO INSTEAD DELETE FROM shoelace_data WHERE (shoelace_data.sl_name = old.sl_name);
 shoelace      | shoelace_ins    | CREATE RULE shoelace_ins AS ON INSERT TO shoelace DO INSTEAD INSERT INTO shoelace_data (sl_name, sl_avail, sl_color, sl_len, sl_unit) VALUES (new.sl_name, new.sl_avail, new.sl_color, new.sl_len, new.sl_unit);
 shoelace      | shoelace_upd    | CREATE RULE shoelace_upd AS ON UPDATE TO shoelace DO INSTEAD UPDATE shoelace_data SET sl_name = new.sl_name, sl_avail = new.sl_avail, sl_color = new.sl_color, sl_len = new.sl_len, sl_unit = new.sl_unit WHERE (shoelace_data.sl_name = old.sl_name);
 shoelace_data | log_shoelace    | CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data WHERE (new.sl_avail <> old.sl_avail) DO INSERT INTO shoelace_log (sl_name, sl_avail, log_who, log_when) VALUES (new.sl_name, new.sl_avail, 'Al Bundy'::name, 'Thu Jan 01 00:00:00 1970'::timestamp without time zone);
 shoelace_ok   | shoelace_ok_ins | CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok DO INSTEAD UPDATE shoelace SET sl_avail = (shoelace.sl_avail + new.ok_quant) WHERE (shoelace.sl_name = new.ok_name);
(29 rows)

--
-- CREATE OR REPLACE RULE
--
CREATE TABLE ruletest_tbl (a int, b int);
CREATE TABLE ruletest_tbl2 (a int, b int);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
INSERT INTO ruletest_tbl VALUES (99, 99);
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
INSERT INTO ruletest_tbl VALUES (99, 99);
SELECT * FROM ruletest_tbl2 ORDER BY a;
  a   |  b   
------+------
   10 |   10
 1000 | 1000
(2 rows)

-- Check that rewrite rules splitting one INSERT into multiple
-- conditional statements does not disable FK checking.
create table rule_and_refint_t1 (
	id1a integer,
	id1b integer,
	primary key (id1a, id1b)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t1_pkey" for table "rule_and_refint_t1"
create table rule_and_refint_t2 (
	id2a integer,
	id2c integer,
	primary key (id2a, id2c)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t2_pkey" for table "rule_and_refint_t2"
create table rule_and_refint_t3 (
	id3a integer,
	id3b integer,
	id3c integer,
	data text,
	primary key (id3a, id3b, id3c),
	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "rule_and_refint_t3_pkey" for table "rule_and_refint_t3"
insert into rule_and_refint_t1 values (1, 11);
insert into rule_and_refint_t1 values (1, 12);
insert into rule_and_refint_t1 values (2, 21);
insert into rule_and_refint_t1 values (2, 22);
insert into rule_and_refint_t2 values (1, 11);
insert into rule_and_refint_t2 values (1, 12);
insert into rule_and_refint_t2 values (2, 21);
insert into rule_and_refint_t2 values (2, 22);
insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
	where (exists (select 1 from rule_and_refint_t3
			where (((rule_and_refint_t3.id3a = new.id3a)
			and (rule_and_refint_t3.id3b = new.id3b))
			and (rule_and_refint_t3.id3c = new.id3c))))
	do instead update rule_and_refint_t3 set data = new.data
	where (((rule_and_refint_t3.id3a = new.id3a)
	and (rule_and_refint_t3.id3b = new.id3b))
	and (rule_and_refint_t3.id3c = new.id3c));
insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey1"
DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".
insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
ERROR:  insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".
--
-- disallow dropping a view's rule (bug #5072)
--
create view fooview as select 'foo'::text;
drop rule "_RETURN" on fooview;
ERROR:  cannot drop rule _RETURN on view fooview because view fooview requires it
HINT:  You can drop view fooview instead.
drop view fooview;
--
-- test conversion of table to view (needed to load some pg_dump files)
--
create table fooview (x int, y text);
select xmin, * from fooview;
 xmin | x | y 
------+---+---
(0 rows)

create rule "_RETURN" as on select to fooview do instead
  select 1 as x, 'aaa'::text as y;
select * from fooview;
 x |  y  
---+-----
 1 | aaa
(1 row)

select xmin, * from fooview;  -- fail, views don't have such a column
ERROR:  column "xmin" does not exist
LINE 1: select xmin, * from fooview;
               ^
CONTEXT:  referenced column: xmin
drop view fooview;
--
-- check for planner problems with complex inherited UPDATES
--
create table id (id serial primary key, name text);
NOTICE:  CREATE TABLE will create implicit sequence "id_id_seq" for serial column "id.id"
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "id_pkey" for table "id"
-- currently, must respecify PKEY for each inherited subtable
create table test_1 (id integer primary key) inherits (id);
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_1_pkey" for table "test_1"
create table test_2 (id integer primary key) inherits (id);
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_2_pkey" for table "test_2"
create table test_3 (id integer primary key) inherits (id);
NOTICE:  merging column "id" with inherited definition
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_3_pkey" for table "test_3"
insert into test_1 (name) values ('Test 1');
insert into test_1 (name) values ('Test 2');
insert into test_2 (name) values ('Test 3');
insert into test_2 (name) values ('Test 4');
insert into test_3 (name) values ('Test 5');
insert into test_3 (name) values ('Test 6');
create view id_ordered as select * from id order by id;
create rule update_id_ordered as on update to id_ordered
	do instead update id set name = new.name where id = old.id;
select * from id_ordered order by id;
 id |  name  
----+--------
  1 | Test 1
  2 | Test 2
  3 | Test 3
  4 | Test 4
  5 | Test 5
  6 | Test 6
(6 rows)

update id_ordered set name = 'update 2' where id = 2;
update id_ordered set name = 'update 4' where id = 4;
update id_ordered set name = 'update 5' where id = 5;
select * from id_ordered order by id;
 id |   name   
----+----------
  1 | Test 1
  2 | update 2
  3 | Test 3
  4 | update 4
  5 | update 5
  6 | Test 6
(6 rows)

set client_min_messages to warning; -- suppress cascade notices
drop table id cascade;
reset client_min_messages;
--
-- check corner case where an entirely-dummy subplan is created by
-- constraint exclusion
--
-- Enforce use of COMMIT instead of 2PC for temporary objects
create temp table t1 (a integer primary key) distribute by replication;
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "t1_pkey" for table "t1"
create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1) distribute by replication;
ALTER TABLE t1_1 ADD PRIMARY KEY(a);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_1_pkey" for table "t1_1"
create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1) distribute by replication;
ALTER TABLE t1_2 ADD PRIMARY KEY(a);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t1_2_pkey" for table "t1_2"
create rule t1_ins_1 as on insert to t1
	where new.a >= 0 and new.a < 10
	do instead
	insert into t1_1 values (new.a);
create rule t1_ins_2 as on insert to t1
	where new.a >= 10 and new.a < 20
	do instead
	insert into t1_2 values (new.a);
create rule t1_upd_1 as on update to t1
	where old.a >= 0 and old.a < 10
	do instead
	update t1_1 set a = new.a where a = old.a;
create rule t1_upd_2 as on update to t1
	where old.a >= 10 and old.a < 20
	do instead
	update t1_2 set a = new.a where a = old.a;
set constraint_exclusion = on;
insert into t1 select * from generate_series(5,19,1) g;
update t1 set a = 4 where a = 5;
select * from only t1 order by 1;
 a 
---
(0 rows)

select * from only t1_1 order by 1;
 a 
---
 4
 6
 7
 8
 9
(5 rows)

select * from only t1_2 order by 1;
 a  
----
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
(10 rows)

-- test various flavors of pg_get_viewdef()
select pg_get_viewdef('shoe'::regclass) as unpretty;
                                                                                                             unpretty                                                                                                              
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 SELECT sh.shoename, sh.sh_avail, sh.slcolor, sh.slminlen, (sh.slminlen * un.un_fact) AS slminlen_cm, sh.slmaxlen, (sh.slmaxlen * un.un_fact) AS slmaxlen_cm, sh.slunit FROM shoe_data sh, unit un WHERE (sh.slunit = un.un_name);
(1 row)

select pg_get_viewdef('shoe'::regclass,true) as pretty;
                           pretty                            
-------------------------------------------------------------
  SELECT sh.shoename, sh.sh_avail, sh.slcolor, sh.slminlen, +
     sh.slminlen * un.un_fact AS slminlen_cm, sh.slmaxlen,  +
     sh.slmaxlen * un.un_fact AS slmaxlen_cm, sh.slunit     +
    FROM shoe_data sh, unit un                              +
   WHERE sh.slunit = un.un_name;
(1 row)

select pg_get_viewdef('shoe'::regclass,0) as prettier;
                   prettier                    
-----------------------------------------------
  SELECT sh.shoename,                         +
     sh.sh_avail,                             +
     sh.slcolor,                              +
     sh.slminlen,                             +
     sh.slminlen * un.un_fact AS slminlen_cm, +
     sh.slmaxlen,                             +
     sh.slmaxlen * un.un_fact AS slmaxlen_cm, +
     sh.slunit                                +
    FROM shoe_data sh,                        +
     unit un                                  +
   WHERE sh.slunit = un.un_name;
(1 row)

--
-- check display of VALUES in view definitions
--
create view rule_v1 as values(1,2);
\d+ rule_v1
                 View "public.rule_v1"
 Column  |  Type   | Modifiers | Storage | Description 
---------+---------+-----------+---------+-------------
 column1 | integer |           | plain   | 
 column2 | integer |           | plain   | 
View definition:
 VALUES (1,2);

drop view rule_v1;
create view rule_v1(x) as values(1,2);
\d+ rule_v1
                 View "public.rule_v1"
 Column  |  Type   | Modifiers | Storage | Description 
---------+---------+-----------+---------+-------------
 x       | integer |           | plain   | 
 column2 | integer |           | plain   | 
View definition:
 SELECT "*VALUES*".column1 AS x, "*VALUES*".column2
   FROM (VALUES (1,2)) "*VALUES*";

drop view rule_v1;
create view rule_v1(x) as select * from (values(1,2)) v;
\d+ rule_v1
                 View "public.rule_v1"
 Column  |  Type   | Modifiers | Storage | Description 
---------+---------+-----------+---------+-------------
 x       | integer |           | plain   | 
 column2 | integer |           | plain   | 
View definition:
 SELECT v.column1 AS x, v.column2
   FROM ( VALUES (1,2)) v;

drop view rule_v1;
create view rule_v1(x) as select * from (values(1,2)) v(q,w);
\d+ rule_v1
                View "public.rule_v1"
 Column |  Type   | Modifiers | Storage | Description 
--------+---------+-----------+---------+-------------
 x      | integer |           | plain   | 
 w      | integer |           | plain   | 
View definition:
 SELECT v.q AS x, v.w
   FROM ( VALUES (1,2)) v(q, w);

drop view rule_v1;
