create schema nodegroup_setop_test;
set current_schema = nodegroup_setop_test;
set enable_nodegroup_explain=true;
ERROR:  unrecognized configuration parameter "enable_nodegroup_explain"
set expected_computing_nodegroup='group1';
create node group ng0 with (datanode1, datanode2, datanode3);
create node group ng1 with (datanode4, datanode5, datanode6);
create node group ng2 with (datanode7, datanode8, datanode9);
create node group ng3 with (datanode10, datanode11, datanode12);
create node group ng4 with (datanode1, datanode2, datanode3, datanode4, datanode5, datanode6);
create node group ng5 with (datanode4, datanode5, datanode6, datanode7, datanode8, datanode9);
create node group ng6 with (datanode7, datanode8, datanode9, datanode10, datanode11, datanode12);
create table setop_hash_table_01( a int, b int ,c text) distribute by hash(a) to group ng0;
create table setop_hash_table_02( a int, b numeric ,c text) distribute by hash(a) to group ng1;
create table setop_hash_table_03( a int, b bigint ,c text) distribute by hash(b) to group ng2;
create table setop_hash_table_04( a smallint, b bigint ,c text) distribute by hash(a) to group ng3;
create table setop_replication_table_01( a int, b bigint ,c text) distribute by replication to group ng4;
create table setop_replication_table_02( a bigint, b int ,c text) distribute by replication to group ng5;
create table setop_replication_table_03( a smallint, b bigint ,c text) distribute by replication to group ng6;
create view setop_view_table_12 as select setop_hash_table_01.a as ta1, setop_hash_table_01.b as tb1, setop_hash_table_02.a as ta2, setop_hash_table_02.b as tb2 from setop_hash_table_01 inner join setop_hash_table_02 on (setop_hash_table_01.a = setop_hash_table_02.a);
create view setop_view_table_23 as select setop_hash_table_02.a as ta1, setop_hash_table_02.b as tb1, setop_hash_table_03.a as ta2, setop_hash_table_03.b as tb2 from setop_hash_table_02 inner join setop_hash_table_03 on (setop_hash_table_02.a = setop_hash_table_03.a);
create view setop_view_table_31 as select setop_hash_table_03.a as ta1, setop_hash_table_03.b as tb1, setop_hash_table_01.a as ta2, setop_hash_table_01.b as tb2 from setop_hash_table_03 inner join setop_hash_table_01 on (setop_hash_table_01.a = setop_hash_table_03.a);
create index index_on_hash_01 on setop_hash_table_01(a);
create index index_on_hash_02 on setop_hash_table_02(a);
create index index_on_hash_03 on setop_hash_table_03(b);
create index index_on_hash_04 on setop_hash_table_04(a);
create index index_on_replication_01 on setop_replication_table_01(a);
create index index_on_replication_02 on setop_replication_table_02(a);
create index index_on_replication_03 on setop_replication_table_03(a);
insert into setop_hash_table_01 values (generate_series(1,2), generate_series(2,3), 'setop_hash_table_01');
insert into setop_hash_table_02 values (generate_series(1,3), generate_series(2,4), 'setop_hash_table_02');
insert into setop_hash_table_03 values (generate_series(1,4), generate_series(2,5), 'setop_hash_table_03');
insert into setop_hash_table_04 values (generate_series(1,5), generate_series(2,6), 'setop_hash_table_04');
insert into setop_replication_table_01 values (generate_series(1,2), generate_series(2,3), 'setop_replication_table_01');
insert into setop_replication_table_02 values (generate_series(1,3), generate_series(2,4), 'setop_replication_table_02');
insert into setop_replication_table_03 values (generate_series(1,4), generate_series(2,5), 'setop_replication_table_03');
insert into setop_hash_table_01 values (generate_series(1,2), generate_series(2,3), 't');
insert into setop_hash_table_02 values (generate_series(1,3), generate_series(2,4), 't');
insert into setop_hash_table_03 values (generate_series(1,4), generate_series(2,5), 't');
insert into setop_hash_table_04 values (generate_series(1,5), generate_series(2,6), 't');
insert into setop_replication_table_01 values (generate_series(1,2), generate_series(2,3), 't');
insert into setop_replication_table_02 values (generate_series(1,3), generate_series(2,4), 't');
insert into setop_replication_table_03 values (generate_series(1,4), generate_series(2,5), 't');
analyze setop_hash_table_01;
analyze setop_hash_table_02;
analyze setop_hash_table_03;
analyze setop_hash_table_04;
analyze setop_replication_table_01;
analyze setop_replication_table_02;
analyze setop_replication_table_03;
analyze pg_auth_members;
--
---- UNION ALL: Append
--
-- hash + hash + same distributeKey + Append executes on all DNs
select * from setop_hash_table_01 union all select * from setop_hash_table_02 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_02
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_hash_table_02
 3 | 4 | t
(10 rows)

select a, b from setop_hash_table_01 union all select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
 2 | 3
 2 | 3
 3 | 2
 3 | 2
 4 | 3
 4 | 3
 5 | 4
 5 | 4
(12 rows)

select * from setop_hash_table_01 where a = 1 union all select * from setop_hash_table_02 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 union all select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
(4 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 union all select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
 1 | 2 | t
(4 rows)

select a, b from setop_hash_table_01 where a = 1 union all select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
(2 rows)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 union all select * from setop_hash_table_03  order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_03
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_03
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_hash_table_03
 3 | 4 | t
 4 | 5 | setop_hash_table_03
 4 | 5 | t
(12 rows)

select a, b from setop_hash_table_01 union all select b, a from setop_hash_table_02  order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
 2 | 3
 2 | 3
 3 | 2
 3 | 2
 4 | 3
 4 | 3
(10 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 union all select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 union all select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
(4 rows)

-- hash + hash + type cast
select * from setop_hash_table_01 union all select * from setop_hash_table_04 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_04
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_04
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_hash_table_04
 3 | 4 | t
 4 | 5 | setop_hash_table_04
 4 | 5 | t
 5 | 6 | setop_hash_table_04
 5 | 6 | t
(14 rows)

select a, b from setop_hash_table_01 union all select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
 2 | 3
 2 | 3
 3 | 2
 3 | 2
 4 | 3
 4 | 3
 5 | 4
 5 | 4
 6 | 5
 6 | 5
(14 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 union all select * from setop_replication_table_01 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_replication_table_01
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_replication_table_01
 2 | 3 | t
 2 | 3 | t
(8 rows)

-- replication + replication
select * from setop_replication_table_01 union all select * from setop_replication_table_02 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_replication_table_01
 1 | 2 | setop_replication_table_02
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_replication_table_01
 2 | 3 | setop_replication_table_02
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_replication_table_02
 3 | 4 | t
(10 rows)

-- execute on cn + hash
select 1 from pg_auth_members union all select b from setop_hash_table_02 order by 1;
 ?column? 
----------
        2
        2
        3
        3
        4
        4
(6 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 union all select b from setop_hash_table_02 order by 1;
 a 
---
 1
 1
 2
 2
 2
 2
 3
 3
 4
 4
(10 rows)

select b from setop_hash_table_01 union all select b from setop_hash_table_02 order by 1;
 b 
---
 2
 2
 2
 2
 3
 3
 3
 3
 4
 4
(10 rows)

select ta1, tb1 from setop_view_table_12 union all select a, b from setop_hash_table_03 order by 1, 2;
 ta1 | tb1 
-----+-----
   1 |   2
   1 |   2
   1 |   2
   1 |   2
   1 |   2
   1 |   2
   2 |   3
   2 |   3
   2 |   3
   2 |   3
   2 |   3
   2 |   3
   3 |   4
   3 |   4
   4 |   5
   4 |   5
(16 rows)

select tb1, tb1 from setop_view_table_12 union all select a, b from setop_hash_table_03 order by 1, 2;
 tb1 | tb1 
-----+-----
   1 |   2
   1 |   2
   2 |   2
   2 |   2
   2 |   2
   2 |   2
   2 |   3
   2 |   3
   3 |   3
   3 |   3
   3 |   3
   3 |   3
   3 |   4
   3 |   4
   4 |   5
   4 |   5
(16 rows)

SELECT 1 AS one union all SELECT 1.1::float8  order by 1;
 one 
-----
   1
 1.1
(2 rows)

--
---- UNION ALL: Append: maybe MergeAppend
--
set enable_sort = false;
select * from setop_hash_table_01 union all select * from setop_hash_table_02 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_02
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_hash_table_02
 3 | 4 | t
(10 rows)

select a, b from setop_hash_table_01 union all select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 1
 2 | 1
 2 | 3
 2 | 3
 3 | 2
 3 | 2
 4 | 3
 4 | 3
 5 | 4
 5 | 4
(12 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 union all select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
 1 | 2 | t
(4 rows)

select a, b from setop_hash_table_01 where a = 1 union all select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
(2 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 union all select * from setop_replication_table_01 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_replication_table_01
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_replication_table_01
 2 | 3 | t
 2 | 3 | t
(8 rows)

-- replication + replication
select * from setop_replication_table_01 union all select * from setop_replication_table_02 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_replication_table_01
 1 | 2 | setop_replication_table_02
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_replication_table_01
 2 | 3 | setop_replication_table_02
 2 | 3 | t
 2 | 3 | t
 3 | 4 | setop_replication_table_02
 3 | 4 | t
(10 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 union all select b from setop_hash_table_02 order by 1;
 a 
---
 1
 1
 2
 2
 2
 2
 3
 3
 4
 4
(10 rows)

select b from setop_hash_table_01 union all select b from setop_hash_table_02 order by 1;
 b 
---
 2
 2
 2
 2
 3
 3
 3
 3
 4
 4
(10 rows)

reset enable_sort;
--
-- UNION
--
-- hash + hash + same distributeKey + Append executes on all DNs
select * from setop_hash_table_01 union select * from setop_hash_table_02 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_02
 2 | 3 | t
 3 | 4 | setop_hash_table_02
 3 | 4 | t
(8 rows)

select a, b from setop_hash_table_01 union select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 1
 2 | 3
 3 | 2
 4 | 3
 5 | 4
(6 rows)

select * from setop_hash_table_01 where a = 1 union select * from setop_hash_table_02 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 union select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 1
(2 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 union select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_02
 1 | 2 | t
(3 rows)

select a, b from setop_hash_table_01 where a = 1 union select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
(1 row)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 union select * from setop_hash_table_03 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_03
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_03
 2 | 3 | t
 3 | 4 | setop_hash_table_03
 3 | 4 | t
 4 | 5 | setop_hash_table_03
 4 | 5 | t
(10 rows)

select a, b from setop_hash_table_01 union select b, a from setop_hash_table_02 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 1
 2 | 3
 3 | 2
 4 | 3
(5 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 union select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 union select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 1
(2 rows)

-- hash + hash + type cast
select * from setop_hash_table_01 union select * from setop_hash_table_04 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_04
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_04
 2 | 3 | t
 3 | 4 | setop_hash_table_04
 3 | 4 | t
 4 | 5 | setop_hash_table_04
 4 | 5 | t
 5 | 6 | setop_hash_table_04
 5 | 6 | t
(12 rows)

select a, b from setop_hash_table_01 union select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 1
 2 | 3
 3 | 2
 4 | 3
 5 | 4
 6 | 5
(7 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 union select * from setop_replication_table_01 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_replication_table_01
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_replication_table_01
 2 | 3 | t
(6 rows)

-- replication + replication
select * from setop_replication_table_01 union select * from setop_replication_table_02 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_replication_table_01
 1 | 2 | setop_replication_table_02
 1 | 2 | t
 2 | 3 | setop_replication_table_01
 2 | 3 | setop_replication_table_02
 2 | 3 | t
 3 | 4 | setop_replication_table_02
 3 | 4 | t
(8 rows)

-- execute on cn + hash
select 1 from pg_auth_members union select b from setop_hash_table_02 order by 1;
 ?column? 
----------
        2
        3
        4
(3 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 union select b from setop_hash_table_02 order by 1;
 a 
---
 1
 2
 3
 4
(4 rows)

select b from setop_hash_table_01 union select b from setop_hash_table_02 order by 1;
 b 
---
 2
 3
 4
(3 rows)

select ta1, tb1 from setop_view_table_12 union select a, b from setop_hash_table_03 order by 1;
 ta1 | tb1 
-----+-----
   1 |   2
   2 |   3
   3 |   4
   4 |   5
(4 rows)

select tb1, tb1 from setop_view_table_12 union select a, b from setop_hash_table_03 order by 1, 2;
 tb1 | tb1 
-----+-----
   1 |   2
   2 |   2
   2 |   3
   3 |   3
   3 |   4
   4 |   5
(6 rows)

SELECT 1 AS one UNION SELECT 1.1::float8;
 one 
-----
   1
 1.1
(2 rows)

--
---- INTERSECT ALL
--
-- hash + hash + same distributeKey + Append executes on all DNs
select * from setop_hash_table_01 intersect all select * from setop_hash_table_02 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect all select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
(0 rows)

select * from setop_hash_table_01 where a = 1 intersect all select * from setop_hash_table_02 where b = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
(0 rows)

select a, b from setop_hash_table_01 where a = 1 intersect all select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 intersect all select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
(1 row)

select a, b from setop_hash_table_01 where a = 1 intersect all select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 intersect all select * from setop_hash_table_03 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect all select b, a from setop_hash_table_02 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 intersect all select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
(0 rows)

select a, b from setop_hash_table_01 where a = 1 intersect all select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + type cast
select * from setop_hash_table_01 intersect all select * from setop_hash_table_04 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect all select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 intersect all select * from setop_replication_table_01 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

-- replication + replication
select * from setop_replication_table_01 intersect all select * from setop_replication_table_02 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

-- execute on cn + hash
select 1 from pg_auth_members intersect all select b from setop_hash_table_02 order by 1;
 ?column? 
----------
(0 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 intersect all select b from setop_hash_table_02 order by 1;
 a 
---
 2
 2
(2 rows)

select b from setop_hash_table_01 intersect all select b from setop_hash_table_02 order by 1;
 b 
---
 2
 2
 3
 3
(4 rows)

select * from setop_view_table_12 intersect all select * from setop_view_table_23 order by 1, 2, 3;
 ta1 | tb1 | ta2 | tb2 
-----+-----+-----+-----
   1 |   2 |   1 |   2
   1 |   2 |   1 |   2
   1 |   2 |   1 |   2
   1 |   2 |   1 |   2
   2 |   3 |   2 |   3
   2 |   3 |   2 |   3
   2 |   3 |   2 |   3
   2 |   3 |   2 |   3
(8 rows)

SELECT 1 AS one intersect all SELECT 1.1::float8 order by 1;
 one 
-----
(0 rows)

--
---- INTERSECT
--
-- hash + hash + same distributeKey + Append executes on all DNs
select * from setop_hash_table_01 intersect select * from setop_hash_table_02 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
(0 rows)

select * from setop_hash_table_01 where a = 1 intersect select * from setop_hash_table_02 where b = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
(0 rows)

select a, b from setop_hash_table_01 where a = 1 intersect select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 intersect select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
(1 row)

select a, b from setop_hash_table_01 where a = 1 intersect select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 intersect select * from setop_hash_table_03 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect select b, a from setop_hash_table_02 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 intersect select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b | c 
---+---+---
(0 rows)

select a, b from setop_hash_table_01 where a = 1 intersect select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + hash + type cast
select * from setop_hash_table_01 intersect select * from setop_hash_table_04 order by 1, 2, 3;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

select a, b from setop_hash_table_01 intersect select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
(0 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 intersect select * from setop_replication_table_01 order by 1, 2;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

-- replication + replication
select * from setop_replication_table_01 intersect select * from setop_replication_table_02 order by 1, 2;
 a | b | c 
---+---+---
 1 | 2 | t
 2 | 3 | t
(2 rows)

-- execute on cn + hash
select 1 from pg_auth_members intersect select b from setop_hash_table_02 order by 1;
 ?column? 
----------
(0 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 intersect select b from setop_hash_table_02 order by 1;
 a 
---
 2
(1 row)

select b from setop_hash_table_01 intersect select b from setop_hash_table_02 order by 1;
 b 
---
 2
 3
(2 rows)

select * from setop_view_table_12 intersect select * from setop_view_table_23 order by 1, 2, 3;
 ta1 | tb1 | ta2 | tb2 
-----+-----+-----+-----
   1 |   2 |   1 |   2
   2 |   3 |   2 |   3
(2 rows)

SELECT 1 AS one intersect SELECT 1.1::float8 order by 1;
 one 
-----
(0 rows)

--
----EXCEPT ALL 
--
-- hash + hash + same distributeKey + Append executes on all DNs
select * from setop_hash_table_01 except all select * from setop_hash_table_02 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except all select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 3
 2 | 3
(4 rows)

select * from setop_hash_table_01 where a = 1 except all select * from setop_hash_table_02 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 except all select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
(2 rows)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 except all select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
(1 row)

select a, b from setop_hash_table_01 where a = 1 except all select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
(2 rows)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 except all select * from setop_hash_table_03 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except all select b, a from setop_hash_table_02 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 3
 2 | 3
(4 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 except all select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 except all select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
(2 rows)

-- hash + hash + type cast
select * from setop_hash_table_01 except all select * from setop_hash_table_04 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except all select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
 1 | 2
 1 | 2
 2 | 3
 2 | 3
(4 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 except all select * from setop_replication_table_01 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

-- replication + replication
select * from setop_replication_table_01 except all select * from setop_replication_table_02 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_replication_table_01
 2 | 3 | setop_replication_table_01
(2 rows)

-- execute on cn + hash
select 1 from pg_auth_members except all select b from setop_hash_table_02 order by 1;
 ?column? 
----------
(0 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 except all select b from setop_hash_table_02 order by 1;
 a 
---
 1
 1
(2 rows)

select b from setop_hash_table_01 except all select b from setop_hash_table_02 order by 1;
 b 
---
(0 rows)

select * from setop_view_table_12 except all select * from setop_view_table_23 order by 1, 2, 3;
 ta1 | tb1 | ta2 | tb2 
-----+-----+-----+-----
(0 rows)

SELECT 1 AS one except all SELECT 1.1::float8 order by 1;
 one 
-----
   1
(1 row)

--
----EXCEPT 
--
-- hash + hash + same distributeKey + Append executes on all DNs
explain (verbose on, costs off) select * from setop_hash_table_01 union all select * from setop_hash_table_02;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, (("*SELECT* 1".b)::numeric), "*SELECT* 1".c
   ->  Append
         ->  Streaming(type: REDISTRIBUTE ng: ng0->ng1)
               Output: "*SELECT* 1".a, (("*SELECT* 1".b)::numeric), "*SELECT* 1".c
               Distribute Key: "*SELECT* 1".a, (("*SELECT* 1".b)::numeric), "*SELECT* 1".c
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, "*SELECT* 1".c
                     ->  Seq Scan on nodegroup_setop_test.setop_hash_table_01
                           Output: setop_hash_table_01.a, setop_hash_table_01.b, setop_hash_table_01.c
                           Distribute Key: setop_hash_table_01.a
         ->  Seq Scan on nodegroup_setop_test.setop_hash_table_02
               Output: setop_hash_table_02.a, setop_hash_table_02.b, setop_hash_table_02.c
               Distribute Key: setop_hash_table_02.a
(14 rows)

select * from setop_hash_table_01 except select * from setop_hash_table_02 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except select b, a from setop_hash_table_03 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 3
(2 rows)

select * from setop_hash_table_01 where a = 1 except select * from setop_hash_table_02 where b = s1 order by 1, 2, 3;
ERROR:  column "s1" does not exist
LINE 1: ...xcept select * from setop_hash_table_02 where b = s1 order b...
                                                             ^
select a, b from setop_hash_table_01 where a = 1 except select b, a from setop_hash_table_03 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
(1 row)

-- hash + hash + same distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 except select * from setop_hash_table_02 where a = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
(1 row)

select a, b from setop_hash_table_01 where a = 1 except select b, a from setop_hash_table_03 where b = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
(1 row)

-- hash + hash + different distributeKey + Append executes on all DNs
select * from setop_hash_table_01 except select * from setop_hash_table_03 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except select b, a from setop_hash_table_02 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 3
(2 rows)

-- hash + hash + different distributeKey + Append executes on special DN
select * from setop_hash_table_01 where a = 1 except select * from setop_hash_table_03 where b = 1 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | t
(2 rows)

select a, b from setop_hash_table_01 where a = 1 except select b, a from setop_hash_table_02 where a = 1 order by 1, 2;
 a | b 
---+---
 1 | 2
(1 row)

-- hash + hash + type cast
select * from setop_hash_table_01 except select * from setop_hash_table_04 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

select a, b from setop_hash_table_01 except select b, a from setop_hash_table_04 order by 1, 2;
 a | b 
---+---
 1 | 2
 2 | 3
(2 rows)

-- hash + replication  + Append executes on special DN
select * from setop_hash_table_01 except select * from setop_replication_table_01 order by 1, 2, 3;
 a | b |          c          
---+---+---------------------
 1 | 2 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
(2 rows)

-- replication + replication
select * from setop_replication_table_01 except select * from setop_replication_table_02 order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_replication_table_01
 2 | 3 | setop_replication_table_01
(2 rows)

-- execute on cn + hash
select 1 from pg_auth_members except select b from setop_hash_table_02 order by 1;
 ?column? 
----------
(0 rows)

-- targetlist dosenot contains distributeKey
select a from setop_hash_table_01 except select b from setop_hash_table_02 order by 1;
 a 
---
 1
(1 row)

select b from setop_hash_table_01 except select b from setop_hash_table_02 order by 1;
 b 
---
(0 rows)

select * from setop_view_table_12 except select * from setop_view_table_23 order by 1, 2, 3;
 ta1 | tb1 | ta2 | tb2 
-----+-----+-----+-----
(0 rows)

SELECT 1 AS one except SELECT 1.1::float8 order by 1;
 one 
-----
   1
(1 row)

--setop optimizer
explain (verbose on, costs off) select 'setop_hash_table_01',b from setop_hash_table_01 union select 'setop_hash_table_03',a from setop_hash_table_03;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: ('setop_hash_table_01'::text), setop_hash_table_01.b
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode7, datanode8, datanode9
   ->  HashAggregate
         Output: ('setop_hash_table_01'::text), setop_hash_table_01.b
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         Group By Key: ('setop_hash_table_01'::text), setop_hash_table_01.b
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: ('setop_hash_table_01'::text), setop_hash_table_01.b
                     Distribute Key: setop_hash_table_01.b
                     Spawn on: (ng0) datanode1, datanode2, datanode3
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.setop_hash_table_01
                           Output: 'setop_hash_table_01'::text, setop_hash_table_01.b
                           Distribute Key: setop_hash_table_01.a
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng2->ng0)
                     Output: ('setop_hash_table_03'::text), setop_hash_table_03.a
                     Distribute Key: setop_hash_table_03.a
                     Spawn on: (ng2) datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.setop_hash_table_03
                           Output: 'setop_hash_table_03'::text, setop_hash_table_03.a
                           Distribute Key: setop_hash_table_03.b
                           Exec Nodes: (ng2) datanode7, datanode8, datanode9
(27 rows)

select 'setop_hash_table_01',b from setop_hash_table_01 union select 'setop_hash_table_03',a from setop_hash_table_03 order by 1,2;
      ?column?       | b 
---------------------+---
 setop_hash_table_01 | 2
 setop_hash_table_01 | 3
 setop_hash_table_03 | 1
 setop_hash_table_03 | 2
 setop_hash_table_03 | 3
 setop_hash_table_03 | 4
(6 rows)

explain (verbose on, costs off) SELECT b FROM setop_hash_table_01 INTERSECT (((SELECT a FROM setop_hash_table_02 UNION SELECT b FROM setop_hash_table_03))) ORDER BY 1;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: (("*SELECT* 1".b)::bigint), (0)
   Merge Sort Key: (("*SELECT* 1".b)::bigint)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Sort
         Output: (("*SELECT* 1".b)::bigint), (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         Sort Key: (("*SELECT* 1".b)::bigint)
         ->  HashSetOp Intersect
               Output: (("*SELECT* 1".b)::bigint), (0)
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Append
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Streaming(type: REDISTRIBUTE)
                           Output: (("*SELECT* 1".b)::bigint), (0)
                           Distribute Key: (("*SELECT* 1".b)::bigint)
                           Spawn on: (ng0) datanode1, datanode2, datanode3
                           Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Subquery Scan on "*SELECT* 1"
                                 Output: "*SELECT* 1".b, 0
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
                                 ->  Seq Scan on nodegroup_setop_test.setop_hash_table_01
                                       Output: setop_hash_table_01.b
                                       Distribute Key: setop_hash_table_01.a
                                       Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Streaming(type: REDISTRIBUTE ng: ng1->ng0)
                           Output: (("*SELECT* 2".a)::bigint), (1)
                           Distribute Key: (("*SELECT* 2".a)::bigint)
                           Spawn on: (ng1) datanode4, datanode5, datanode6
                           Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Result
                                 Output: (("*SELECT* 2".a)::bigint), 1
                                 Exec Nodes: (ng1) datanode4, datanode5, datanode6
                                 ->  HashAggregate
                                       Output: (("*SELECT* 2".a)::bigint)
                                       Exec Nodes: (ng1) datanode4, datanode5, datanode6
                                       Group By Key: (("*SELECT* 2".a)::bigint)
                                       ->  Append
                                             Exec Nodes: (ng1) datanode4, datanode5, datanode6
                                             ->  Subquery Scan on "*SELECT* 2"
                                                   Output: "*SELECT* 2".a
                                                   Exec Nodes: (ng1) datanode4, datanode5, datanode6
                                                   ->  Seq Scan on nodegroup_setop_test.setop_hash_table_02
                                                         Output: setop_hash_table_02.a
                                                         Distribute Key: setop_hash_table_02.a
                                                         Exec Nodes: (ng1) datanode4, datanode5, datanode6
                                             ->  Streaming(type: REDISTRIBUTE ng: ng2->ng1)
                                                   Output: setop_hash_table_03.b
                                                   Distribute Key: setop_hash_table_03.b
                                                   Spawn on: (ng2) datanode7, datanode8, datanode9
                                                   Consumer Nodes: (ng1) datanode4, datanode5, datanode6
                                                   ->  Seq Scan on nodegroup_setop_test.setop_hash_table_03
                                                         Output: setop_hash_table_03.b
                                                         Distribute Key: setop_hash_table_03.b
                                                         Exec Nodes: (ng2) datanode7, datanode8, datanode9
(55 rows)

SELECT b FROM setop_hash_table_01 INTERSECT (((SELECT a FROM setop_hash_table_02 UNION SELECT b FROM setop_hash_table_03))) ORDER BY 1;
 b 
---
 2
 3
(2 rows)

--union all between replication and hash
explain (costs off) select * from setop_replication_table_01 except select * from setop_replication_table_02 
union all 
select setop_hash_table_01.a as ta1, setop_hash_table_01.b as tb1, setop_hash_table_01.c as tc1 from setop_hash_table_01 left join setop_hash_table_02 on (setop_hash_table_01.b = setop_hash_table_02.b);
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   ->  Append
         ->  Streaming(type: REDISTRIBUTE)
               ->  Result
                     ->  HashSetOp Except
                           ->  Append
                                 ->  Subquery Scan on "*SELECT* 1"
                                       ->  Seq Scan on setop_replication_table_01
                                 ->  Subquery Scan on "*SELECT* 2"
                                       ->  Seq Scan on setop_replication_table_02
         ->  Subquery Scan on "*SELECT* 3"
               ->  Hash Right Join
                     Hash Cond: (setop_hash_table_02.b = ((setop_hash_table_01.b)::numeric))
                     ->  Streaming(type: REDISTRIBUTE)
                           ->  Seq Scan on setop_hash_table_02
                     ->  Hash
                           ->  Streaming(type: REDISTRIBUTE ng: ng0->ng1)
                                 ->  Seq Scan on setop_hash_table_01
(18 rows)

select * from setop_replication_table_01 except select * from setop_replication_table_02 
union all 
select setop_hash_table_01.a as ta1, setop_hash_table_01.b as tb1, setop_hash_table_01.c as tc1 from setop_hash_table_01 left join setop_hash_table_02 on (setop_hash_table_01.b = setop_hash_table_02.b) 
order by 1, 2, 3;
 a | b |             c              
---+---+----------------------------
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_hash_table_01
 1 | 2 | setop_replication_table_01
 1 | 2 | t
 1 | 2 | t
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_hash_table_01
 2 | 3 | setop_replication_table_01
 2 | 3 | t
 2 | 3 | t
(10 rows)

explain (costs off) select distinct b*2/3+5 from setop_hash_table_01 union all select a from setop_hash_table_02 order by 1; 
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Merge Sort Key: ((((setop_hash_table_01.b * 2) / 3) + 5::double precision))
   ->  Sort
         Sort Key: ((((setop_hash_table_01.b * 2) / 3) + 5::double precision))
         ->  Append
               ->  Streaming(type: REDISTRIBUTE ng: group1->ng1)
                     ->  HashAggregate
                           Group By Key: ((((setop_hash_table_01.b * 2) / 3) + 5::double precision))
                           ->  Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                 ->  HashAggregate
                                       Group By Key: (((setop_hash_table_01.b * 2) / 3) + 5::double precision)
                                       ->  Seq Scan on setop_hash_table_01
               ->  Subquery Scan on "*SELECT* 2"
                     ->  Seq Scan on setop_hash_table_02
(14 rows)

select distinct b*2/3+5 from setop_replication_table_01 union all select a from setop_replication_table_02 order by 1; 
     ?column?     
------------------
                1
                1
                2
                2
                3
                3
 6.33333333333333
                7
(8 rows)

drop table setop_hash_table_01 cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to view setop_view_table_12
drop cascades to view setop_view_table_31
drop table setop_hash_table_02 cascade;
NOTICE:  drop cascades to view setop_view_table_23
drop table setop_hash_table_03 cascade;
drop table setop_hash_table_04 cascade;
drop table setop_replication_table_01 cascade;
drop table setop_replication_table_02 cascade;
drop table setop_replication_table_03 cascade;
--Test union
create table test_union_1(a int, b int, c int) distribute by hash(a, b) to group ng0;
create table test_union_2(a int, b int, c int) distribute by hash(a, b) to group ng5;
explain (verbose on, costs off) select a, b from  test_union_1 union all select a, b from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: test_union_1.a, test_union_1.b
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Append
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Seq Scan on nodegroup_setop_test.test_union_1
               Output: test_union_1.a, test_union_1.b
               Distribute Key: test_union_1.a, test_union_1.b
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
               Output: test_union_2.a, test_union_2.b
               Distribute Key: test_union_2.a, test_union_2.b
               Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
               Consumer Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Seq Scan on nodegroup_setop_test.test_union_2
                     Output: test_union_2.a, test_union_2.b
                     Distribute Key: test_union_2.a, test_union_2.b
                     Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(18 rows)

explain (verbose on, costs off) select a, b from  test_union_1 union all select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: test_union_1.a, test_union_1.b
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Append
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Seq Scan on nodegroup_setop_test.test_union_1
               Output: test_union_1.a, test_union_1.b
               Distribute Key: test_union_1.a, test_union_1.b
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
               Output: test_union_2.b, test_union_2.c
               Distribute Key: test_union_2.b, test_union_2.c
               Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
               Consumer Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Seq Scan on nodegroup_setop_test.test_union_2
                     Output: test_union_2.b, test_union_2.c
                     Distribute Key: test_union_2.a, test_union_2.b
                     Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(18 rows)

explain (verbose on, costs off) select a, b from  test_union_1 union all select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: test_union_1.a, test_union_1.b
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Append
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Seq Scan on nodegroup_setop_test.test_union_1
               Output: test_union_1.a, test_union_1.b
               Distribute Key: test_union_1.a, test_union_1.b
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
               Output: test_union_2.b, test_union_2.a
               Distribute Key: test_union_2.b, test_union_2.a
               Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
               Consumer Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Seq Scan on nodegroup_setop_test.test_union_2
                     Output: test_union_2.b, test_union_2.a
                     Distribute Key: test_union_2.a, test_union_2.b
                     Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(18 rows)

explain (verbose on, costs off) select b, a from  test_union_1 union all select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: test_union_1.b, test_union_1.a
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Append
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Seq Scan on nodegroup_setop_test.test_union_1
               Output: test_union_1.b, test_union_1.a
               Distribute Key: test_union_1.a, test_union_1.b
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
               Output: test_union_2.b, test_union_2.a
               Distribute Key: test_union_2.b, test_union_2.a
               Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
               Consumer Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Seq Scan on nodegroup_setop_test.test_union_2
                     Output: test_union_2.b, test_union_2.a
                     Distribute Key: test_union_2.a, test_union_2.b
                     Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(18 rows)

explain (verbose on, costs off) select b, c from  test_union_1 union all select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: test_union_1.b, test_union_1.c
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  Append
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Seq Scan on nodegroup_setop_test.test_union_1
               Output: test_union_1.b, test_union_1.c
               Distribute Key: test_union_1.a, test_union_1.b
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
               Output: test_union_2.b, test_union_2.c
               Distribute Key: test_union_2.b, test_union_2.c
               Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
               Consumer Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Seq Scan on nodegroup_setop_test.test_union_2
                     Output: test_union_2.b, test_union_2.c
                     Distribute Key: test_union_2.a, test_union_2.b
                     Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(18 rows)

explain (verbose on, costs off) select a, b from  test_union_1 intersect select a, b from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".a, "*SELECT* 2".b, (1)
                     Distribute Key: "*SELECT* 2".a, "*SELECT* 2".b
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".a, "*SELECT* 2".b, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.a, test_union_2.b
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select a, b from  test_union_1 intersect select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".c, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".c
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".c, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.c
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select a, b from  test_union_1 intersect select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".a, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".a
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".a, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.a
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select b, a from  test_union_1 intersect select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".a, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".b, "*SELECT* 1".a, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".b, "*SELECT* 1".a, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.b, test_union_1.a
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".a, (1)
                     Distribute Key: "*SELECT* 2".a, "*SELECT* 2".b
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".a, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.a
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select b, c from  test_union_1 intersect select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
                     Distribute Key: "*SELECT* 1".b, "*SELECT* 1".c
                     Spawn on: (ng0) datanode1, datanode2, datanode3
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".b, "*SELECT* 1".c, 0
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: test_union_1.b, test_union_1.c
                                 Distribute Key: test_union_1.a, test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".c, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".c
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".c, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.c
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(32 rows)

explain (verbose on, costs off) select a, b from  test_union_1 minus select a, b from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Except
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".a, "*SELECT* 2".b, (1)
                     Distribute Key: "*SELECT* 2".a, "*SELECT* 2".b
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".a, "*SELECT* 2".b, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.a, test_union_2.b
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select a, b from  test_union_1 minus select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Except
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".c, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".c
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".c, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.c
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select a, b from  test_union_1 minus select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Except
         Output: "*SELECT* 1".a, "*SELECT* 1".b, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".a, "*SELECT* 1".b, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.a, test_union_1.b
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".a, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".a
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".a, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.a
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select b, a from  test_union_1 minus select b, a from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".a, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Except
         Output: "*SELECT* 1".b, "*SELECT* 1".a, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Subquery Scan on "*SELECT* 1"
                     Output: "*SELECT* 1".b, "*SELECT* 1".a, 0
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Seq Scan on nodegroup_setop_test.test_union_1
                           Output: test_union_1.b, test_union_1.a
                           Distribute Key: test_union_1.a, test_union_1.b
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".a, (1)
                     Distribute Key: "*SELECT* 2".a, "*SELECT* 2".b
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".a, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.a
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(27 rows)

explain (verbose on, costs off) select b, c from  test_union_1 minus select b, c from  test_union_2;
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3, datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
   ->  HashSetOp Except
         Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: "*SELECT* 1".b, "*SELECT* 1".c, (0)
                     Distribute Key: "*SELECT* 1".b, "*SELECT* 1".c
                     Spawn on: (ng0) datanode1, datanode2, datanode3
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".b, "*SELECT* 1".c, 0
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: test_union_1.b, test_union_1.c
                                 Distribute Key: test_union_1.a, test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: ng5->ng0)
                     Output: "*SELECT* 2".b, "*SELECT* 2".c, (1)
                     Distribute Key: "*SELECT* 2".b, "*SELECT* 2".c
                     Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: "*SELECT* 2".b, "*SELECT* 2".c, 1
                           Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                           ->  Seq Scan on nodegroup_setop_test.test_union_2
                                 Output: test_union_2.b, test_union_2.c
                                 Distribute Key: test_union_2.a, test_union_2.b
                                 Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
(32 rows)

explain (verbose on, costs off) select b, substr(c, 1, 3), c from  test_union_1 minus (select 1, t2.b::varchar(10), t1.c from (select a,b,case c when 1 then 1 else null end as c from test_union_2 where b<0) t1 right join test_union_2 t2 on t1.b=t2.c group by 1, 2, 3);
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c, nodegroup_setop_test.test_union_2.a, nodegroup_setop_test.test_union_2.b, nodegroup_setop_test.test_union_2.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".substr, "*SELECT* 1".c, (0)
   Node/s: All datanodes
   ->  HashSetOp Except
         Output: "*SELECT* 1".b, "*SELECT* 1".substr, "*SELECT* 1".c, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: "*SELECT* 1".b, "*SELECT* 1".substr, "*SELECT* 1".c, (0)
                     Distribute Key: "*SELECT* 1".b, "*SELECT* 1".substr, "*SELECT* 1".c
                     Spawn on: (ng0) datanode1, datanode2, datanode3
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".b, "*SELECT* 1".substr, "*SELECT* 1".c, 0
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: test_union_1.b, substr((test_union_1.c)::text, 1, 3), test_union_1.c
                                 Distribute Key: test_union_1.a, test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE ng: group1->ng0)
                     Output: (1), (("*SELECT* 2".b)::text), "*SELECT* 2".c, (1)
                     Distribute Key: (1), (("*SELECT* 2".b)::text), "*SELECT* 2".c
                     Spawn on: All datanodes
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 2"
                           Output: 1, ("*SELECT* 2".b)::text, "*SELECT* 2".c, 1
                           Exec Nodes: All datanodes
                           ->  HashAggregate
                                 Output: (1), ((t2.b)::character varying(10)), (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                 Exec Nodes: All datanodes
                                 Group By Key: (1), ((t2.b)::character varying(10)), (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                 ->  Streaming(type: REDISTRIBUTE ng: ng5->group1)
                                       Output: (1), ((t2.b)::character varying(10)), (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                       Distribute Key: ((t2.b)::character varying(10)), (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                       Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                       Consumer Nodes: All datanodes
                                       ->  Hash Left Join
                                             Output: 1, (t2.b)::character varying(10), (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                             Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                             Hash Cond: (t2.c = test_union_2.b)
                                             ->  Streaming(type: REDISTRIBUTE)
                                                   Output: t2.b, t2.c
                                                   Distribute Key: t2.c
                                                   Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                   Consumer Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                   ->  Seq Scan on nodegroup_setop_test.test_union_2 t2
                                                         Output: t2.b, t2.c
                                                         Distribute Key: t2.a, t2.b
                                                         Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                             ->  Hash
                                                   Output: test_union_2.b, (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                                   Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                   ->  Streaming(type: REDISTRIBUTE)
                                                         Output: test_union_2.b, (CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END)
                                                         Distribute Key: test_union_2.b
                                                         Spawn on: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                         Consumer Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                         ->  Seq Scan on nodegroup_setop_test.test_union_2
                                                               Output: test_union_2.b, CASE test_union_2.c WHEN 1 THEN 1 ELSE NULL::integer END
                                                               Distribute Key: test_union_2.a, test_union_2.b
                                                               Exec Nodes: (ng5) datanode4, datanode5, datanode6, datanode7, datanode8, datanode9
                                                               Filter: (test_union_2.b < 0)
(63 rows)

explain (verbose on, costs off) SELECT b,a,c FROM test_union_1 INTERSECT (((SELECT a,b,c FROM test_union_1 UNION ALL SELECT a,b,c FROM test_union_1)));
WARNING:  Statistics in some tables or columns(nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Output: "*SELECT* 1".b, "*SELECT* 1".a, "*SELECT* 1".c, (0)
   Node/s: (GenGroup) datanode1, datanode2, datanode3
   ->  HashSetOp Intersect
         Output: "*SELECT* 1".b, "*SELECT* 1".a, "*SELECT* 1".c, (0)
         Exec Nodes: (ng0) datanode1, datanode2, datanode3
         ->  Append
               Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Streaming(type: REDISTRIBUTE)
                     Output: "*SELECT* 1".b, "*SELECT* 1".a, "*SELECT* 1".c, (0)
                     Distribute Key: "*SELECT* 1".b, "*SELECT* 1".a
                     Spawn on: (ng0) datanode1, datanode2, datanode3
                     Consumer Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Subquery Scan on "*SELECT* 1"
                           Output: "*SELECT* 1".b, "*SELECT* 1".a, "*SELECT* 1".c, 0
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.c
                                 Distribute Key: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
               ->  Result
                     Output: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c, 1
                     Exec Nodes: (ng0) datanode1, datanode2, datanode3
                     ->  Append
                           Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c
                                 Distribute Key: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
                           ->  Seq Scan on nodegroup_setop_test.test_union_1
                                 Output: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b, nodegroup_setop_test.test_union_1.c
                                 Distribute Key: nodegroup_setop_test.test_union_1.a, nodegroup_setop_test.test_union_1.b
                                 Exec Nodes: (ng0) datanode1, datanode2, datanode3
(33 rows)

create table income_band
(
    ib_income_band_sk         integer               not null,
    ib_lower_bound            integer                       ,
    ib_upper_bound            integer
)
distribute by replication to group ng0;
create table store
(
    s_store_sk                integer               not null,
    s_store_id                char(16)              not null,
    s_manager                 varchar(40)                   ,
	s_market_id               integer                       ,
    s_company_id              integer
)
distribute by replication to group ng1;
create table call_center
(
    cc_call_center_sk         integer               not null,
    cc_call_center_id         char(16)              not null,
    cc_city                   varchar(60)
)
distribute by replication to group ng2;
create table item
(
    i_item_sk                 integer               not null,
    i_item_id                 char(16)              not null,
    i_class_id                integer
)
distribute by hash (i_item_sk) to group ng3;
select s_market_id
          from store
         inner join item
            on i_class_id = s_company_id
         where s_manager like '%a%'
         group by 1
        union
        select 1
          from call_center
         where cc_city like '%b%'
        union all 
        select count(*) from income_band;
 s_market_id 
-------------
           0
(1 row)

create table sales_transaction_line
(
    SALES_TRAN_ID number(27,8) NOT NULL ,
    SALES_TRAN_LINE_NUM SMALLINT NOT NULL ,
    ITEM_ID number(18,9),
    ITEM_QTY NUMBER(5) NOT NULL ,
    UNIT_SELLING_PRICE_AMT DECIMAL(18,4) NOT NULL ,
    UNIT_COST_AMT DECIMAL(8,4) NULL ,
    TRAN_LINE_STATUS_CD CHAR(1) NULL ,
    SALES_TRAN_LINE_START_DTTM TIMESTAMP(6) NULL ,
    TRAN_LINE_SALES_TYPE_CD CHAR(2) NULL ,
    SALES_TRAN_LINE_END_DTTM TIMESTAMP(6) NULL ,
    TRAN_LINE_DATE DATE NULL ,
    TX_TIME INTEGER NOT NULL ,
    LOCATION INTEGER NULL ,
    LINE_RUN_DURATION_SECONDS  interval  ,
    LINE_RUN_DURATION_MINUTES  interval ,
    LINE_RUN_DURATION_HOURS    interval  ,
    LINE_RUN_DURATION_DAYS     interval ,
    unique(SALES_TRAN_ID,location) 
)  distribute by hash(sales_tran_id);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "sales_transaction_line_sales_tran_id_location_key" for table "sales_transaction_line"
create table party
(
    party_id varchar(10) not null ,
    party_type_cd char(4) not null ,
    party_firstname varchar(20) null ,
    party_lastname varchar(20) null,
    party_street_address varchar(50) null,
    party_city char(30) null ,
    party_state char(2) null,
    party_zip char(5) null,
    party_info_source_type_cd char(4) null ,
    party_start_dt date null,
    party_first_purchase_dt date null,
    LOCATION_POINT VARCHAR(100) NULL ,
    ACTIVE_AREA VARCHAR(100) NULL ,
    ACTIVE_LINES VARCHAR(100) NULL ,
    KEY_LINE VARCHAR(100) NULL ,
    KEY_POINTS VARCHAR(100) NULL ,
    ALL_RELATED_GEO VARCHAR(100) NULL ,
primary key(party_id,party_type_cd)
)  distribute by hash(party_id);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "party_pkey" for table "party"
create table district
(
    district_cd varchar(50) not null ,
    district_name varchar(100) null,
    region_cd varchar(50) not null ,
    district_mgr_associate_id number(19,18) null,
primary key(district_cd)
)
distribute by hash(district_cd);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "district_pkey" for table "district"
create index i_district_1 on district (district_cd,district_mgr_associate_id) where district_mgr_associate_id > 2 and district_cd <= 'O';
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 3, 4,  0.12, 0.30, 0.40, 0.40, 'A' , NULL                           , 'A' , NULL                           , DATE '1970-01-01', 9, NULL);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 12345, 1,  1.3, 1.0, 1.0, 1.0, NULL, TIMESTAMP '1973-01-01 00:00:00', NULL, TIMESTAMP '1973-01-01 00:00:00', NULL             , 1,  1);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 1.2345, 2,  2.33, 2.0, 2.0, 2.0, 'C' , TIMESTAMP '1976-01-01 00:00:00', 'C' , TIMESTAMP '1976-01-01 00:00:00', DATE '1976-01-01', 2,  2);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 12.345, 1,  3.33, 3.0, 3.0, 3.0, 'D' , TIMESTAMP '1979-01-01 00:00:00', 'D' , TIMESTAMP '1979-01-01 00:00:00', DATE '1979-01-01', 3,  3);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 123.45, 4,  4.98, 4.0, 4.0, 4.0, NULL, TIMESTAMP '1982-01-01 00:00:00', 'E' , TIMESTAMP '1982-01-01 00:00:00', DATE '1982-01-01', 4, 14);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 1234.5, 5,  5.01, 5.0, 5.0, 5.0, 'F' , NULL                           , NULL, NULL                           , DATE '1985-01-01', 5,  5);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( -12345, 1,  5.01, 6.0, 6.0, 6.0, 'G' , TIMESTAMP '1988-01-01 00:00:00', 'G' , TIMESTAMP '1988-01-01 00:00:00', DATE '1988-01-01', 6, 16);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 1.2346, 7,  6, 7.0, 7.0, 7.0, 'H' , TIMESTAMP '1991-01-01 00:00:00', 'H' , TIMESTAMP '1991-01-01 00:00:00', DATE '1991-01-01', 7,  6);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 1.2347, 8,  6, 8.0, 8.0, 8.0, 'I' , TIMESTAMP '1994-01-01 00:00:00', 'I' , TIMESTAMP '1994-01-01 00:00:00', DATE '1994-01-01', 8,  5);
INSERT INTO SALES_TRANSACTION_LINE VALUES ( 1.2348, 9,  6, 9.0, 9.0, 9.0, 'J' , TIMESTAMP '1997-01-01 00:00:00', 'J' , TIMESTAMP '1997-01-01 00:00:00', DATE '1997-01-01', 9,  7);
INSERT INTO PARTY VALUES ('A', 'A', NULL, 'A' , NULL, 'A' , 'A' , 'A' , NULL, DATE '1970-01-01', NULL,'POINT(10 20)' ,'MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('B', 'B', 'B' , NULL, 'B' , NULL, 'B' , 'B' , 'B' , DATE '1973-01-01', DATE '1973-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('C', 'B', 'C' , 'C' , '  C ' , 'C' , NULL, 'C' , NULL, DATE '1976-01-01', DATE '1976-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('D', '  D', 'D' , NULL, 'D ' , 'D' , 'D' , '  D' , 'D' , NULL             , DATE '1979-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('E', 'E', NULL, 'E' , NULL, 'E' , ' ' , NULL, 'E' , DATE '1982-01-01', DATE '1982-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('F', 'F', 'F' , 'F' , 'F' , 'F' , NULL, 'F ' , ' ' , DATE '1985-01-01', DATE '1985-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('G', ' ', 'TTT GO TO BED' , 'G' , 'G' , 'G' , 'G' , 'F' , 'GOTO' , NULL             , NULL,'POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO PARTY VALUES ('H', 'H ', 'H' , 'H' , 'H' , 'TTT TO TO BED' , 'H' , 'G' , NULL, DATE '1991-01-01', DATE '1991-01-01','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))','LINESTRING(1 1, 2 2, 3 3, 4 4)','LINESTRING(1 1, 2 2, 3 3, 4 4)','POINT(10 20)','MULTIPOINT((1 1), (1 3), (6 3), (10 5), (20 1))');
INSERT INTO DISTRICT VALUES ('JAP', ' JAPAN', 'A', -9.223372036854775807);
INSERT INTO DISTRICT VALUES ('KOR', 'KOREA' , 'B', 3.2767);
INSERT INTO DISTRICT VALUES ('CHINA', 'SAINT LUCIA' , 'C', -3.2768);
INSERT INTO DISTRICT VALUES ('IND', 'CUBA' , 'G', NULL);
INSERT INTO DISTRICT VALUES ('AMER', ' ' , 'E', 2.147483647);
INSERT INTO DISTRICT VALUES ('MEX', NULL, 'F', NULL);
INSERT INTO DISTRICT VALUES ('NICAR', 'NICARAGUA' , 'F', 6.64738692398);
INSERT INTO DISTRICT VALUES ('COLOMA', 'COLOMABIA' , 'G', 7.2893908908);
analyze sales_transaction_line;
analyze party;
analyze district;
set enable_seqscan=off;
explain (costs off) SELECT 1
FROM sales_transaction_line ,
 (SELECT 1
 FROM district INNER JOIN party 
 ON (CASE WHEN party_state LIKE '_t_' THEN 'v' END) 
 NOT IN (SELECT tran_line_status_cd 
 FROM sales_transaction_line 
 WHERE TRAN_LINE_STATUS_CD IN (
 SELECT 'e' 
 FROM district 
 WHERE 1=0
 ORDER BY 1)
 ORDER BY 1)) dt
WHERE UNIT_COST_AMT NOT LIKE 'j%';
                                                                                                                                                                              QUERY PLAN                                                                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Streaming (type: GATHER)
   Node/s: All datanodes
   ->  Nested Loop Anti Join
         Join Filter: ((CASE WHEN (party.party_state ~~ '_t_'::text) THEN 'v'::text ELSE NULL::text END = (nodegroup_setop_test.sales_transaction_line.tran_line_status_cd)::text) OR (CASE WHEN (party.party_state ~~ '_t_'::text) THEN 'v'::text ELSE NULL::text END IS NULL) OR ((nodegroup_setop_test.sales_transaction_line.tran_line_status_cd)::text IS NULL))
         ->  Nested Loop
               ->  Nested Loop
                     ->  Seq Scan on sales_transaction_line
                           Filter: ((unit_cost_amt)::text !~~ 'j%'::text)
                     ->  Materialize
                           ->  Streaming(type: BROADCAST)
                                 Spawn on: All datanodes
                                 ->  Index Only Scan using district_pkey on district
               ->  Materialize
                     ->  Streaming(type: BROADCAST)
                           Spawn on: All datanodes
                           ->  Seq Scan on party
         ->  Sort
               Sort Key: nodegroup_setop_test.sales_transaction_line.tran_line_status_cd
               ->  Result
                     One-Time Filter: false
(20 rows)

reset current_schema;
drop schema nodegroup_setop_test cascade;
NOTICE:  drop cascades to 9 other objects
DETAIL:  drop cascades to table nodegroup_setop_test.test_union_1
drop cascades to table nodegroup_setop_test.test_union_2
drop cascades to table nodegroup_setop_test.income_band
drop cascades to table nodegroup_setop_test.store
drop cascades to table nodegroup_setop_test.call_center
drop cascades to table nodegroup_setop_test.item
drop cascades to table nodegroup_setop_test.sales_transaction_line
drop cascades to table nodegroup_setop_test.party
drop cascades to table nodegroup_setop_test.district
drop node group ng0;
drop node group ng1;
drop node group ng2;
drop node group ng3;
drop node group ng4;
drop node group ng5;
drop node group ng6;
