-- CHECK CONSTRAINT
CREATE TABLE TEST_CHECK_CONSTRAINT_A_1
(
	A INT4 CHECK(A <> 0),
	B INT 
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_CHECK_CONSTRAINT_A_1_P0 VALUES LESS THAN (50),
	PARTITION TEST_CHECK_CONSTRAINT_A_1_P1 VALUES LESS THAN (100),
	PARTITION TEST_CHECK_CONSTRAINT_A_1_P2 VALUES LESS THAN (MAXVALUE)
);
DROP TABLE IF EXISTS TEST_CHECK_CONSTRAINT_A_1;
--UNIQUE CONSTRAINT
CREATE TABLE TEST_UNIQUE_CONSTRAINT_B_1
(
	A INT4,
	B INT UNIQUE
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_B_1_P0 VALUES LESS THAN (50),
	PARTITION TEST_UNIQUE_CONSTRAINT_B_1_P1 VALUES LESS THAN (100),
	PARTITION TEST_UNIQUE_CONSTRAINT_B_1_P2 VALUES LESS THAN (MAXVALUE)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_UNIQUE_CONSTRAINT_A_1
(
	A INT4 UNIQUE,
	B INT
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_A_1_P0 VALUES LESS THAN (50),
	PARTITION TEST_UNIQUE_CONSTRAINT_A_1_P1 VALUES LESS THAN (100),
	PARTITION TEST_UNIQUE_CONSTRAINT_A_1_P2 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_constraint_a_1_a_key" for table "test_unique_constraint_a_1"
DROP TABLE IF EXISTS TEST_UNIQUE_CONSTRAINT_A_1;
CREATE TABLE TEST_UNIQUE_CONSTRAINT_A_2
(
	A INT4,
	B INT,
	UNIQUE(A)
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_A_2_P0 VALUES LESS THAN (50),
	PARTITION TEST_UNIQUE_CONSTRAINT_A_2_P1 VALUES LESS THAN (100),
	PARTITION TEST_UNIQUE_CONSTRAINT_A_2_P2 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_constraint_a_2_a_key" for table "test_unique_constraint_a_2"
DROP TABLE IF EXISTS TEST_UNIQUE_CONSTRAINT_A_2;
-- PRIMARY KEY CONSTRAINT
CREATE TABLE TEST_PRIMARY_KEY_CONSTRAINT_B_1
(
	A INT4,
	B INT PRIMARY KEY
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_B_1_P0 VALUES LESS THAN (50),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_B_1_P1 VALUES LESS THAN (100),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_B_1_P2 VALUES LESS THAN (MAXVALUE)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_PRIMARY_KEY_CONSTRAINT_A_1
(
	A INT4 PRIMARY KEY,
	B INT
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_1_P0 VALUES LESS THAN (50),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_1_P1 VALUES LESS THAN (100),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_1_P2 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_key_constraint_a_1_pkey" for table "test_primary_key_constraint_a_1"
DROP TABLE IF EXISTS TEST_PRIMARY_KEY_CONSTRAINT_A_1;
CREATE TABLE TEST_PRIMARY_KEY_CONSTRAINT_A_2
(
	A INT4,
	B INT,
	PRIMARY KEY(A)
)
PARTITION BY RANGE (A)
(
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_2_P0 VALUES LESS THAN (50),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_2_P1 VALUES LESS THAN (100),
	PARTITION TEST_PRIMARY_KEY_CONSTRAINT_A_2_P2 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_key_constraint_a_2_pkey" for table "test_primary_key_constraint_a_2"
DROP TABLE IF EXISTS TEST_PRIMARY_KEY_CONSTRAINT_A_2;
CREATE TABLE TEST_FOREIGN_KEY_PARTITIONED_SEFT 
(
	C1 INT PRIMARY KEY,
	C2 INT,
	FOREIGN KEY(C2) REFERENCES TEST_FOREIGN_KEY_PARTITIONED_SEFT(C1)
)
PARTITION BY RANGE (C1)
(
	PARTITION TEST_FOREIGN_KEY_PARTITIONED_SEFT_P0 VALUES LESS THAN (50),
	PARTITION TEST_FOREIGN_KEY_PARTITIONED_SEFT_P1 VALUES LESS THAN (100),
	PARTITION TEST_FOREIGN_KEY_PARTITIONED_SEFT_P2 VALUES LESS THAN (MAXVALUE)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_foreign_key_partitioned_seft_pkey" for table "test_foreign_key_partitioned_seft"
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
CREATE TABLE TEST_PK_CONSTRAINT_1
(
	A INT PRIMARY KEY,
	B INT,
	C INT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_PK_CONSTRAINT_1_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_PK_CONSTRAINT_1_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_PK_CONSTRAINT_2
(
	A INT,
	B INT PRIMARY KEY,
	C INT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_PK_CONSTRAINT_2_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_PK_CONSTRAINT_2_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_PK_CONSTRAINT_3
(
	A INT,
	B INT,
	C INT PRIMARY KEY
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_PK_CONSTRAINT_3_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_PK_CONSTRAINT_3_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_PK_CONSTRAINT_4
(
	A INT,
	B INT,
	C INT,
	PRIMARY KEY(A,C)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_PK_CONSTRAINT_4_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_PK_CONSTRAINT_4_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_PK_CONSTRAINT_5
(
	A INT,
	B INT,
	C INT,
	PRIMARY KEY(A,B)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_PK_CONSTRAINT_5_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_PK_CONSTRAINT_5_P1 VALUES LESS THAN (10, 10)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_pk_constraint_5_pkey" for table "test_pk_constraint_5"
DROP TABLE TEST_PK_CONSTRAINT_5;
CREATE TABLE TEST_UNIQUE_CONSTRAINT_1
(
	A INT UNIQUE,
	B INT,
	C INT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_1_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_UNIQUE_CONSTRAINT_1_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_UNIQUE_CONSTRAINT_2
(
	A INT,
	B INT UNIQUE,
	C INT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_2_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_UNIQUE_CONSTRAINT_2_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_UNIQUE_CONSTRAINT_3
(
	A INT,
	B INT,
	C INT UNIQUE
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_3_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_UNIQUE_CONSTRAINT_3_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_UNIQUE_CONSTRAINT_4
(
	A INT,
	B INT,
	C INT,
	UNIQUE(A,C)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_4_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_UNIQUE_CONSTRAINT_4_P1 VALUES LESS THAN (10, 10)
);
ERROR:  Invalid PRIMARY KEY/UNIQUE constraint for partitioned table
DETAIL:  Columns of PRIMARY KEY/UNIQUE constraint Must contain PARTITION KEY
CREATE TABLE TEST_UNIQUE_CONSTRAINT_5
(
	A INT,
	B INT,
	C INT,
	UNIQUE(A,B)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_UNIQUE_CONSTRAINT_5_P0 VALUES LESS THAN (0, 10),
	PARTITION TEST_UNIQUE_CONSTRAINT_5_P1 VALUES LESS THAN (10, 10)
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique_constraint_5_a_b_key" for table "test_unique_constraint_5"
DROP TABLE TEST_UNIQUE_CONSTRAINT_5;
CREATE TABLE TEST_PARTITION_FOREIGN_KEY
(
	A INT,
	B TEXT,
	C INT,
	D TEXT,
	FOREIGN KEY (A, B) REFERENCES TEST_ORDINARY_REFTABLE (A, B)
)
PARTITION BY RANGE (A, B)
(
	PARTITION TEST_PARTITION_FOREIGN_KEY_P1 VALUES LESS THAN (1, 'B'),
	PARTITION TEST_PARTITION_FOREIGN_KEY_P2 VALUES LESS THAN (4, 'E'),
	PARTITION TEST_PARTITION_FOREIGN_KEY_P3 VALUES LESS THAN (7, 'H')
);
ERROR:  relation "test_ordinary_reftable" does not exist
--
---- Tese For  ALTER TABLE  ADD table_constraint_using_index
--
--
---- prepare
--
CREATE TABLE TEST_TABLE_CONSTRAINT_USING_INDEX (A INT4, B INT)
PARTITION BY RANGE (A)
(
	PARTITION TEST_TABLE_CONSTRAINT_USING_INDEX_P0 VALUES LESS THAN (50),
	PARTITION TEST_TABLE_CONSTRAINT_USING_INDEX_P1 VALUES LESS THAN (100),
	PARTITION TEST_TABLE_CONSTRAINT_USING_INDEX_P2 VALUES LESS THAN (MAXVALUE)
);
with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
               relname                | parttype | partstrategy | boundaries |              parent               
--------------------------------------+----------+--------------+------------+-----------------------------------
 test_table_constraint_using_index    | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0 | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p1 | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p2 | p        | r            | {NULL}     | test_table_constraint_using_index
(4 rows)

--
----  ALTER TABLE  ADD table_constraint_using_index
--
-- partitioned index does not support index with expression columns
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (INT4UP(A)) LOCAL; --fail
ERROR:  unique index columns must contain the partition key and collation must be default collation
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (INT4UP(A)); --fail
ERROR:  partitioned table does not support global index
-- partitioned index does not support partial index 
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) WHERE (A < 100) LOCAL; --fail
ERROR:  syntax error at or near "LOCAL"
LINE 1: ...TEST_TABLE_CONSTRAINT_USING_INDEX (A) WHERE (A < 100) LOCAL;
                                                                 ^
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) WHERE (A < 100); --fail
ERROR:  partitioned table does not support global index
-- partitioned index does not support b-tree index without default sort ordering
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A DESC NULLS LAST) LOCAL;
with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index' or relname = 'index_on_test_table_constraint_using_index'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
                  relname                   | parttype | partstrategy |                   parent                   
--------------------------------------------+----------+--------------+--------------------------------------------
 test_table_constraint_using_index          | r        | r            | test_table_constraint_using_index
 test_table_constraint_using_index_p0       | p        | r            | test_table_constraint_using_index
 test_table_constraint_using_index_p0_a_idx | x        | n            | index_on_test_table_constraint_using_index
 test_table_constraint_using_index_p1       | p        | r            | test_table_constraint_using_index
 test_table_constraint_using_index_p1_a_idx | x        | n            | index_on_test_table_constraint_using_index
 test_table_constraint_using_index_p2       | p        | r            | test_table_constraint_using_index
 test_table_constraint_using_index_p2_a_idx | x        | n            | index_on_test_table_constraint_using_index
(7 rows)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT CON UNIQUE USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX; --fail
ERROR:  index "index_on_test_table_constraint_using_index" does not have default sorting behavior
LINE 1: ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT...
                                                          ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
DROP INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
-- If PRIMARY KEY is specified, then this command will attempt to do ALTER COLUMN SET NOT NULL against each index's column
INSERT INTO TEST_TABLE_CONSTRAINT_USING_INDEX VALUES (NULL, NULL);
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) LOCAL;
with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index' or relname = 'index_on_test_table_constraint_using_index'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
                  relname                   | parttype | partstrategy | boundaries |                   parent                   
--------------------------------------------+----------+--------------+------------+--------------------------------------------
 test_table_constraint_using_index          | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0       | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p0_a_idx | x        | n            |            | index_on_test_table_constraint_using_index
 test_table_constraint_using_index_p1       | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p1_a_idx | x        | n            |            | index_on_test_table_constraint_using_index
 test_table_constraint_using_index_p2       | p        | r            | {NULL}     | test_table_constraint_using_index
 test_table_constraint_using_index_p2_a_idx | x        | n            |            | index_on_test_table_constraint_using_index
(7 rows)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD PRIMARY KEY USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX; --fail
ERROR:  column "a" contains null values
DELETE FROM TEST_TABLE_CONSTRAINT_USING_INDEX;
INSERT INTO TEST_TABLE_CONSTRAINT_USING_INDEX VALUES (50, NULL);
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD PRIMARY KEY USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX; -- sucess
SELECT CON.CONNAME, CON.CONTYPE, CON.CONVALIDATED, CLA.RELNAME AS CONRELNAME FROM PG_CONSTRAINT CON LEFT JOIN PG_CLASS CLA ON(CON. CONRELID = CLA.OID) WHERE CLA.RELNAME = 'test_table_constraint_using_index' order by 1, 2, 3;
                  conname                   | contype | convalidated |            conrelname             
--------------------------------------------+---------+--------------+-----------------------------------
 index_on_test_table_constraint_using_index | p       | t            | test_table_constraint_using_index
(1 row)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX DROP CONSTRAINT INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
-- 1. If a constraint name is not provided, the constraint will be named the same as the index. 
-- 2. After this command is executed, the index is "owned" by the constraint
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) LOCAL;
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD PRIMARY KEY USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
SELECT CON.CONNAME, CON.CONTYPE, CON.CONVALIDATED, CLA.RELNAME AS CONRELNAME FROM PG_CONSTRAINT CON LEFT JOIN PG_CLASS CLA ON(CON. CONRELID = CLA.OID) WHERE CLA.RELNAME = 'test_table_constraint_using_index' order by 1, 2, 3;
                  conname                   | contype | convalidated |            conrelname             
--------------------------------------------+---------+--------------+-----------------------------------
 index_on_test_table_constraint_using_index | p       | t            | test_table_constraint_using_index
(1 row)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX DROP CONSTRAINT INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
               relname                | parttype | partstrategy | boundaries |              parent               
--------------------------------------+----------+--------------+------------+-----------------------------------
 test_table_constraint_using_index    | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0 | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p1 | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p2 | p        | r            | {NULL}     | test_table_constraint_using_index
(4 rows)

CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) LOCAL;
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD UNIQUE USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
SELECT CON.CONNAME, CON.CONTYPE, CON.CONVALIDATED, CLA.RELNAME AS CONRELNAME FROM PG_CONSTRAINT CON LEFT JOIN PG_CLASS CLA ON(CON. CONRELID = CLA.OID) WHERE CLA.RELNAME = 'test_table_constraint_using_index' order by 1, 2, 3;
                  conname                   | contype | convalidated |            conrelname             
--------------------------------------------+---------+--------------+-----------------------------------
 index_on_test_table_constraint_using_index | u       | t            | test_table_constraint_using_index
(1 row)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX DROP CONSTRAINT INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
               relname                | parttype | partstrategy | boundaries |              parent               
--------------------------------------+----------+--------------+------------+-----------------------------------
 test_table_constraint_using_index    | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0 | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p1 | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p2 | p        | r            | {NULL}     | test_table_constraint_using_index
(4 rows)

-- 1. If a constraint name is provided then the index will be renamed to match the constraint name. 
-- 2. After this command is executed, the index is "owned" by the constraint
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) LOCAL;
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT CON UNIQUE USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "index_on_test_table_constraint_using_index" to "con"
SELECT CON.CONNAME, CON.CONTYPE, CON.CONVALIDATED, CLA.RELNAME AS CONRELNAME FROM PG_CONSTRAINT CON LEFT JOIN PG_CLASS CLA ON(CON. CONRELID = CLA.OID) WHERE CLA.RELNAME = 'test_table_constraint_using_index' order by 1, 2, 3;
 conname | contype | convalidated |            conrelname             
---------+---------+--------------+-----------------------------------
 con     | u       | t            | test_table_constraint_using_index
(1 row)

with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index' or relname = 'con'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
                  relname                   | parttype | partstrategy | boundaries |              parent               
--------------------------------------------+----------+--------------+------------+-----------------------------------
 test_table_constraint_using_index          | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0       | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p0_a_idx | x        | n            |            | con
 test_table_constraint_using_index_p1       | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p1_a_idx | x        | n            |            | con
 test_table_constraint_using_index_p2       | p        | r            | {NULL}     | test_table_constraint_using_index
 test_table_constraint_using_index_p2_a_idx | x        | n            |            | con
(7 rows)

SELECT SCHEMANAME, TABLENAME, INDEXNAME FROM PG_INDEXES WHERE TABLENAME = 'test_table_constraint_using_index' order by 1, 2, 3;
 schemaname |             tablename             | indexname 
------------+-----------------------------------+-----------
 public     | test_table_constraint_using_index | con
(1 row)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT CON_PK PRIMARY KEY  USING INDEX CON;
ERROR:  index "con" is already associated with a constraint
LINE 1: ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT...
                                                          ^
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX DROP CONSTRAINT CON;
CREATE UNIQUE INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX ON TEST_TABLE_CONSTRAINT_USING_INDEX (A) LOCAL;
ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX ADD CONSTRAINT CON_PK PRIMARY KEY  USING INDEX INDEX_ON_TEST_TABLE_CONSTRAINT_USING_INDEX;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "index_on_test_table_constraint_using_index" to "con_pk"
SELECT CON.CONNAME, CON.CONTYPE, CON.CONVALIDATED, CLA.RELNAME AS CONRELNAME FROM PG_CONSTRAINT CON LEFT JOIN PG_CLASS CLA ON(CON. CONRELID = CLA.OID) WHERE CLA.RELNAME = 'test_table_constraint_using_index' order by 1, 2, 3;
 conname | contype | convalidated |            conrelname             
---------+---------+--------------+-----------------------------------
 con_pk  | p       | t            | test_table_constraint_using_index
(1 row)

with partitioned_obj_oids as
(
	select oid 
	from pg_class 
	where relname = 'test_table_constraint_using_index' or relname = 'con_pk'
)
SELECT P.RELNAME, P.PARTTYPE, P.PARTSTRATEGY, P.BOUNDARIES, C.RELNAME AS PARENT FROM PG_PARTITION P LEFT JOIN PG_CLASS C ON (P.PARENTID = C.OID) 
	where P.parentid in (select oid from partitioned_obj_oids)
	order by 1, 2, 3;
                  relname                   | parttype | partstrategy | boundaries |              parent               
--------------------------------------------+----------+--------------+------------+-----------------------------------
 test_table_constraint_using_index          | r        | r            |            | test_table_constraint_using_index
 test_table_constraint_using_index_p0       | p        | r            | {50}       | test_table_constraint_using_index
 test_table_constraint_using_index_p0_a_idx | x        | n            |            | con_pk
 test_table_constraint_using_index_p1       | p        | r            | {100}      | test_table_constraint_using_index
 test_table_constraint_using_index_p1_a_idx | x        | n            |            | con_pk
 test_table_constraint_using_index_p2       | p        | r            | {NULL}     | test_table_constraint_using_index
 test_table_constraint_using_index_p2_a_idx | x        | n            |            | con_pk
(7 rows)

SELECT SCHEMANAME, TABLENAME, INDEXNAME FROM PG_INDEXES WHERE TABLENAME = 'test_table_constraint_using_index' order by 1, 2, 3;
 schemaname |             tablename             | indexname 
------------+-----------------------------------+-----------
 public     | test_table_constraint_using_index | con_pk
(1 row)

ALTER TABLE TEST_TABLE_CONSTRAINT_USING_INDEX DROP CONSTRAINT CON_PK;
-- 
---- clean up
--
DROP TABLE TEST_TABLE_CONSTRAINT_USING_INDEX;
--
---- FOREIGN KEY CONSTRAINT
--
-- PREPARE FOR FOREIGN KEY CONSTRAINT
CREATE TABLE FOREIGN_KEY_ORDINARY_REFTABLE
(
	A INT,
	B INT
);
ALTER TABLE FOREIGN_KEY_ORDINARY_REFTABLE ADD UNIQUE(A, b); 
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "foreign_key_ordinary_reftable_a_b_key" for table "foreign_key_ordinary_reftable"
--ALTER TABLE FOREIGN_KEY_ORDINARY_REFTABLE ADD PRIMARY KEY (A, B); 
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3, NULL), (NULL, NULL);
CREATE TABLE FOREIGN_KEY_PARTITIONED_REFTABLE
(
	A INT,
	B INT
)
PARTITION BY RANGE(A, b)
(
	PARTITION FOREIGN_KEY_PARTITIONED_REFTABLE_P0 VALUES LESS THAN (50, 50)
);
ALTER TABLE FOREIGN_KEY_PARTITIONED_REFTABLE ADD UNIQUE(A, b); 
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "foreign_key_partitioned_reftable_a_b_key" for table "foreign_key_partitioned_reftable"
ALTER TABLE FOREIGN_KEY_PARTITIONED_REFTABLE ADD PRIMARY KEY (A, b); 
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "foreign_key_partitioned_reftable_pkey" for table "foreign_key_partitioned_reftable"
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED, CON.CONFUPDTYPE, CON.CONFDELTYPE, CON.CONFMATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1 WHERE CON.CONRELID = C1.OID AND C1.RELNAME IN ('foreign_key_partitioned_reftable', 'foreign_key_ordinary_reftable')
ORDER BY C1.RELNAME, CON.CONTYPE, CON.CONNAME;
                 conname                  | contype |             relname              | convalidated | confupdtype | confdeltype | confmatchtype 
------------------------------------------+---------+----------------------------------+--------------+-------------+-------------+---------------
 foreign_key_ordinary_reftable_a_b_key    | u       | foreign_key_ordinary_reftable    | t            |             |             |  
 foreign_key_partitioned_reftable_pkey    | p       | foreign_key_partitioned_reftable | t            |             |             |  
 foreign_key_partitioned_reftable_a_b_key | u       | foreign_key_partitioned_reftable | t            |             |             |  
(3 rows)

SELECT C1.RELNAME AS INDEXNAME, C2.RELNAME AS TABLENAME, IND.INDISUNIQUE, IND.INDISPRIMARY, IND.INDISEXCLUSION
FROM PG_CLASS C1, PG_CLASS C2, PG_INDEX IND
WHERE IND.INDEXRELID = C1.OID AND IND.INDRELID = C2.OID AND C2.RELNAME IN('foreign_key_partitioned_reftable', 'foreign_key_ordinary_reftable')
ORDER BY TABLENAME, INDEXNAME;
                indexname                 |            tablename             | indisunique | indisprimary | indisexclusion 
------------------------------------------+----------------------------------+-------------+--------------+----------------
 foreign_key_ordinary_reftable_a_b_key    | foreign_key_ordinary_reftable    | t           | f            | f
 foreign_key_partitioned_reftable_a_b_key | foreign_key_partitioned_reftable | t           | f            | f
 foreign_key_partitioned_reftable_pkey    | foreign_key_partitioned_reftable | t           | t            | f
(3 rows)

-- TEST FOR FOREIGN KEY CONSTRAINT
-- FAIL:  Partitioned table cannot be reftable
CREATE TABLE TEST_FK_1 
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_PARTITIONED_REFTABLE(A, B)
);
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
-- FAIL:  Partitioned table cannot be reftable
CREATE TABLE TEST_FK_2 
(
	A INT,
	B INT
);
ALTER TABLE TEST_FK_2 ADD CONSTRAINT CON_TEST_PK_2 FOREIGN KEY(A, B) REFERENCES FOREIGN_KEY_PARTITIONED_REFTABLE(A, B);
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
DROP TABLE TEST_FK_2;
-- FAIL:  Partitioned table cannot be reftable
CREATE TABLE TEST_FK_3
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_PARTITIONED_REFTABLE(A, B)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_3_P0 VALUES LESS THAN (50, 50)
);
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
-- FAIL:  Partitioned table cannot be reftable
CREATE TABLE TEST_FK_4
(
	A INT,
	B INT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_4_P0 VALUES LESS THAN (50, 50)
);
ALTER TABLE TEST_FK_4 ADD CONSTRAINT CON_TEST_FK_4 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_PARTITIONED_REFTABLE(A, B);
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
DROP TABLE TEST_FK_4;
-- TEST FOR MATCH SIMPLE AND NO ACTION
CREATE TABLE TEST_FK_5
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B)
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_5_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_5_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_5_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_5_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_5';
     conname      | contype |  relname  | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
------------------+---------+-----------+--------------+-------------------------------+-----------+-----------+-----------
 test_fk_5_a_fkey | f       | test_fk_5 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_5 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_5" violates foreign key constraint "test_fk_5_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
INSERT INTO TEST_FK_5 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_5 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;--ERROR
--SELECT * FROM TEST_FK_5 order by A;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;--ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "test_fk_5_a_fkey" on table "test_fk_5"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_5".
SELECT * FROM TEST_FK_5 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_5 VALUES (NULL, NULL);
DROP TABLE TEST_FK_5;
-- TEST FOR MATCH SIMPLE AND ON UPDATE CASCADE
CREATE TABLE TEST_FK_7
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE CASCADE
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_7_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_7_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_7_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_7_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_7';
     conname      | contype |  relname  | convalidated |         confreftable          | updtype | deltype | matchtype 
------------------+---------+-----------+--------------+-------------------------------+---------+---------+-----------
 test_fk_7_a_fkey | f       | test_fk_7 | t            | foreign_key_ordinary_reftable | cascade | cascade | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_7 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_7 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_7 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_7" violates foreign key constraint "test_fk_7_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_7 order by 1, 2;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;--ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "test_fk_7_a_fkey" on table "test_fk_7"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_7".
SELECT * FROM TEST_FK_7 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_7 VALUES (NULL, NULL);
DROP TABLE TEST_FK_7;
-- TEST FOR MATCH SIMPLE AND ON UPDATE SET NULL
CREATE TABLE TEST_FK_8
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE SET NULL
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_8_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_8_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_8_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_8_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_8';
     conname      | contype |  relname  | convalidated |         confreftable          | updtype  | deltype  | matchtype 
------------------+---------+-----------+--------------+-------------------------------+----------+----------+-----------
 test_fk_8_a_fkey | f       | test_fk_8 | t            | foreign_key_ordinary_reftable | set full | set full | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_8 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_8 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_8 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_8" violates foreign key constraint "test_fk_8_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_8;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;--ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "test_fk_8_a_fkey" on table "test_fk_8"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_8".
SELECT * FROM TEST_FK_8 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_8 VALUES (NULL, NULL);
DROP TABLE TEST_FK_8;
-- TEST FOR MATCH SIMPLE AND ON UPDATE SET DEFAULT
CREATE TABLE TEST_FK_9
(
	A INT DEFAULT 5,
	B INT DEFAULT 5,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE SET DEFAULT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_9_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_9_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_9_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_9_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_9';
     conname      | contype |  relname  | convalidated |         confreftable          |   updtype   |   deltype   | matchtype 
------------------+---------+-----------+--------------+-------------------------------+-------------+-------------+-----------
 test_fk_9_a_fkey | f       | test_fk_9 | t            | foreign_key_ordinary_reftable | set default | set default | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_9 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_9 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_9 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_9" violates foreign key constraint "test_fk_9_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_9;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;--ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "test_fk_9_a_fkey" on table "test_fk_9"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_9".
SELECT * FROM TEST_FK_9 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_9 VALUES (NULL, NULL);
DROP TABLE TEST_FK_9;
-- TEST FOR MATCH SIMPLE AND ON DELETE CASCADE
CREATE TABLE TEST_FK_6
(
	A INT,
	B INT,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE CASCADE
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_6_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_6_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_6_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_6_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_6';
     conname      | contype |  relname  | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
------------------+---------+-----------+--------------+-------------------------------+-----------+-----------+-----------
 test_fk_6_a_fkey | f       | test_fk_6 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_6 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_6 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_6 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_6" violates foreign key constraint "test_fk_6_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;--ERROR
--SELECT * FROM TEST_FK_6;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
SELECT * FROM TEST_FK_6 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 4 | 4
(3 rows)

INSERT INTO TEST_FK_6 VALUES (NULL, NULL);
DROP TABLE TEST_FK_6;
-- TEST FOR MATCH FULL AND ON DELETE SET NULL
CREATE TABLE TEST_FK_10
(
	A INT DEFAULT 5,
	B INT DEFAULT 5,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE SET NULL
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_10_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_10_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_10_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_10_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_10';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 test_fk_10_a_fkey | f       | test_fk_10 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_10 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_10 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_10 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_10" violates foreign key constraint "test_fk_10_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;--ERROR
--SELECT * FROM TEST_FK_10;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
SELECT * FROM TEST_FK_10 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 4 | 4
   |  
(4 rows)

INSERT INTO TEST_FK_10 VALUES (NULL, NULL);
DROP TABLE TEST_FK_10;
-- TEST FOR MATCH FULL AND ON DELETE SET DEFAULT
CREATE TABLE TEST_FK_11
(
	A INT DEFAULT 5,
	B INT DEFAULT 5,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE SET DEFAULT
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_11_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_11_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_11_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_11_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_11';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 test_fk_11_a_fkey | f       | test_fk_11 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_11 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_11 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_11 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_11" violates foreign key constraint "test_fk_11_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;--ERROR
--SELECT * FROM TEST_FK_11;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
ERROR:  insert or update on table "test_fk_11" violates foreign key constraint "test_fk_11_a_fkey"
DETAIL:  Key (a, b)=(5, 5) is not present in table "foreign_key_ordinary_reftable".
SELECT * FROM TEST_FK_11 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_11 VALUES (NULL, NULL);
DROP TABLE TEST_FK_11;
-- TEST FOR MATCH FULL AND ON DELETE CASCADE ON UPDATE CASCADE
CREATE TABLE TEST_FK_11
(
	A INT DEFAULT 5,
	B INT DEFAULT 5,
	FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE CASCADE ON UPDATE CASCADE
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_11_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_11_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_11_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_11_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_11';
      conname      | contype |  relname   | convalidated |         confreftable          | updtype | deltype | matchtype 
-------------------+---------+------------+--------------+-------------------------------+---------+---------+-----------
 test_fk_11_a_fkey | f       | test_fk_11 | t            | foreign_key_ordinary_reftable | cascade | cascade | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_11 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_11 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_11 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_11" violates foreign key constraint "test_fk_11_a_fkey"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_11;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
SELECT * FROM TEST_FK_11 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 4 | 4
(3 rows)

INSERT INTO TEST_FK_11 VALUES (NULL, NULL);
DROP TABLE TEST_FK_11;
-- TEST FOR MATCH FULL AND ON DELETE/ON UPDATE
CREATE TABLE TEST_FK_12
(
	A INT DEFAULT 5,
	B INT DEFAULT 5
)
PARTITION BY RANGE(A, B)
(
	PARTITION TEST_FK_12_P0 VALUES LESS THAN (1, 1),
	PARTITION TEST_FK_12_P1 VALUES LESS THAN (3, 3),
	PARTITION TEST_FK_12_P2 VALUES LESS THAN (5, 5),
	PARTITION TEST_FK_12_P3 VALUES LESS THAN (MAXVALUE, MAXVALUE)
) ENABLE ROW MOVEMENT;
-- ON NO ACTION
ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B);
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON UPDATE CASCADE
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE CASCADE;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          | updtype | deltype | matchtype 
-------------------+---------+------------+--------------+-------------------------------+---------+---------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | cascade | cascade | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON UPDATE SET NULL
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE SET NULL;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          | updtype  | deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+----------+----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | set full | set full | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_12 order by 1, 2;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON UPDATE SET DEFAULT
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON UPDATE SET DEFAULT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |   updtype   |   deltype   | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-------------+-------------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | set default | set default | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1;
--SELECT * FROM TEST_FK_12 order by 1, 2;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON DELETE NO ACTION
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE NO ACTION;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON DELETE RESTRICT
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE RESTRICT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3; --ERROR
ERROR:  update or delete on table "foreign_key_ordinary_reftable" violates foreign key constraint "con_on_test_fk_12" on table "test_fk_12"
DETAIL:  Key (a, b)=(3, 3) is still referenced from table "test_fk_12".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON DELETE CASCADE
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE CASCADE;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 4 | 4
(3 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON DELETE SET NULL
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE SET NULL;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 4 | 4
   |  
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
-- ON DELETE SET DEFAULT
DELETE FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE;
INSERT INTO FOREIGN_KEY_ORDINARY_REFTABLE VALUES (1,1), (2,2),(3,3),(4, 4),(5,5),(5, NULL), (NULL, NULL);
INSERT INTO TEST_FK_12 VALUES (1,1), (2,2),(3,3),(4, 4);
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

ALTER TABLE TEST_FK_12 ADD CONSTRAINT CON_ON_TEST_FK_12 FOREIGN KEY (A, B) REFERENCES FOREIGN_KEY_ORDINARY_REFTABLE(A, B) ON DELETE SET DEFAULT;
SELECT CON.CONNAME, CON.CONTYPE, C1.RELNAME, CON.CONVALIDATED,
	CASE
		WHEN CON.CONFRELID = 0 THEN NULL
		WHEN CON.CONFRELID <> 0 THEN C2.RELNAME
	END AS CONFREFTABLE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS UPDTYPE,
	CASE
		WHEN CON.CONFUPDTYPE='a' THEN 'no action'::TEXT
		WHEN CON.CONFUPDTYPE='r' THEN 'restrict'::TEXT
		WHEN CON.CONFUPDTYPE='c' THEN 'cascade'::TEXT
		WHEN CON.CONFUPDTYPE='n' THEN 'set full'::TEXT
		WHEN CON.CONFUPDTYPE='d' THEN 'set default'::TEXT
	END AS DELTYPE,
	CASE
		WHEN CON.CONFMATCHTYPE='f' THEN 'full'::TEXT
		WHEN CON.CONFMATCHTYPE='p' THEN 'partial'::TEXT
		WHEN CON.CONFMATCHTYPE='u' THEN 'simple'::TEXT
	END AS MATCHTYPE
FROM PG_CONSTRAINT CON, PG_CLASS C1, PG_CLASS C2
WHERE CON.CONRELID = C1.OID AND CON.CONFRELID = C2.OID AND C1.RELNAME = 'test_fk_12';
      conname      | contype |  relname   | convalidated |         confreftable          |  updtype  |  deltype  | matchtype 
-------------------+---------+------------+--------------+-------------------------------+-----------+-----------+-----------
 con_on_test_fk_12 | f       | test_fk_12 | t            | foreign_key_ordinary_reftable | no action | no action | simple
(1 row)

INSERT INTO TEST_FK_12 VALUES (1,2); --ERROR
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(1, 2) is not present in table "foreign_key_ordinary_reftable".
--UPDATE FOREIGN_KEY_ORDINARY_REFTABLE SET A = 6,B = 6 WHERE A = 1; --ERROR
--SELECT * FROM TEST_FK_12;
DELETE FROM FOREIGN_KEY_ORDINARY_REFTABLE WHERE A = 3;
ERROR:  insert or update on table "test_fk_12" violates foreign key constraint "con_on_test_fk_12"
DETAIL:  Key (a, b)=(5, 5) is not present in table "foreign_key_ordinary_reftable".
SELECT * FROM TEST_FK_12 order by 1, 2;
 a | b 
---+---
 1 | 1
 2 | 2
 3 | 3
 4 | 4
(4 rows)

INSERT INTO TEST_FK_12 VALUES (NULL, NULL);
ALTER TABLE TEST_FK_12 DROP CONSTRAINT CON_ON_TEST_FK_12;
DROP TABLE TEST_FK_12;
DROP TABLE FOREIGN_KEY_ORDINARY_REFTABLE;
DROP TABLE FOREIGN_KEY_PARTITIONED_REFTABLE;
--
---- --  ALTER TABLE VALIDATE CONSTRAINT constraint_name
--
-- 1. test validate check constraint
-- 2. test validate unique constraint
-- 3. test validate primary key constraint
-- 4. test validate exclude constraint(not support exclude index on partitioned table)
-- 5. test validate foreign key constraint
-- 1. test validate check constraint
create table test_validate_table_constraint_check (a int, b text, c int, d text)
partition by range (a, b)
(
	partition test_validate_table_constraint_check_p1 values less than (1, 'b'),
	partition test_validate_table_constraint_check_p2 values less than (4, 'e'),
	partition test_validate_table_constraint_check_p3 values less than (7, 'h')
);
insert into test_validate_table_constraint_check values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_check values (1, 'b', 1, 'b');
insert into test_validate_table_constraint_check values (2, 'c', 2, 'c');
-- sueccess: add check constraint
alter table test_validate_table_constraint_check add constraint test_check check (a>0) not valid;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_check';
  conname   | contype | convalidated |              conrelname              
------------+---------+--------------+--------------------------------------
 test_check | c       | f            | test_validate_table_constraint_check
(1 row)

-- failed: validate the check constraint
alter table test_validate_table_constraint_check validate constraint test_check;
ERROR:  check constraint "test_check" is violated by some row
delete from test_validate_table_constraint_check where a=0;
-- success: validate the check constraint
alter table test_validate_table_constraint_check validate constraint test_check;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_check' order by 1, 2, 3, 4;
  conname   | contype | convalidated |              conrelname              
------------+---------+--------------+--------------------------------------
 test_check | c       | t            | test_validate_table_constraint_check
(1 row)

-- failed: insert
insert into test_validate_table_constraint_check values (0, 'a', 0, 'a');
ERROR:  new row for relation "test_validate_table_constraint_check" violates check constraint "test_check"
DETAIL:  Failing row contains (0, a, 0, a).
-- clean
drop table test_validate_table_constraint_check;
-- 2. test validate unique constraint
create table test_validate_table_constraint_unique (a int, b text, c int, d text)
partition by range (a, b)
(
	partition test_validate_table_constraint_unique_p1 values less than (1, 'b'),
	partition test_validate_table_constraint_unique_p2 values less than (4, 'e'),
	partition test_validate_table_constraint_unique_p3 values less than (7, 'h')
);
insert into test_validate_table_constraint_unique values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_unique values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_unique values (1, 'b', 1, 'b');
insert into test_validate_table_constraint_unique values (2, 'c', 2, 'c');
-- failed: unique index columns must contain the partition key
alter table test_validate_table_constraint_unique add constraint test_unique unique (a);
ERROR:  unique index columns must contain the partition key
-- failed: UNIQUE constraints cannot be marked NOT VALID
alter table test_validate_table_constraint_unique add constraint test_unique unique (a, b) not valid;
ERROR:  UNIQUE constraints cannot be marked NOT VALID
LINE 1: ...int_unique add constraint test_unique unique (a, b) not vali...
                                                             ^
-- failed: duplicated row
alter table test_validate_table_constraint_unique add constraint test_unique unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique" for table "test_validate_table_constraint_unique"
ERROR:  could not create unique index "test_unique"
DETAIL:  Key (a, b)=(0, a) is duplicated.
delete from test_validate_table_constraint_unique where a=0;
-- success
alter table test_validate_table_constraint_unique add constraint test_unique unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique" for table "test_validate_table_constraint_unique"
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_unique' order by 1, 2, 3, 4;
   conname   | contype | convalidated |              conrelname               
-------------+---------+--------------+---------------------------------------
 test_unique | u       | t            | test_validate_table_constraint_unique
(1 row)

-- failed: duplicated row
insert into test_validate_table_constraint_unique values (1, 'b', 1, 'b');
ERROR:  duplicate key value violates unique constraint "test_unique"
DETAIL:  Key (a, b)=(1, b) already exists.
-- failed: validate the unique constraint
alter table test_validate_table_constraint_unique validate constraint test_unique;
ERROR:  constraint "test_unique" of relation "test_validate_table_constraint_unique" is not a foreign key or check constraint
-- clean
drop table test_validate_table_constraint_unique;
-- 3. test validate primary key constraint
create table test_validate_table_constraint_primary_key (a int, b text, c int, d text)
partition by range (a, b)
(
	partition test_validate_table_constraint_primary_key_p1 values less than (1, 'b'),
	partition test_validate_table_constraint_primary_key_p2 values less than (4, 'e'),
	partition test_validate_table_constraint_primary_key_p3 values less than (7, 'h')
);
insert into test_validate_table_constraint_primary_key values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_primary_key values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_primary_key values (1, 'b', 1, 'b');
insert into test_validate_table_constraint_primary_key values (2, 'c', 2, 'c');
-- failed: unique index columns must contain the partition key
alter table test_validate_table_constraint_primary_key add constraint test_primary_key primary key (a);
ERROR:  unique index columns must contain the partition key
-- failed: UNIQUE constraints cannot be marked NOT VALID
alter table test_validate_table_constraint_primary_key add constraint test_primary_key primary key (a, b) not valid;
ERROR:  PRIMARY KEY constraints cannot be marked NOT VALID
LINE 1: ... add constraint test_primary_key primary key (a, b) not vali...
                                                             ^
-- failed: duplicated row
alter table test_validate_table_constraint_primary_key add constraint test_primary_key primary key (a, b);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_key" for table "test_validate_table_constraint_primary_key"
ERROR:  could not create unique index "test_primary_key"
DETAIL:  Key (a, b)=(0, a) is duplicated.
delete from test_validate_table_constraint_primary_key where a=0;
-- success
alter table test_validate_table_constraint_primary_key add constraint test_primary_key primary key (a, b);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "test_primary_key" for table "test_validate_table_constraint_primary_key"
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_primary_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |                 conrelname                 
------------------+---------+--------------+--------------------------------------------
 test_primary_key | p       | t            | test_validate_table_constraint_primary_key
(1 row)

-- failed: duplicated row
insert into test_validate_table_constraint_primary_key values (1, 'b', 1, 'b');
ERROR:  duplicate key value violates unique constraint "test_primary_key"
DETAIL:  Key (a, b)=(1, b) already exists.
-- failed: validate the unique constraint
alter table test_validate_table_constraint_primary_key validate constraint test_primary_key;
ERROR:  constraint "test_primary_key" of relation "test_validate_table_constraint_primary_key" is not a foreign key or check constraint
-- clean
drop table test_validate_table_constraint_primary_key;
-- 4. test validate exclude constraint
create table test_validate_table_constraint_exclude (a int, b text, c int, d text)
partition by range (a, b)
(
	partition test_validate_table_constraint_exclude_p1 values less than (1, 'b'),
	partition test_validate_table_constraint_exclude_p2 values less than (4, 'e'),
	partition test_validate_table_constraint_exclude_p3 values less than (7, 'h')
);
insert into test_validate_table_constraint_exclude values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_exclude values (0, 'a', 0, 'a');
insert into test_validate_table_constraint_exclude values (1, 'b', 1, 'b');
insert into test_validate_table_constraint_exclude values (2, 'c', 2, 'c');
-- failed: Partitioned table does not support EXCLUDE index
alter table test_validate_table_constraint_exclude add constraint test_exclude exclude using btree (a with =);
ERROR:  Partitioned table does not support EXCLUDE index
-- clean
drop table test_validate_table_constraint_exclude;
-- 5. test validate foreign key constraint
create table test_ordinary_reftable (a int, b text);
alter table test_ordinary_reftable add unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_ordinary_reftable_a_b_key" for table "test_ordinary_reftable"
create table test_validate_table_constraint_foreign_key (a int, b text, c int, d text)
partition by range (a, b)
(
	partition test_validate_table_constraint_foreign_key_p1 values less than (1, 'b'),
	partition test_validate_table_constraint_foreign_key_p2 values less than (4, 'e'),
	partition test_validate_table_constraint_foreign_key_p3 values less than (7, 'h')
);
insert into test_validate_table_constraint_foreign_key values (0, 'a', 0, 'a');
-- failed
alter table test_validate_table_constraint_foreign_key 
add constraint test_foreign_key foreign key (a, b) references test_ordinary_reftable (a) not valid;
ERROR:  there is no unique constraint matching given keys for referenced table "test_ordinary_reftable"
-- success
alter table test_validate_table_constraint_foreign_key 
add constraint test_foreign_key foreign key (a, b) references test_ordinary_reftable (a, b) not valid;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_foreign_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |                 conrelname                 
------------------+---------+--------------+--------------------------------------------
 test_foreign_key | f       | f            | test_validate_table_constraint_foreign_key
(1 row)

-- failed
alter table test_validate_table_constraint_foreign_key validate constraint test_foreign_key;
ERROR:  insert or update on table "test_validate_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(0, a) is not present in table "test_ordinary_reftable".
delete from test_validate_table_constraint_foreign_key;
-- success
alter table test_validate_table_constraint_foreign_key validate constraint test_foreign_key;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_validate_table_constraint_foreign_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |                 conrelname                 
------------------+---------+--------------+--------------------------------------------
 test_foreign_key | f       | t            | test_validate_table_constraint_foreign_key
(1 row)

-- failed
insert into test_validate_table_constraint_foreign_key values (0, 'a', 0, 'a');
ERROR:  insert or update on table "test_validate_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(0, a) is not present in table "test_ordinary_reftable".
insert into test_ordinary_reftable values(0, 'a');
-- success
insert into test_validate_table_constraint_foreign_key values (0, 'a', 0, 'a');
delete from test_validate_table_constraint_foreign_key;
delete from test_ordinary_reftable;
alter table test_validate_table_constraint_foreign_key add unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_validate_table_constraint_foreign_key_a_b_key" for table "test_validate_table_constraint_foreign_key"
-- failed: Partitioned table cannot be reftable
alter table test_ordinary_reftable
add constraint test_foreign_key foreign key (a, b) references test_validate_table_constraint_foreign_key (a, b) not valid;
ERROR:  Invalid FOREIGN KEY constraints
DETAIL:  Partitioned table cannot be referenced table
-- clean
drop table test_validate_table_constraint_foreign_key;
drop table test_ordinary_reftable;
--
----  ALTER TABLE DROP CONSTRAINT [ IF EXISTS ] constraint_name [ RESTRICT | CASCADE ]
--
-- 1. test drop check constraint
-- 2. test drop unique constraint
-- 3. test drop primary key constraint
-- 4. test drop exclude constraint (not support exclude index on partitioned table)
-- 5. test drop foreign key constraint
-- 1. test drop check constraint
create table test_drop_table_constraint_check
(a int, b text, c int, d text, constraint test_check check (a>-1))
partition by range (a, b)
(
	partition test_drop_table_constraint_check_p1 values less than (1, 'b'),
	partition test_drop_table_constraint_check_p2 values less than (4, 'e'),
	partition test_drop_table_constraint_check_p3 values less than (7, 'h')
);
insert into test_drop_table_constraint_check values (0, 'a', 0, 'a');
insert into test_drop_table_constraint_check values (1, 'b', 1, 'b');
insert into test_drop_table_constraint_check values (2, 'c', 2, 'c');
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_check' order by 1, 2, 3, 4;
  conname   | contype | convalidated |            conrelname            
------------+---------+--------------+----------------------------------
 test_check | c       | t            | test_drop_table_constraint_check
(1 row)

-- failed
insert into test_drop_table_constraint_check values (-1, 'a', 0, 'a');
ERROR:  new row for relation "test_drop_table_constraint_check" violates check constraint "test_check"
DETAIL:  Failing row contains (-1, a, 0, a).
alter table test_drop_table_constraint_check drop constraint test_check;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_check' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_check values (-1, 'a', 0, 'a');
alter table test_drop_table_constraint_check add constraint test_check check (a>-2);
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_check' order by 1, 2, 3, 4;
  conname   | contype | convalidated |            conrelname            
------------+---------+--------------+----------------------------------
 test_check | c       | t            | test_drop_table_constraint_check
(1 row)

-- failed
insert into test_drop_table_constraint_check values (-2, 'a', 0, 'a');
ERROR:  new row for relation "test_drop_table_constraint_check" violates check constraint "test_check"
DETAIL:  Failing row contains (-2, a, 0, a).
alter table test_drop_table_constraint_check drop constraint test_check;
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_check' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_check values (-2, 'a', 0, 'a');
-- clean
drop table test_drop_table_constraint_check;
-- 2. test drop unique constraint
create table test_drop_table_constraint_unique
(a int, b text, c int, d text, constraint test_unique unique (a, b))
partition by range (a, b)
(
	partition test_drop_table_constraint_unique_p1 values less than (1, 'b'),
	partition test_drop_table_constraint_unique_p2 values less than (4, 'e'),
	partition test_drop_table_constraint_unique_p3 values less than (7, 'h')
);
NOTICE:  CREATE TABLE / UNIQUE will create implicit index "test_unique" for table "test_drop_table_constraint_unique"
insert into test_drop_table_constraint_unique values (0, 'a', 0, 'a');
insert into test_drop_table_constraint_unique values (1, 'b', 1, 'b');
insert into test_drop_table_constraint_unique values (2, 'c', 2, 'c');
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_unique' order by 1, 2, 3, 4;
   conname   | contype | convalidated |            conrelname             
-------------+---------+--------------+-----------------------------------
 test_unique | u       | t            | test_drop_table_constraint_unique
(1 row)

-- failed: duplicated row
insert into test_drop_table_constraint_unique values (2, 'c', 2, 'c');
ERROR:  duplicate key value violates unique constraint "test_unique"
DETAIL:  Key (a, b)=(2, c) already exists.
alter table test_drop_table_constraint_unique drop constraint test_unique;
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_unique' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_unique values (2, 'c', 2, 'c');
-- failed
alter table test_drop_table_constraint_unique add constraint test_unique unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique" for table "test_drop_table_constraint_unique"
ERROR:  could not create unique index "test_unique"
DETAIL:  Key (a, b)=(2, c) is duplicated.
delete from test_drop_table_constraint_unique where a =2;
-- success
alter table test_drop_table_constraint_unique add constraint test_unique unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_unique" for table "test_drop_table_constraint_unique"
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_unique' order by 1, 2, 3, 4;
   conname   | contype | convalidated |            conrelname             
-------------+---------+--------------+-----------------------------------
 test_unique | u       | t            | test_drop_table_constraint_unique
(1 row)

-- falied
insert into test_drop_table_constraint_unique values (0, 'a', 0, 'a');
ERROR:  duplicate key value violates unique constraint "test_unique"
DETAIL:  Key (a, b)=(0, a) already exists.
-- success
insert into test_drop_table_constraint_unique values (2, 'c', 2, 'c');
alter table test_drop_table_constraint_unique drop constraint test_unique;
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_unique' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_unique values (0, 'a', 0, 'a');
-- clean
drop table test_drop_table_constraint_unique;
-- 3. test drop primary key constraint
create table test_drop_table_constraint_primary_key
(a int, b text, c int, d text, constraint test_primary_key primary key (a, b))
partition by range (a, b)
(
	partition test_drop_table_constraint_primary_key_p1 values less than (1, 'b'),
	partition test_drop_table_constraint_primary_key_p2 values less than (4, 'e'),
	partition test_drop_table_constraint_primary_key_p3 values less than (7, 'h')
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_primary_key" for table "test_drop_table_constraint_primary_key"
insert into test_drop_table_constraint_primary_key values (0, 'a', 0, 'a');
insert into test_drop_table_constraint_primary_key values (1, 'b', 1, 'b');
insert into test_drop_table_constraint_primary_key values (2, 'c', 2, 'c');
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_primary_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |               conrelname               
------------------+---------+--------------+----------------------------------------
 test_primary_key | p       | t            | test_drop_table_constraint_primary_key
(1 row)

-- failed: duplicated row
insert into test_drop_table_constraint_primary_key values (2, 'c', 2, 'c');
ERROR:  duplicate key value violates unique constraint "test_primary_key"
DETAIL:  Key (a, b)=(2, c) already exists.
alter table test_drop_table_constraint_primary_key drop constraint test_primary_key;
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_primary_key' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_primary_key values (2, 'c', 2, 'c');
-- failed
alter table test_drop_table_constraint_primary_key add constraint test_primary_key unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_primary_key" for table "test_drop_table_constraint_primary_key"
ERROR:  could not create unique index "test_primary_key"
DETAIL:  Key (a, b)=(2, c) is duplicated.
delete from test_drop_table_constraint_primary_key where a =2;
-- success
alter table test_drop_table_constraint_primary_key add constraint test_primary_key unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_primary_key" for table "test_drop_table_constraint_primary_key"
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_primary_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |               conrelname               
------------------+---------+--------------+----------------------------------------
 test_primary_key | u       | t            | test_drop_table_constraint_primary_key
(1 row)

-- falied
insert into test_drop_table_constraint_primary_key values (0, 'a', 0, 'a');
ERROR:  duplicate key value violates unique constraint "test_primary_key"
DETAIL:  Key (a, b)=(0, a) already exists.
-- success
insert into test_drop_table_constraint_primary_key values (2, 'c', 2, 'c');
alter table test_drop_table_constraint_primary_key drop constraint test_primary_key;
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_primary_key' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_primary_key values (0, 'a', 0, 'a');
-- clean
drop table test_drop_table_constraint_primary_key;
-- 5. test drop foreign key constraint
create table test_ordinary_reftable (a int, b text);
alter table test_ordinary_reftable add unique (a, b);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "test_ordinary_reftable_a_b_key" for table "test_ordinary_reftable"
create table test_drop_table_constraint_foreign_key
(a int, b text, c int, d text,  constraint test_foreign_key foreign key (a, b) references test_ordinary_reftable (a, b))
partition by range (a, b)
(
	partition test_ordinary_reftable_p1 values less than (1, 'b'),
	partition test_ordinary_reftable_p2 values less than (4, 'e'),
	partition test_ordinary_reftable_p3 values less than (7, 'h')
);
-- failed
insert into test_drop_table_constraint_foreign_key values (0, 'a', 0, 'a');
ERROR:  insert or update on table "test_drop_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(0, a) is not present in table "test_ordinary_reftable".
insert into test_ordinary_reftable values(0, 'a');
-- success
insert into test_drop_table_constraint_foreign_key values (0, 'a', 0, 'a');
-- failed
insert into test_drop_table_constraint_foreign_key values (1, 'b', 1, 'b');
ERROR:  insert or update on table "test_drop_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(1, b) is not present in table "test_ordinary_reftable".
-- verify that constraint is correctly set 
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_foreign_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |               conrelname               
------------------+---------+--------------+----------------------------------------
 test_foreign_key | f       | t            | test_drop_table_constraint_foreign_key
(1 row)

alter table test_drop_table_constraint_foreign_key drop constraint test_foreign_key;
-- verify that constraint is correctly set
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_foreign_key' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_foreign_key values (1, 'b', 1, 'b');
-- failed
alter table test_drop_table_constraint_foreign_key 
add constraint test_foreign_key foreign key (a, b) references test_ordinary_reftable (a, b);
ERROR:  insert or update on table "test_drop_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(1, b) is not present in table "test_ordinary_reftable".
delete from test_drop_table_constraint_foreign_key where a=1;
-- success
alter table test_drop_table_constraint_foreign_key 
add constraint test_foreign_key foreign key (a, b) references test_ordinary_reftable (a, b);
-- verify that constraint is correctly set
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_foreign_key' order by 1, 2, 3, 4;
     conname      | contype | convalidated |               conrelname               
------------------+---------+--------------+----------------------------------------
 test_foreign_key | f       | t            | test_drop_table_constraint_foreign_key
(1 row)

-- failed
insert into test_drop_table_constraint_foreign_key values (1, 'b', 1, 'b');
ERROR:  insert or update on table "test_drop_table_constraint_foreign_key" violates foreign key constraint "test_foreign_key"
DETAIL:  Key (a, b)=(1, b) is not present in table "test_ordinary_reftable".
alter table test_drop_table_constraint_foreign_key drop constraint test_foreign_key;
-- verify that constraint is correctly set
select con.conname, con.contype, con.convalidated, cla.relname as conrelname from pg_constraint con left join pg_class cla on(con. conrelid = cla.oid) where cla.relname = 'test_drop_table_constraint_foreign_key' order by 1, 2, 3, 4;
 conname | contype | convalidated | conrelname 
---------+---------+--------------+------------
(0 rows)

-- success
insert into test_drop_table_constraint_foreign_key values (1, 'b', 1, 'b');
-- clean
drop table test_ordinary_reftable;
drop table test_drop_table_constraint_foreign_key;
