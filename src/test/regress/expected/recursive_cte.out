set current_schema=public;
/* 测试不下推场景下计划显示正确 */
explain (costs false) with recursive rq as
(
  select id, name from  chinamap where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Sort Key: rq.id
   CTE rq
     ->  Recursive Union
           ->  Seq Scan on chinamap
                 Filter: (id = 11)
           ->  Hash Join
                 Hash Cond: (origin.pid = rq.id)
                 ->  Seq Scan on chinamap origin
                 ->  Hash
                       ->  WorkTable Scan on rq
   ->  CTE Scan on rq
(12 rows)

with recursive rq as
(
  select id, name from  chinamap where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
 id  |           name           
-----+--------------------------
  11 | 湖北省
 110 | 湖北省 > 武汉市
 111 | 湖北省 > 武汉市 > 武昌区
 112 | 湖北省 > 武汉市 > 下城区
 113 | 湖北省 > 武汉市 > 江岸区
 114 | 湖北省 > 武汉市 > 江汉区
 115 | 湖北省 > 武汉市 > 汉阳区
 116 | 湖北省 > 武汉市 > 洪山区
 117 | 湖北省 > 武汉市 > 青山区
 120 | 湖北省 > 孝感市
 130 | 湖北省 > 宜昌市
 140 | 湖北省 > 随州市
 150 | 湖北省 > 仙桃市
 160 | 湖北省 > 荆门市
 170 | 湖北省 > 枝江市
 180 | 湖北省 > 神农架市
(16 rows)

set explain_perf_mode=pretty;
explain (costs false) with recursive rq as
(
  select id, name from  chinamap where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Sort Key: rq.id
   CTE rq
     ->  Recursive Union
           ->  Seq Scan on chinamap
                 Filter: (id = 11)
           ->  Hash Join
                 Hash Cond: (origin.pid = rq.id)
                 ->  Seq Scan on chinamap origin
                 ->  Hash
                       ->  WorkTable Scan on rq
   ->  CTE Scan on rq
(12 rows)

with recursive rq as
(
  select id, name from  chinamap where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
 id  |           name           
-----+--------------------------
  11 | 湖北省
 110 | 湖北省 > 武汉市
 111 | 湖北省 > 武汉市 > 武昌区
 112 | 湖北省 > 武汉市 > 下城区
 113 | 湖北省 > 武汉市 > 江岸区
 114 | 湖北省 > 武汉市 > 江汉区
 115 | 湖北省 > 武汉市 > 汉阳区
 116 | 湖北省 > 武汉市 > 洪山区
 117 | 湖北省 > 武汉市 > 青山区
 120 | 湖北省 > 孝感市
 130 | 湖北省 > 宜昌市
 140 | 湖北省 > 随州市
 150 | 湖北省 > 仙桃市
 160 | 湖北省 > 荆门市
 170 | 湖北省 > 枝江市
 180 | 湖北省 > 神农架市
(16 rows)

explain (costs false) 
with recursive rq as
(
  select id, name from  chinamap2 where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap2 origin on origin.pid = rq.id
)
select id, name from rq order by 1;
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: rq.id
   CTE rq
     ->  Recursive Union
           ->  Seq Scan on chinamap2
                 Filter: (id = 11)
           ->  Hash Join
                 Hash Cond: (origin.pid = rq.id)
                 ->  Seq Scan on chinamap2 origin
                 ->  Hash
                       ->  WorkTable Scan on rq
   ->  CTE Scan on rq
(12 rows)

with recursive rq as
(
  select id, name from  chinamap2 where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap2 origin on origin.pid = rq.id
)
select id, name from rq order by 1;
 id  |           name           
-----+--------------------------
  11 | 湖北省
 110 | 湖北省 > 武汉市
 111 | 湖北省 > 武汉市 > 武昌区
 112 | 湖北省 > 武汉市 > 下城区
 113 | 湖北省 > 武汉市 > 江岸区
 114 | 湖北省 > 武汉市 > 江汉区
 115 | 湖北省 > 武汉市 > 汉阳区
 116 | 湖北省 > 武汉市 > 洪山区
 117 | 湖北省 > 武汉市 > 青山区
 120 | 湖北省 > 孝感市
 130 | 湖北省 > 宜昌市
 140 | 湖北省 > 随州市
 150 | 湖北省 > 仙桃市
 160 | 湖北省 > 荆门市
 170 | 湖北省 > 枝江市
 180 | 湖北省 > 神农架市
(16 rows)

explain (costs false) 
with recursive rq as
(
  select id, name from  chinamap join t1 on id = t1.c2 where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Sort Key: rq.id
   CTE rq
     ->  Recursive Union
           ->  Nested Loop
                 ->  Seq Scan on t1
                       Filter: (c2 = 11)
                 ->  Materialize
                       ->  Seq Scan on chinamap
                             Filter: (id = 11)
           ->  Hash Join
                 Hash Cond: (origin.pid = rq.id)
                 ->  Seq Scan on chinamap origin
                 ->  Hash
                       ->  WorkTable Scan on rq
   ->  CTE Scan on rq
(16 rows)

with recursive rq as
(
  select id, name from  chinamap join t1 on id = t1.c2 where id = 11
  union all
  select origin.id, rq.name || ' > ' || origin.name
  from rq join chinamap origin on origin.pid = rq.id
)
select id, name from rq order by 1;
 id  |           name           
-----+--------------------------
  11 | 湖北省
 110 | 湖北省 > 武汉市
 111 | 湖北省 > 武汉市 > 武昌区
 112 | 湖北省 > 武汉市 > 下城区
 113 | 湖北省 > 武汉市 > 江岸区
 114 | 湖北省 > 武汉市 > 江汉区
 115 | 湖北省 > 武汉市 > 汉阳区
 116 | 湖北省 > 武汉市 > 洪山区
 117 | 湖北省 > 武汉市 > 青山区
 120 | 湖北省 > 孝感市
 130 | 湖北省 > 宜昌市
 140 | 湖北省 > 随州市
 150 | 湖北省 > 仙桃市
 160 | 湖北省 > 荆门市
 170 | 湖北省 > 枝江市
 180 | 湖北省 > 神农架市
(16 rows)

explain (costs false) 
with recursive cte as (  
	select  ID,  PID,  NAME 
	from a
	where a.NAME = 'm'
	union all  
	select parent.ID, parent.PID, parent.NAME 
	from cte as child join  a as parent 
	on child.pid=parent.id
)
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on a parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
    select  ID,  PID,  NAME
    from a
    where a.NAME = 'm'
    union all
    select parent.ID, parent.PID, parent.NAME
    from cte as child join  a as parent
    on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  1 |   0 | a
  3 |   1 | c
  7 |   3 | g
  9 |   7 | i
 11 |   9 | k
 12 |  11 | l
 13 |  12 | m
(7 rows)

explain (costs false) 
with recursive cte as (  
	select ID,PID,NAME
	from a
	where a.NAME = 'b'
	union all  
	select child.ID, child.PID, child.NAME
	from cte as parent join a as child 
	on child.pid=parent.id  
)  
select * from cte order by ID;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'b'::text)
           ->  Hash Join
                 Hash Cond: (child.pid = parent.id)
                 ->  Seq Scan on a child
                 ->  Hash
                       ->  WorkTable Scan on cte parent
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
    select ID,PID,NAME
    from a
    where a.NAME = 'b'
    union all
    select child.ID, child.PID, child.NAME
    from cte as parent join a as child
    on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  2 |   1 | b
  4 |   2 | d
  5 |   2 | e
  8 |   4 | h
 10 |   8 | j
(5 rows)

explain (costs false) 
with recursive cte as (  
	select 
		ID,
		PID,
		NAME,
		1 as level 
	from
		a
	where
		a.NAME = 'm'
	union all  
	select
		parent.ID,
		parent.PID,
		parent.NAME,
		child.level+1
	from 
		cte as child 
	join
		a as parent
	on
		child.pid=parent.id and child.level < 3 
)  
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on a parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
                             Filter: (level < 3)
   ->  CTE Scan on cte
(13 rows)

with recursive cte as (
    select
        ID,
        PID,
        NAME,
        1 as level
    from
        a
    where
        a.NAME = 'm'
    union all
    select
        parent.ID,
        parent.PID,
        parent.NAME,
        child.level+1
    from
        cte as child
    join
        a as parent
    on
        child.pid=parent.id and child.level < 3
)
select * from cte order by ID;
 id | pid | name | level 
----+-----+------+-------
 11 |   9 | k    |     3
 12 |  11 | l    |     2
 13 |  12 | m    |     1
(3 rows)

-----------
explain (costs false) 
with recursive cte as (  
select
	ID,
	PID,
	NAME,
	1 as level
from
	a
where
	a.NAME = 'b'
union all  
select
	child.ID,
	child.PID,
	child.NAME,
	parent.level+1
from
	cte as parent 
join
	a as child
on 
	child.pid=parent.id and parent.level < 3 
)  
select * from cte order by ID;
                       QUERY PLAN                       
--------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'b'::text)
           ->  Hash Join
                 Hash Cond: (child.pid = parent.id)
                 ->  Seq Scan on a child
                 ->  Hash
                       ->  WorkTable Scan on cte parent
                             Filter: (level < 3)
   ->  CTE Scan on cte
(13 rows)

with recursive cte as (
select
    ID,
    PID,
    NAME,
    1 as level
from
    a
where
    a.NAME = 'b'
union all
select
    child.ID,
    child.PID,
    child.NAME,
    parent.level+1
from
    cte as parent
join
    a as child
on
    child.pid=parent.id and parent.level < 3
)
select * from cte order by ID;
 id | pid | name | level 
----+-----+------+-------
  2 |   1 | b    |     1
  4 |   2 | d    |     2
  5 |   2 | e    |     2
  8 |   4 | h    |     3
(4 rows)

--------------
explain (costs false) 
select
	b.NAME
from 
	b
where 
	b.ID in
	(
		with recursive cte as 
		(
			select 
							ID,
							PID,
							NAME
			from 
							a
			where 
							a.NAME = 'g'
			union all
			select 
							child.ID, 
							child.PID, 
							child.NAME 
			from 
							cte as parent 
			join 
							a as child
			on child.pid=parent.id 
		)
		select ID from cte
	) order by 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Sort Key: b.name
   ->  Hash Right Semi Join
         Hash Cond: (cte.id = b.id)
         ->  CTE Scan on cte
               CTE cte
                 ->  Recursive Union
                       ->  Seq Scan on a
                             Filter: (name = 'g'::text)
                       ->  Hash Join
                             Hash Cond: (child.pid = parent.id)
                             ->  Seq Scan on a child
                             ->  Hash
                                   ->  WorkTable Scan on cte parent
         ->  Hash
               ->  Seq Scan on b
(16 rows)

select
    b.NAME
from
    b
where
    b.ID in
    (
        with recursive cte as
        (
            select
                            ID,
                            PID,
                            NAME
            from
                            a
            where
                            a.NAME = 'g'
            union all
            select
                            child.ID,
                            child.PID,
                            child.NAME
            from
                            cte as parent
            join
                            a as child
            on child.pid=parent.id
        )
        select ID from cte
    ) order by 1;
 name 
------
 G
 I
 K
 L
 M
(5 rows)

------------
explain (costs false) 
WITH RECURSIVE  TABLE_COLUMN(T,B,C,D)
AS
(
	SELECT   area_code,belong_area_code,name,rnk
    FROM   area
    UNION ALL
    SELECT   area_code,b.T||'|'||a.area_code,b.C||a.name,rnk
    FROM   area a JOIN   TABLE_COLUMN b ON   a.belong_area_code=b.T
)
SELECT  T,B,C FROM  Table_Column
ORDER BY 1,2,3;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: table_column.t, table_column.b, table_column.c
   CTE table_column
     ->  Recursive Union
           ->  Seq Scan on area
           ->  Hash Join
                 Hash Cond: (b.t = a.belong_area_code)
                 ->  WorkTable Scan on table_column b
                 ->  Hash
                       ->  Seq Scan on area a
   ->  CTE Scan on table_column
(11 rows)

WITH RECURSIVE  TABLE_COLUMN(T,B,C,D)
AS
(
    SELECT   area_code,belong_area_code,name,rnk
    FROM   area
    UNION ALL
    SELECT   area_code,b.T||'|'||a.area_code,b.C||a.name,rnk
    FROM   area a JOIN   TABLE_COLUMN b ON   a.belong_area_code=b.T
)
SELECT  T,B,C FROM  Table_Column
ORDER BY 1,2,3;
    t    |        b        |                c                 
---------+-----------------+----------------------------------
 1000000 | 0000000         | 总行
 1100000 | 1000000         | 北京分行
 1100000 | 1000000|1100000 | 总行北京分行
 1110000 | 1100000         | 朝阳区支行
 1110000 | 1100000|1110000 | 北京分行朝阳区支行
 1110000 | 1100000|1110000 | 总行北京分行朝阳区支行
 1111000 | 1110000         | 三里屯支行
 1111000 | 1110000|1111000 | 北京分行朝阳区支行三里屯支行
 1111000 | 1110000|1111000 | 总行北京分行朝阳区支行三里屯支行
 1111000 | 1110000|1111000 | 朝阳区支行三里屯支行
 1112000 | 1110000         | 酒仙桥支行
 1112000 | 1110000|1112000 | 北京分行朝阳区支行酒仙桥支行
 1112000 | 1110000|1112000 | 总行北京分行朝阳区支行酒仙桥支行
 1112000 | 1110000|1112000 | 朝阳区支行酒仙桥支行
 1120000 | 1100000         | 海淀区支行
 1120000 | 1100000|1120000 | 北京分行海淀区支行
 1120000 | 1100000|1120000 | 总行北京分行海淀区支行
 1121000 | 1120000         | 西三旗支行
 1121000 | 1120000|1121000 | 北京分行海淀区支行西三旗支行
 1121000 | 1120000|1121000 | 总行北京分行海淀区支行西三旗支行
 1121000 | 1120000|1121000 | 海淀区支行西三旗支行
 1200000 | 1000000         | 上海分行
 1200000 | 1000000|1200000 | 总行上海分行
 1210000 | 1200000         | 虹桥区支行
 1210000 | 1200000|1210000 | 上海分行虹桥区支行
 1210000 | 1200000|1210000 | 总行上海分行虹桥区支行
 1220000 | 1200000         | 浦东区支行
 1220000 | 1200000|1220000 | 上海分行浦东区支行
 1220000 | 1200000|1220000 | 总行上海分行浦东区支行
 1300000 | 1000000         | 深圳分行
 1300000 | 1000000|1300000 | 总行深圳分行
(31 rows)

/* recursive-cte关联外层 */
explain (costs false) select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME
        from b
        where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent
        on child.pid=parent.id
    )
    select NAME from cte
    where cte.ID % 2 = 0
    limit 1
) cName
from a
order by 1,2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Hash Join
                               Hash Cond: (parent.id = child.pid)
                               ->  Seq Scan on b parent
                               ->  Hash
                                     ->  WorkTable Scan on cte child
                 ->  CTE Scan on cte
                       Filter: ((id % 2::numeric) = 0::numeric)
(16 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME
        from b
        where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent
        on child.pid=parent.id
    )
    select NAME from cte
    where cte.ID % 2 = 0
    limit 1
) cName
from a
order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | 
  2 | b    | B
  3 | c    | 
  4 | d    | D
  5 | e    | B
  6 | f    | F
  7 | g    | F
  8 | h    | H
  9 | i    | H
 10 | j    | J
 11 | k    | J
 12 | l    | L
 13 | m    | L
(13 rows)

/*
 * 多层stream
 * --------------------------------------------------------
 *   ->RecursiveUnion
 *      ->Scan
 *      ->Join
 *          ->Scan
 *          ->Streaming <<<
 *              ->Join
 *                  ->Streaming
 *                      ->Scan
 *                  ->WorkTableScan
 * --------------------------------------------------------
 */
explain (costs false) with recursive rq as
(
    select id, name from  chinamap where id = 11
    union all
    select origin.id, rq.name || ' > ' || origin.name
    from rq join chinamap origin on origin.pid = rq.id, t2
	where t2.c2 = rq.id
)
select * from rq order by 1;
                         QUERY PLAN                          
-------------------------------------------------------------
 Sort
   Sort Key: rq.id
   CTE rq
     ->  Recursive Union
           ->  Seq Scan on chinamap
                 Filter: (id = 11)
           ->  Hash Join
                 Hash Cond: (t2.c2 = origin.pid)
                 ->  Seq Scan on t2
                 ->  Hash
                       ->  Hash Join
                             Hash Cond: (origin.pid = rq.id)
                             ->  Seq Scan on chinamap origin
                             ->  Hash
                                   ->  WorkTable Scan on rq
   ->  CTE Scan on rq
(16 rows)

with recursive rq as
(
    select id, name from  chinamap where id = 11
    union all
    select origin.id, rq.name || ' > ' || origin.name
    from rq join chinamap origin on origin.pid = rq.id, t2
	where t2.c2 = rq.id
)
select * from rq order by 1;
 id  |       name        
-----+-------------------
  11 | 湖北省
 110 | 湖北省 > 武汉市
 120 | 湖北省 > 孝感市
 130 | 湖北省 > 宜昌市
 140 | 湖北省 > 随州市
 150 | 湖北省 > 仙桃市
 160 | 湖北省 > 荆门市
 170 | 湖北省 > 枝江市
 180 | 湖北省 > 神农架市
(9 rows)

explain (costs false) select * from chinamap where pid = 11
union
select * from chinamap where id in
(
    with recursive rq as
    (   
        select * from chinamap where id = 110 
        union all 
        select origin.* from chinamap origin join rq on origin.pid = rq.id
    )   
     select id from rq
) order by id; 
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Sort
   Sort Key: public.chinamap.id
   ->  HashAggregate
         Group By Key: public.chinamap.id, public.chinamap.pid, public.chinamap.name
         ->  Append
               ->  Seq Scan on chinamap
                     Filter: (pid = 11)
               ->  Hash Join
                     Hash Cond: (public.chinamap.id = rq.id)
                     ->  Seq Scan on chinamap
                     ->  Hash
                           ->  HashAggregate
                                 Group By Key: rq.id
                                 ->  CTE Scan on rq
                                       CTE rq
                                         ->  Recursive Union
                                               ->  Seq Scan on chinamap
                                                     Filter: (id = 110)
                                               ->  Hash Join
                                                     Hash Cond: (origin.pid = rq.id)
                                                     ->  Seq Scan on chinamap origin
                                                     ->  Hash
                                                           ->  WorkTable Scan on rq
(23 rows)

select * from chinamap where pid = 11
union
select * from chinamap where id in
(
    with recursive rq as
    (   
        select * from chinamap where id = 110 
        union all 
        select origin.* from chinamap origin join rq on origin.pid = rq.id
    )   
     select id from rq
) order by id; 
 id  | pid |   name   
-----+-----+----------
 110 |  11 | 武汉市
 111 | 110 | 武昌区
 112 | 110 | 下城区
 113 | 110 | 江岸区
 114 | 110 | 江汉区
 115 | 110 | 汉阳区
 116 | 110 | 洪山区
 117 | 110 | 青山区
 120 |  11 | 孝感市
 130 |  11 | 宜昌市
 140 |  11 | 随州市
 150 |  11 | 仙桃市
 160 |  11 | 荆门市
 170 |  11 | 枝江市
 180 |  11 | 神农架市
(15 rows)

explain (costs false) select * from 
(
    with recursive cte1 as
    (
        select  ID,  PID,  NAME
        from a
        where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME
        from cte1 as child join  a as parent
        on child.pid=parent.id
    )select * from cte1
)
union all
(
    with recursive cte2 as
    (
        select  ID,  PID,  NAME
        from a
        where a.NAME = 'b'
        union all
        select parent.ID, parent.PID, parent.NAME
        from cte2 as child join  a as parent
        on child.pid=parent.id
    ) select * from cte2
) order by id;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort
   Sort Key: cte1.id
   ->  Result
         ->  Append
               ->  CTE Scan on cte1
                     CTE cte1
                       ->  Recursive Union
                             ->  Seq Scan on a
                                   Filter: (name = 'm'::text)
                             ->  Hash Join
                                   Hash Cond: (parent.id = child.pid)
                                   ->  Seq Scan on a parent
                                   ->  Hash
                                         ->  WorkTable Scan on cte1 child
               ->  CTE Scan on cte2
                     CTE cte2
                       ->  Recursive Union
                             ->  Seq Scan on a
                                   Filter: (name = 'b'::text)
                             ->  Hash Join
                                   Hash Cond: (parent.id = child.pid)
                                   ->  Seq Scan on a parent
                                   ->  Hash
                                         ->  WorkTable Scan on cte2 child
(24 rows)

select * from 
(
    with recursive cte1 as
    (
        select  ID,  PID,  NAME
        from a
        where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME
        from cte1 as child join  a as parent
        on child.pid=parent.id
    )select * from cte1
)
union all
(
    with recursive cte2 as
    (
        select  ID,  PID,  NAME
        from a
        where a.NAME = 'b'
        union all
        select parent.ID, parent.PID, parent.NAME
        from cte2 as child join  a as parent
        on child.pid=parent.id
    ) select * from cte2
) order by id;
 id | pid | name 
----+-----+------
  1 |   0 | a
  1 |   0 | a
  2 |   1 | b
  3 |   1 | c
  7 |   3 | g
  9 |   7 | i
 11 |   9 | k
 12 |  11 | l
 13 |  12 | m
(9 rows)

/*
 * 测试复制表replicate-plan场景
 */
/* a:b H:H */
explain (costs false)
with recursive cte as (
        select  ID,  PID,  NAME from a where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b as parent on child.pid=parent.id
)
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on b parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
        select  ID,  PID,  NAME from a where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b as parent on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  1 |   0 | A
  3 |   1 | C
  6 |   3 | F
  7 |   6 | G
  8 |   7 | H
  9 |   8 | I
 10 |   9 | J
 11 |  10 | K
 12 |  11 | L
 13 |  12 | m
(10 rows)

/* a:b R:H */
explain (costs false)
with recursive cte as (
        select  ID,  PID,  NAME from a_rep where a_rep.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b as parent on child.pid=parent.id
)
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a_rep
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on b parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
        select  ID,  PID,  NAME from a_rep where a_rep.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b as parent on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  1 |   0 | A
  3 |   1 | C
  6 |   3 | F
  7 |   6 | G
  8 |   7 | H
  9 |   8 | I
 10 |   9 | J
 11 |  10 | K
 12 |  11 | L
 13 |  12 | m
(10 rows)

/* a:b H:R */
explain (costs false)
with recursive cte as (
        select  ID,  PID,  NAME from a where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b_rep as parent on child.pid=parent.id
)
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on b_rep parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
        select  ID,  PID,  NAME from a where a.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b_rep as parent on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  1 |   0 | A
  3 |   1 | C
  6 |   3 | F
  7 |   6 | G
  8 |   7 | H
  9 |   8 | I
 10 |   9 | J
 11 |  10 | K
 12 |  11 | L
 13 |  12 | m
(10 rows)

/* a:b R:R */
explain (costs false)
with recursive cte as (
        select  ID,  PID,  NAME from a_rep where a_rep.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b_rep as parent on child.pid=parent.id
)
select * from cte order by ID;
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: cte.id
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on a_rep
                 Filter: (name = 'm'::text)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on b_rep parent
                 ->  Hash
                       ->  WorkTable Scan on cte child
   ->  CTE Scan on cte
(12 rows)

with recursive cte as (
        select  ID,  PID,  NAME from a_rep where a_rep.NAME = 'm'
        union all
        select parent.ID, parent.PID, parent.NAME from cte as child join  b_rep as parent on child.pid=parent.id
)
select * from cte order by ID;
 id | pid | name 
----+-----+------
  1 |   0 | A
  3 |   1 | C
  6 |   3 | F
  7 |   6 | G
  8 |   7 | H
  9 |   8 | I
 10 |   9 | J
 11 |  10 | K
 12 |  11 | L
 13 |  12 | m
(10 rows)

explain (costs false)
with recursive rq as
(
    select a.name address, b.name, a.id,a.pid
    from chinamap a,
    (
        with recursive rq as
        (
            select pid,id, name, mapid from  chinamap3
            union all
            select rq.pid,origin.id, rq.name || ' > ' || origin.name, origin.mapid
            from rq join chinamap3 origin on origin.pid = rq.id
        )select * from rq where pid is null
    ) b
    where a.id = b.mapid
    union all
    select chinamap.name, rq.name, rq.pid, chinamap.pid
    from rq ,chinamap
    where rq.pid=chinamap.id
)select address,name from rq order by address,name;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Sort Key: rq.address, rq.name
   CTE rq
     ->  Recursive Union
           ->  Hash Join
                 Hash Cond: (rq.mapid = a.id)
                 ->  CTE Scan on rq
                       Filter: (pid IS NULL)
                       CTE rq
                         ->  Recursive Union
                               ->  Seq Scan on chinamap3
                               ->  Hash Join
                                     Hash Cond: (rq.id = origin.pid)
                                     ->  WorkTable Scan on rq
                                     ->  Hash
                                           ->  Seq Scan on chinamap3 origin
                 ->  Hash
                       ->  Seq Scan on chinamap a
           ->  Hash Join
                 Hash Cond: (rq.pid = chinamap.id)
                 ->  WorkTable Scan on rq
                 ->  Hash
                       ->  Seq Scan on chinamap
   ->  CTE Scan on rq
(24 rows)

with recursive rq as
(
    select a.name address, b.name, a.id,a.pid
    from chinamap a,
    (
        with recursive rq as
        (
            select pid,id, name, mapid from  chinamap3
            union all
            select rq.pid,origin.id, rq.name || ' > ' || origin.name, origin.mapid
            from rq join chinamap3 origin on origin.pid = rq.id
        )select * from rq where pid is null
    ) b
    where a.id = b.mapid
    union all
    select chinamap.name, rq.name, rq.pid, chinamap.pid
    from rq ,chinamap
    where rq.pid=chinamap.id
)select address,name from rq order by address,name;
 address |                    name                    
---------+--------------------------------------------
 武昌区  | 教育 > 武汉大学
 武昌区  | 景点 > 黄鹤楼
 武汉市  | 教育 > 武汉大学
 武汉市  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 武汉市  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
 武汉市  | 景点 > 黄鹤楼
 洪山区  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 湖北省  | 教育 > 武汉大学
 湖北省  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 湖北省  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
 湖北省  | 景点 > 黄鹤楼
 湖北省  | 美食 > 热干面
 青山区  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
(13 rows)

explain (costs false)
with recursive rq as
(
    select a.name address, b.name, a.id,a.pid
    from chinamap a,
    (
        with recursive rq as
        (
            select pid,id, name, mapid from  chinamap4
            union all
            select rq.pid,origin.id, rq.name || ' > ' || origin.name, origin.mapid
            from rq join chinamap4 origin on origin.pid = rq.id
        )select * from rq where pid is null
    ) b
    where a.id = b.mapid
    union all
    select chinamap.name, rq.name, rq.pid, chinamap.pid
    from rq ,chinamap
    where rq.pid=chinamap.id
)select address,name from rq order by address,name;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Sort Key: rq.address, rq.name
   CTE rq
     ->  Recursive Union
           ->  Hash Join
                 Hash Cond: (rq.mapid = a.id)
                 ->  CTE Scan on rq
                       Filter: (pid IS NULL)
                       CTE rq
                         ->  Recursive Union
                               ->  Seq Scan on chinamap4
                               ->  Hash Join
                                     Hash Cond: (rq.id = origin.pid)
                                     ->  WorkTable Scan on rq
                                     ->  Hash
                                           ->  Seq Scan on chinamap4 origin
                 ->  Hash
                       ->  Seq Scan on chinamap a
           ->  Hash Join
                 Hash Cond: (rq.pid = chinamap.id)
                 ->  WorkTable Scan on rq
                 ->  Hash
                       ->  Seq Scan on chinamap
   ->  CTE Scan on rq
(24 rows)

with recursive rq as
(
    select a.name address, b.name, a.id,a.pid
    from chinamap a,
    (
        with recursive rq as
        (
            select pid,id, name, mapid from  chinamap4
            union all
            select rq.pid,origin.id, rq.name || ' > ' || origin.name, origin.mapid
            from rq join chinamap4 origin on origin.pid = rq.id
        )select * from rq where pid is null
    ) b
    where a.id = b.mapid
    union all
    select chinamap.name, rq.name, rq.pid, chinamap.pid
    from rq ,chinamap
    where rq.pid=chinamap.id
)select address,name from rq order by address,name;
 address |                    name                    
---------+--------------------------------------------
 武昌区  | 教育 > 武汉大学
 武昌区  | 景点 > 黄鹤楼
 武汉市  | 教育 > 武汉大学
 武汉市  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 武汉市  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
 武汉市  | 景点 > 黄鹤楼
 洪山区  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 湖北省  | 教育 > 武汉大学
 湖北省  | 教育 > 武汉科技大学 > 武汉科技大学洪山校区
 湖北省  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
 湖北省  | 景点 > 黄鹤楼
 湖北省  | 美食 > 热干面
 青山区  | 教育 > 武汉科技大学 > 武汉科技大学青山校区
(13 rows)

/* correlated subquery */
explain (costs false)
select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Subquery Scan on a
         ->  HashAggregate
               Group By Key: public.a.id, public.a.name
               ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Hash Join
                               Hash Cond: (parent.id = child.pid)
                               ->  Seq Scan on b parent
                               ->  Hash
                                     ->  WorkTable Scan on cte child
                 ->  CTE Scan on cte
(18 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | A
  2 | b    | B
  3 | c    | C
  4 | d    | D
  5 | e    | E
  6 | f    | F
  7 | g    | G
  8 | h    | H
  9 | i    | I
 10 | j    | J
 11 | k    | K
 12 | l    | L
 13 | m    | M
(13 rows)

explain (costs false)
select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Subquery Scan on a
         ->  HashAggregate
               Group By Key: public.a.id, public.a.name
               ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Nested Loop
                               ->  WorkTable Scan on cte child
                                     Filter: (pid = a.id)
                               ->  Seq Scan on b parent
                                     Filter: (id = a.id)
                 ->  CTE Scan on cte
(18 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | A
  2 | b    | B
  3 | c    | C
  4 | d    | D
  5 | e    | E
  6 | f    | F
  7 | g    | G
  8 | h    | H
  9 | i    | I
 10 | j    | J
 11 | k    | K
 12 | l    | L
 13 | m    | M
(13 rows)

/* verify conflict dop lead to unshippable recursive plan */
/* correlated subquery */
explain (costs false)
select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Subquery Scan on a
         ->  HashAggregate
               Group By Key: public.a.id, public.a.name
               ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Hash Join
                               Hash Cond: (parent.id = child.pid)
                               ->  Seq Scan on b parent
                               ->  Hash
                                     ->  WorkTable Scan on cte child
                 ->  CTE Scan on cte
(18 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | A
  2 | b    | B
  3 | c    | C
  4 | d    | D
  5 | e    | E
  6 | f    | F
  7 | g    | G
  8 | h    | H
  9 | i    | I
 10 | j    | J
 11 | k    | K
 12 | l    | L
 13 | m    | M
(13 rows)

explain (costs false)
select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Subquery Scan on a
         ->  HashAggregate
               Group By Key: public.a.id, public.a.name
               ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Nested Loop
                               ->  WorkTable Scan on cte child
                                     Filter: (pid = a.id)
                               ->  Seq Scan on b parent
                                     Filter: (id = a.id)
                 ->  CTE Scan on cte
(18 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | A
  2 | b    | B
  3 | c    | C
  4 | d    | D
  5 | e    | E
  6 | f    | F
  7 | g    | G
  8 | h    | H
  9 | i    | I
 10 | j    | J
 11 | k    | K
 12 | l    | L
 13 | m    | M
(13 rows)

explain (costs false)
select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
                          QUERY PLAN                           
---------------------------------------------------------------
 Sort
   Sort Key: a.id, a.name
   ->  Subquery Scan on a
         ->  HashAggregate
               Group By Key: public.a.id, public.a.name
               ->  Seq Scan on a
         SubPlan 2
           ->  Limit
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on b
                               Filter: (id = a.id)
                         ->  Nested Loop
                               ->  WorkTable Scan on cte child
                                     Filter: (pid = a.id)
                               ->  Seq Scan on b parent
                                     Filter: (id = a.id)
                 ->  CTE Scan on cte
(18 rows)

select  a.ID,a.Name,
(
    with recursive cte as (
        select ID, PID, NAME from b where b.ID = a.ID
        union all
        select parent.ID,parent.PID,parent.NAME
        from cte as child join b as parent on child.pid=parent.id
        where parent.id = a.id
    )
    select NAME from cte limit 1
) cName
from
(
    select id, name, count(*) as cnt
    from a group by id,name
) a order by 1,2;
 id | name | cname 
----+------+-------
  1 | a    | A
  2 | b    | B
  3 | c    | C
  4 | d    | D
  5 | e    | E
  6 | f    | F
  7 | g    | G
  8 | h    | H
  9 | i    | I
 10 | j    | J
 11 | k    | K
 12 | l    | L
 13 | m    | M
(13 rows)

explain (costs false)
with recursive cte as (
    select ID, PID, NAME from b where b.ID = 5 
    union all
    select parent.ID,parent.PID,parent.NAME
    from cte as child join b as parent on child.pid=parent.id
    where parent.id <= 5 
),
tmp as (select * from cte)
select cte.NAME from cte join tmp on cte.id = tmp.id
where tmp.id in (select id from tmp) order by 1;
                       QUERY PLAN                        
---------------------------------------------------------
 Sort
   Sort Key: cte.name
   CTE cte
     ->  Recursive Union
           ->  Seq Scan on b
                 Filter: (id = 5::numeric)
           ->  Hash Join
                 Hash Cond: (parent.id = child.pid)
                 ->  Seq Scan on b parent
                       Filter: (id <= 5::numeric)
                 ->  Hash
                       ->  WorkTable Scan on cte child
                             Filter: (pid <= 5::numeric)
   CTE tmp
     ->  CTE Scan on cte
   ->  Hash Semi Join
         Hash Cond: (cte.id = tmp.id)
         ->  Hash Join
               Hash Cond: (cte.id = tmp.id)
               ->  CTE Scan on cte
               ->  Hash
                     ->  CTE Scan on tmp
         ->  Hash
               ->  CTE Scan on tmp
(24 rows)

with recursive cte as (
    select ID, PID, NAME from b where b.ID = 5 
    union all
    select parent.ID,parent.PID,parent.NAME
    from cte as child join b as parent on child.pid=parent.id
    where parent.id <= 5 
),
tmp as (select * from cte)
select cte.NAME from cte join tmp on cte.id = tmp.id
where tmp.id in (select id from tmp) order by 1;
 name 
------
 A
 B
 E
(3 rows)

drop table if exists rec_tb4;
NOTICE:  table "rec_tb4" does not exist, skipping
create table rec_tb4 (id int ,parentID int ,name varchar(100))  partition by range(parentID)
(
PARTITION P1 VALUES LESS THAN(2),
PARTITION P2 VALUES LESS THAN(8),
PARTITION P3 VALUES LESS THAN(16),
PARTITION P4 VALUES LESS THAN(MAXVALUE)
);
insert into rec_tb4 values(1,0,'河南省');
insert into rec_tb4 values(2,1,'信阳市');
insert into rec_tb4 values(3,2,'淮滨县');
insert into rec_tb4 values(4,3,'芦集乡');
insert into rec_tb4 values(12,3,'邓湾乡');
insert into rec_tb4 values(13,3,'台头乡');
insert into rec_tb4 values(14,3,'谷堆乡');
insert into rec_tb4 values(8,2,'固始县');
insert into rec_tb4 values(9,8,'李店乡');
insert into rec_tb4 values(10,2,'息县');
insert into rec_tb4 values(11,10,'关店乡');
insert into rec_tb4 values(5,1,'安阳市');
insert into rec_tb4 values(6,5,'滑县');
insert into rec_tb4 values(7,6,'老庙乡');
insert into rec_tb4 values(15,1,'南阳市');
insert into rec_tb4 values(16,15,'方城县');
insert into rec_tb4 values(17,1,'驻马店市');
insert into rec_tb4 values(18,17,'正阳县');
with recursive cte as (select * from rec_tb4 where id<4 union all  select h.id,h.parentID,h.name from (with recursive cte as (select * from rec_tb4 where id<4 union all  select h.id,h.parentID,h.name from rec_tb4 h inner join cte c on h.id=c.parentID) SELECT id ,parentID,name from cte order by parentID) h inner join cte c on h.id=c.parentID) SELECT id ,parentID,name from cte order by parentID,1,2,3;
 id | parentid |  name  
----+----------+--------
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  1 |        0 | 河南省
  2 |        1 | 信阳市
  2 |        1 | 信阳市
  2 |        1 | 信阳市
  3 |        2 | 淮滨县
(14 rows)

explain (costs false)
with recursive cte as (select * from rec_tb4 where id<4 union all  select h.id,h.parentID,h.name from (with recursive cte as (select * from rec_tb4 where id<4 union all  select h.id,h.parentID,h.name from rec_tb4 h inner join cte c on h.id=c.parentID) SELECT id ,parentID,name from cte order by parentID) h inner join cte  c on h.id=c.parentID) SELECT id ,parentID,name from cte order by parentID,1,2,3;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Sort
   Sort Key: cte.parentid, cte.id, cte.name
   CTE cte
     ->  Recursive Union
           ->  Partition Iterator
                 Iterations: 4
                 ->  Partitioned Seq Scan on rec_tb4
                       Filter: (id < 4)
                       Selected Partitions:  1..4
           ->  Hash Join
                 Hash Cond: (cte.id = c.parentid)
                 ->  CTE Scan on cte
                       CTE cte
                         ->  Recursive Union
                               ->  Partition Iterator
                                     Iterations: 4
                                     ->  Partitioned Seq Scan on rec_tb4
                                           Filter: (id < 4)
                                           Selected Partitions:  1..4
                               ->  Hash Join
                                     Hash Cond: (c.parentid = h.id)
                                     ->  WorkTable Scan on cte c
                                     ->  Hash
                                           ->  Partition Iterator
                                                 Iterations: 4
                                                 ->  Partitioned Seq Scan on rec_tb4 h
                                                       Selected Partitions:  1..4
                 ->  Hash
                       ->  WorkTable Scan on cte c
   ->  CTE Scan on cte
(30 rows)

drop table rec_tb4;
drop table if exists test_perf3;
NOTICE:  table "test_perf3" does not exist, skipping
create table test_perf3
(
etl_tx_dt varchar2(8),
area_code varchar2(30) primary key,
area_name varchar2(360),
area_short_name varchar2(360),
local_name varchar2(240),
belong_area_code varchar2(30),
bank_level varchar2(24),
country_code varchar2(15),
part_code varchar2(15),
time_zone varchar2(27),
bank_code varchar2(30),
group_code varchar2(15),
mag_area_status varchar2(3),
mag_area_broad varchar2(3),
mag_area_grade varchar2(9)
)
;
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "test_perf3_pkey" for table "test_perf3"
explain (costs false)
with recursive cte1 as
(select area_code, belong_area_code, area_code as chain, 1 as level
from test_perf3
where area_code='100000'
union all
select h.area_code, h.belong_area_code, cast(cte1.chain||'>'||h.area_code as varchar2(30)),cte1.level+1
from cte1
join test_perf3 h
on h.belong_area_code=cte1.area_code and cte1.level <3 and h.area_code not in (select regexp_split_to_table(cte1.chain,'>'))
),
cte2 as (
select area_code, belong_area_code, area_code as chain, 1 as level
from cte1
where area_code='100000'
union all
select h.area_code, h.belong_area_code, cast(cte2.chain||'>'||h.area_code as varchar2(30)),cte2.level+1
from cte2
join cte1 h
on h.belong_area_code=cte2.area_code and cte2.level <3 and h.area_code not in (select regexp_split_to_table(cte2.chain,'>'))
)
select * from cte2;
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 CTE Scan on cte2
   CTE cte1
     ->  Recursive Union
           ->  Index Scan using test_perf3_pkey on test_perf3
                 Index Cond: ((area_code)::text = '100000'::text)
           ->  Hash Join
                 Hash Cond: ((h.belong_area_code)::text = (cte1.area_code)::text)
                 Join Filter: (NOT (SubPlan 1))
                 ->  Seq Scan on test_perf3 h
                 ->  Hash
                       ->  WorkTable Scan on cte1
                             Filter: (level < 3)
                 SubPlan 1
                   ->  Result
   CTE cte2
     ->  Recursive Union
           ->  CTE Scan on cte1
                 Filter: ((area_code)::text = '100000'::text)
           ->  Hash Join
                 Hash Cond: ((h.belong_area_code)::text = (cte2.area_code)::text)
                 Join Filter: (NOT (SubPlan 3))
                 ->  CTE Scan on cte1 h
                 ->  Hash
                       ->  WorkTable Scan on cte2
                             Filter: (level < 3)
                 SubPlan 3
                   ->  Result
(27 rows)

with recursive cte1 as
(select area_code, belong_area_code, area_code as chain, 1 as level
from test_perf3
where area_code='100000'
union all
select h.area_code, h.belong_area_code, cast(cte1.chain||'>'||h.area_code as varchar2(30)),cte1.level+1
from cte1
join test_perf3 h
on h.belong_area_code=cte1.area_code and cte1.level <3 and h.area_code not in (select regexp_split_to_table(cte1.chain,'>'))
),
cte2 as (
select area_code, belong_area_code, area_code as chain, 1 as level
from cte1
where area_code='100000'
union all
select h.area_code, h.belong_area_code, cast(cte2.chain||'>'||h.area_code as varchar2(30)),cte2.level+1
from cte2
join cte1 h
on h.belong_area_code=cte2.area_code and cte2.level <3 and h.area_code not in (select regexp_split_to_table(cte2.chain,'>'))
)
select * from cte2;
 area_code | belong_area_code | chain | level 
-----------+------------------+-------+-------
(0 rows)

drop table test_perf3;
reset explain_perf_mode;
/*update-delte语句中含有with recursive,且with recursive引用目标表*/
drop table if exists bom_ptbl;
NOTICE:  table "bom_ptbl" does not exist, skipping
drop table if exists bom_locator;
NOTICE:  table "bom_locator" does not exist, skipping
create table bom_ptbl(
		id varchar(3) , 
		pid varchar(3) , 
		name varchar(10)
) with (orientation=row, compression=no) ;
create table bom_locator(
		zone varchar(3)
) with (orientation=row, compression=no) ;
insert into bom_ptbl values('002' , 0 , '浙江省'); 
insert into bom_ptbl values('001' , 0 , '广东省'); 
insert into bom_ptbl values('003' , '002' , '衢州市');  
insert into bom_ptbl values('004' , '002' , '杭州市') ; 
insert into bom_ptbl values('005' , '002' , '湖州市');  
insert into bom_ptbl values('006' , '002' , '嘉兴市') ; 
insert into bom_ptbl values('007' , '002' , '宁波市');  
insert into bom_ptbl values('008' , '002' , '绍兴市') ; 
insert into bom_ptbl values('009' , '002' , '台州市');  
insert into bom_ptbl values('010' , '002' , '温州市') ; 
insert into bom_ptbl values('011' , '002' , '丽水市');  
insert into bom_ptbl values('012' , '002' , '金华市') ; 
insert into bom_ptbl values('013' , '002' , '舟山市');  
insert into bom_ptbl values('014' , '004' , '上城区') ; 
insert into bom_ptbl values('015' , '004' , '下城区');  
insert into bom_ptbl values('016' , '004' , '拱墅区') ; 
insert into bom_ptbl values('017' , '004' , '余杭区') ; 
insert into bom_ptbl values('018' , '011' , '金东区') ; 
insert into bom_ptbl values('019' , '001' , '广州市') ; 
insert into bom_ptbl values('020' , '001' , '深圳市') ;
insert into bom_locator values('002');
insert into bom_locator values('007');
explain (costs off, verbose on) update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Update on public.bom_ptbl
   ->  Seq Scan on public.bom_ptbl
         Output: bom_ptbl.id, bom_ptbl.pid, (SubPlan 2), bom_ptbl.ctid
         Filter: (bom_ptbl.name IS NOT NULL)
         SubPlan 2
           ->  Limit
                 Output: cte.name, cte.id
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on public.bom_ptbl a
                               Output: a.id, a.name, a.pid
                               Filter: ((a.id)::text = (bom_ptbl.id)::text)
                         ->  Hash Join
                               Output: b.id, b.name, b.pid
                               Hash Cond: ((b.pid)::text = (cte.id)::text)
                               ->  Seq Scan on public.bom_ptbl b
                                     Output: b.id, b.pid, b.name
                               ->  Hash
                                     Output: cte.id
                                     ->  WorkTable Scan on cte
                                           Output: cte.id
                 ->  Sort
                       Output: cte.name, cte.id
                       Sort Key: cte.id
                       ->  Hash Left Join
                             Output: cte.name, cte.id
                             Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                             ->  CTE Scan on cte
                                   Output: cte.id, cte.name, cte.pid
                             ->  Hash
                                   Output: bom_locator.zone
                                   ->  Seq Scan on public.bom_locator
                                         Output: bom_locator.zone
(33 rows)

update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
explain (costs off, verbose on) delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Delete on public.bom_ptbl
   ->  Seq Scan on public.bom_ptbl
         Output: bom_ptbl.ctid
         Filter: ((bom_ptbl.name IS NOT NULL) AND ((bom_ptbl.name)::text = ((SubPlan 2))::text))
         SubPlan 2
           ->  Limit
                 Output: cte.name, cte.id
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on public.bom_ptbl a
                               Output: a.id, a.name, a.pid
                               Filter: ((a.id)::text = (bom_ptbl.id)::text)
                         ->  Hash Join
                               Output: b.id, b.name, b.pid
                               Hash Cond: ((b.pid)::text = (cte.id)::text)
                               ->  Seq Scan on public.bom_ptbl b
                                     Output: b.id, b.pid, b.name
                               ->  Hash
                                     Output: cte.id
                                     ->  WorkTable Scan on cte
                                           Output: cte.id
                 ->  Sort
                       Output: cte.name, cte.id
                       Sort Key: cte.id
                       ->  Hash Left Join
                             Output: cte.name, cte.id
                             Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                             ->  CTE Scan on cte
                                   Output: cte.id, cte.name, cte.pid
                             ->  Hash
                                   Output: bom_locator.zone
                                   ->  Seq Scan on public.bom_locator
                                         Output: bom_locator.zone
(33 rows)

delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
insert into bom_ptbl values('002' , 0 , '浙江省'); 
insert into bom_ptbl values('001' , 0 , '广东省'); 
insert into bom_ptbl values('003' , '002' , '衢州市');  
insert into bom_ptbl values('004' , '002' , '杭州市') ; 
insert into bom_ptbl values('005' , '002' , '湖州市');  
insert into bom_ptbl values('006' , '002' , '嘉兴市') ; 
insert into bom_ptbl values('007' , '002' , '宁波市');  
insert into bom_ptbl values('008' , '002' , '绍兴市') ; 
insert into bom_ptbl values('009' , '002' , '台州市');  
insert into bom_ptbl values('010' , '002' , '温州市') ; 
insert into bom_ptbl values('011' , '002' , '丽水市');  
insert into bom_ptbl values('012' , '002' , '金华市') ; 
insert into bom_ptbl values('013' , '002' , '舟山市');  
insert into bom_ptbl values('014' , '004' , '上城区') ; 
insert into bom_ptbl values('015' , '004' , '下城区');  
insert into bom_ptbl values('016' , '004' , '拱墅区') ; 
insert into bom_ptbl values('017' , '004' , '余杭区') ; 
insert into bom_ptbl values('018' , '011' , '金东区') ; 
insert into bom_ptbl values('019' , '001' , '广州市') ; 
insert into bom_ptbl values('020' , '001' , '深圳市') ;
explain (costs off, verbose on) update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Update on public.bom_ptbl
   ->  Seq Scan on public.bom_ptbl
         Output: bom_ptbl.id, bom_ptbl.pid, (SubPlan 2), bom_ptbl.ctid
         Filter: (bom_ptbl.name IS NOT NULL)
         SubPlan 2
           ->  Limit
                 Output: cte.name, cte.id
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on public.bom_ptbl a
                               Output: a.id, a.name, a.pid
                               Filter: ((a.id)::text = (bom_ptbl.id)::text)
                         ->  Hash Join
                               Output: b.id, b.name, b.pid
                               Hash Cond: ((b.pid)::text = (cte.id)::text)
                               ->  Seq Scan on public.bom_ptbl b
                                     Output: b.id, b.pid, b.name
                               ->  Hash
                                     Output: cte.id
                                     ->  WorkTable Scan on cte
                                           Output: cte.id
                 ->  Sort
                       Output: cte.name, cte.id
                       Sort Key: cte.id
                       ->  Hash Left Join
                             Output: cte.name, cte.id
                             Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                             ->  CTE Scan on cte
                                   Output: cte.id, cte.name, cte.pid
                             ->  Hash
                                   Output: bom_locator.zone
                                   ->  Seq Scan on public.bom_locator
                                         Output: bom_locator.zone
(33 rows)

update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
explain (costs off, verbose on) delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Delete on public.bom_ptbl
   ->  Seq Scan on public.bom_ptbl
         Output: bom_ptbl.ctid
         Filter: ((bom_ptbl.name IS NOT NULL) AND ((bom_ptbl.name)::text = ((SubPlan 2))::text))
         SubPlan 2
           ->  Limit
                 Output: cte.name, cte.id
                 CTE cte
                   ->  Recursive Union
                         ->  Seq Scan on public.bom_ptbl a
                               Output: a.id, a.name, a.pid
                               Filter: ((a.id)::text = (bom_ptbl.id)::text)
                         ->  Hash Join
                               Output: b.id, b.name, b.pid
                               Hash Cond: ((b.pid)::text = (cte.id)::text)
                               ->  Seq Scan on public.bom_ptbl b
                                     Output: b.id, b.pid, b.name
                               ->  Hash
                                     Output: cte.id
                                     ->  WorkTable Scan on cte
                                           Output: cte.id
                 ->  Sort
                       Output: cte.name, cte.id
                       Sort Key: cte.id
                       ->  Hash Left Join
                             Output: cte.name, cte.id
                             Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                             ->  CTE Scan on cte
                                   Output: cte.id, cte.name, cte.pid
                             ->  Hash
                                   Output: bom_locator.zone
                                   ->  Seq Scan on public.bom_locator
                                         Output: bom_locator.zone
(33 rows)

delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
drop table if exists bom_ptbl;
drop table if exists bom_locator;
create table bom_ptbl(
		id varchar(3) , 
		pid varchar(3) , 
		name varchar(10)
) with (orientation=column, compression=low) ;
create table bom_locator(
		zone varchar(3)
) with (orientation=column, compression=low) ;
insert into bom_ptbl values('002' , 0 , '浙江省'); 
insert into bom_ptbl values('001' , 0 , '广东省'); 
insert into bom_ptbl values('003' , '002' , '衢州市');  
insert into bom_ptbl values('004' , '002' , '杭州市') ; 
insert into bom_ptbl values('005' , '002' , '湖州市');  
insert into bom_ptbl values('006' , '002' , '嘉兴市') ; 
insert into bom_ptbl values('007' , '002' , '宁波市');  
insert into bom_ptbl values('008' , '002' , '绍兴市') ; 
insert into bom_ptbl values('009' , '002' , '台州市');  
insert into bom_ptbl values('010' , '002' , '温州市') ; 
insert into bom_ptbl values('011' , '002' , '丽水市');  
insert into bom_ptbl values('012' , '002' , '金华市') ; 
insert into bom_ptbl values('013' , '002' , '舟山市');  
insert into bom_ptbl values('014' , '004' , '上城区') ; 
insert into bom_ptbl values('015' , '004' , '下城区');  
insert into bom_ptbl values('016' , '004' , '拱墅区') ; 
insert into bom_ptbl values('017' , '004' , '余杭区') ; 
insert into bom_ptbl values('018' , '011' , '金东区') ; 
insert into bom_ptbl values('019' , '001' , '广州市') ; 
insert into bom_ptbl values('020' , '001' , '深圳市') ;
insert into bom_locator values('002');
insert into bom_locator values('007');
explain (costs off, verbose on) update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.bom_ptbl
         ->  CStore Scan on public.bom_ptbl
               Output: bom_ptbl.id, bom_ptbl.pid, (SubPlan 2), bom_ptbl.ctid, bom_ptbl.tableoid
               Filter: (bom_ptbl.name IS NOT NULL)
               SubPlan 2
                 ->  Limit
                       Output: cte.name, cte.id
                       CTE cte
                         ->  Recursive Union
                               ->  Row Adapter
                                     Output: a.id, a.name, a.pid
                                     ->  CStore Scan on public.bom_ptbl a
                                           Output: a.id, a.name, a.pid
                                           Filter: ((a.id)::text = (bom_ptbl.id)::text)
                               ->  Hash Join
                                     Output: b.id, b.name, b.pid
                                     Hash Cond: ((b.pid)::text = (cte.id)::text)
                                     ->  Row Adapter
                                           Output: b.id, b.name, b.pid
                                           ->  CStore Scan on public.bom_ptbl b
                                                 Output: b.id, b.name, b.pid
                                     ->  Hash
                                           Output: cte.id
                                           ->  WorkTable Scan on cte
                                                 Output: cte.id
                       ->  Sort
                             Output: cte.name, cte.id
                             Sort Key: cte.id
                             ->  Hash Left Join
                                   Output: cte.name, cte.id
                                   Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                                   ->  CTE Scan on cte
                                         Output: cte.id, cte.name, cte.pid
                                   ->  Hash
                                         Output: bom_locator.zone
                                         ->  Row Adapter
                                               Output: bom_locator.zone
                                               ->  CStore Scan on public.bom_locator
                                                     Output: bom_locator.zone
(40 rows)

update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
explain (costs off, verbose on) delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.bom_ptbl
         ->  CStore Scan on public.bom_ptbl
               Output: bom_ptbl.ctid, bom_ptbl.tableoid
               Filter: ((bom_ptbl.name IS NOT NULL) AND ((bom_ptbl.name)::text = ((SubPlan 2))::text))
               SubPlan 2
                 ->  Limit
                       Output: cte.name, cte.id
                       CTE cte
                         ->  Recursive Union
                               ->  Row Adapter
                                     Output: a.id, a.name, a.pid
                                     ->  CStore Scan on public.bom_ptbl a
                                           Output: a.id, a.name, a.pid
                                           Filter: ((a.id)::text = (bom_ptbl.id)::text)
                               ->  Hash Join
                                     Output: b.id, b.name, b.pid
                                     Hash Cond: ((b.pid)::text = (cte.id)::text)
                                     ->  Row Adapter
                                           Output: b.id, b.name, b.pid
                                           ->  CStore Scan on public.bom_ptbl b
                                                 Output: b.id, b.name, b.pid
                                     ->  Hash
                                           Output: cte.id
                                           ->  WorkTable Scan on cte
                                                 Output: cte.id
                       ->  Sort
                             Output: cte.name, cte.id
                             Sort Key: cte.id
                             ->  Hash Left Join
                                   Output: cte.name, cte.id
                                   Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                                   ->  CTE Scan on cte
                                         Output: cte.id, cte.name, cte.pid
                                   ->  Hash
                                         Output: bom_locator.zone
                                         ->  Row Adapter
                                               Output: bom_locator.zone
                                               ->  CStore Scan on public.bom_locator
                                                     Output: bom_locator.zone
(40 rows)

delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
insert into bom_ptbl values('002' , 0 , '浙江省'); 
insert into bom_ptbl values('001' , 0 , '广东省'); 
insert into bom_ptbl values('003' , '002' , '衢州市');  
insert into bom_ptbl values('004' , '002' , '杭州市') ; 
insert into bom_ptbl values('005' , '002' , '湖州市');  
insert into bom_ptbl values('006' , '002' , '嘉兴市') ; 
insert into bom_ptbl values('007' , '002' , '宁波市');  
insert into bom_ptbl values('008' , '002' , '绍兴市') ; 
insert into bom_ptbl values('009' , '002' , '台州市');  
insert into bom_ptbl values('010' , '002' , '温州市') ; 
insert into bom_ptbl values('011' , '002' , '丽水市');  
insert into bom_ptbl values('012' , '002' , '金华市') ; 
insert into bom_ptbl values('013' , '002' , '舟山市');  
insert into bom_ptbl values('014' , '004' , '上城区') ; 
insert into bom_ptbl values('015' , '004' , '下城区');  
insert into bom_ptbl values('016' , '004' , '拱墅区') ; 
insert into bom_ptbl values('017' , '004' , '余杭区') ; 
insert into bom_ptbl values('018' , '011' , '金东区') ; 
insert into bom_ptbl values('019' , '001' , '广州市') ; 
insert into bom_ptbl values('020' , '001' , '深圳市') ;
explain (costs off, verbose on) update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Update on public.bom_ptbl
         ->  CStore Scan on public.bom_ptbl
               Output: bom_ptbl.id, bom_ptbl.pid, (SubPlan 2), bom_ptbl.ctid, bom_ptbl.tableoid
               Filter: (bom_ptbl.name IS NOT NULL)
               SubPlan 2
                 ->  Limit
                       Output: cte.name, cte.id
                       CTE cte
                         ->  Recursive Union
                               ->  Row Adapter
                                     Output: a.id, a.name, a.pid
                                     ->  CStore Scan on public.bom_ptbl a
                                           Output: a.id, a.name, a.pid
                                           Filter: ((a.id)::text = (bom_ptbl.id)::text)
                               ->  Hash Join
                                     Output: b.id, b.name, b.pid
                                     Hash Cond: ((b.pid)::text = (cte.id)::text)
                                     ->  Row Adapter
                                           Output: b.id, b.name, b.pid
                                           ->  CStore Scan on public.bom_ptbl b
                                                 Output: b.id, b.name, b.pid
                                     ->  Hash
                                           Output: cte.id
                                           ->  WorkTable Scan on cte
                                                 Output: cte.id
                       ->  Sort
                             Output: cte.name, cte.id
                             Sort Key: cte.id
                             ->  Hash Left Join
                                   Output: cte.name, cte.id
                                   Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                                   ->  CTE Scan on cte
                                         Output: cte.id, cte.name, cte.pid
                                   ->  Hash
                                         Output: bom_locator.zone
                                         ->  Row Adapter
                                               Output: bom_locator.zone
                                               ->  CStore Scan on public.bom_locator
                                                     Output: bom_locator.zone
(40 rows)

update bom_ptbl set name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) where bom_ptbl.name is not null;
explain (costs off, verbose on) delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Delete on public.bom_ptbl
         ->  CStore Scan on public.bom_ptbl
               Output: bom_ptbl.ctid, bom_ptbl.tableoid
               Filter: ((bom_ptbl.name IS NOT NULL) AND ((bom_ptbl.name)::text = ((SubPlan 2))::text))
               SubPlan 2
                 ->  Limit
                       Output: cte.name, cte.id
                       CTE cte
                         ->  Recursive Union
                               ->  Row Adapter
                                     Output: a.id, a.name, a.pid
                                     ->  CStore Scan on public.bom_ptbl a
                                           Output: a.id, a.name, a.pid
                                           Filter: ((a.id)::text = (bom_ptbl.id)::text)
                               ->  Hash Join
                                     Output: b.id, b.name, b.pid
                                     Hash Cond: ((b.pid)::text = (cte.id)::text)
                                     ->  Row Adapter
                                           Output: b.id, b.name, b.pid
                                           ->  CStore Scan on public.bom_ptbl b
                                                 Output: b.id, b.name, b.pid
                                     ->  Hash
                                           Output: cte.id
                                           ->  WorkTable Scan on cte
                                                 Output: cte.id
                       ->  Sort
                             Output: cte.name, cte.id
                             Sort Key: cte.id
                             ->  Hash Left Join
                                   Output: cte.name, cte.id
                                   Hash Cond: ((cte.id)::text = (bom_locator.zone)::text)
                                   ->  CTE Scan on cte
                                         Output: cte.id, cte.name, cte.pid
                                   ->  Hash
                                         Output: bom_locator.zone
                                         ->  Row Adapter
                                               Output: bom_locator.zone
                                               ->  CStore Scan on public.bom_locator
                                                     Output: bom_locator.zone
(40 rows)

delete bom_ptbl where name =
(
	with recursive cte as
	(
	select a.id, a.name, a.pid from bom_ptbl a where a.id = bom_ptbl.id
	union all
	select b.id, b.name, b.pid from cte,bom_ptbl b where cte.id = b.pid
	) 
	select cte.name from cte left join bom_locator on cte.id = bom_locator.zone 
	order by cte.id limit 1
) and bom_ptbl.name is not null;
drop table if exists bom_ptbl;
drop table if exists bom_locator;
reset current_schema;
