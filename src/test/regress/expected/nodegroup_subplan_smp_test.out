/*
 * This file is used to test pull down of subplan expressions
 */
set query_dop = 1002;
create schema nodegroup_subplan_test;
set current_schema = nodegroup_subplan_test;
set enable_nodegroup_explain=true;
ERROR:  unrecognized configuration parameter "enable_nodegroup_explain"
set expected_computing_nodegroup='group1';
create node group ng0 with (datanode1, datanode2, datanode3);
create node group ng1 with (datanode4, datanode5, datanode6);
create node group ng2 with (datanode7, datanode8, datanode9);
create node group ng3 with (datanode10, datanode11, datanode12);
-- Create Table and Insert Data
create table temp(a int, b int, c int, d int)with(autovacuum_enabled = off);
create table t_subplan1(a1 int, b1 int, c1 int, d1 int) with (orientation = column,autovacuum_enabled = off) distribute by hash(a1, b1) to group ng0;
create table t_subplan2(a2 int, b2 int, c2 int, d2 int) with (orientation = column,autovacuum_enabled = off) distribute by hash(a2, b2) to group ng1;
insert into temp select generate_series(1, 100)%98, generate_series(1, 100)%20, generate_series(1, 100)%13, generate_series(1, 100)%6;
insert into t_subplan1 select * from temp;
delete from temp;
insert into temp select generate_series(1, 50)%48, generate_series(1, 50)%28, generate_series(1, 50)%12, generate_series(1, 50)%9;
insert into t_subplan2 select * from temp;
create table t_subplan5(a1 int, b1 int, c1 int, d1 int) with (orientation = column,autovacuum_enabled = off) distribute by hash(a1, b1) to group ng2;
create table t_subplan6(a2 int, b2 int, c2 int, d2 int) with (orientation = column,autovacuum_enabled = off) distribute by hash(a2, b2) to group ng3;
insert into t_subplan5 select * from t_subplan1;
insert into t_subplan6 select * from t_subplan2;
--create row table
create table t_subplan7(a1 int, b1 int, c1 int, d1 int) with (orientation = column,autovacuum_enabled = off) distribute by hash(a1, b1) to group ng1;
insert into t_subplan7 select * from t_subplan1;
-- 1. initplan
explain (costs off)
select case when (select count(*)
                  from t_subplan2
                  where a2 between 1 and 20) > 15
            then (select avg(b2)
                  from t_subplan2
                  where a2 between 1 and 20)
            else (select avg(c2)
                  from t_subplan2
                  where a2 between 1 and 20) end bucket1 ,
       case when (select count(*)
                  from t_subplan2
                  where a2 between 1 and 20) > 25
             then (select avg(b2)
                  from t_subplan2
                  where a2 between 1 and 20)
            else (select avg(c2)
                  from t_subplan2
                  where a2 between 1 and 20) end bucket2
from t_subplan1
where a1 = 5 or a1 = 6
;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         InitPlan 2 (returns $1)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         InitPlan 3 (returns $2)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         InitPlan 4 (returns $3)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         InitPlan 5 (returns $4)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         InitPlan 6 (returns $5)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2
                                         Filter: ((a2 >= 1) AND (a2 <= 20))
         ->  CStore Scan on t_subplan1
               Filter: ((a1 = 5) OR (a1 = 6))
(46 rows)

select case when (select count(*)
                  from t_subplan2
                  where a2 between 1 and 20) > 15
            then (select avg(b2)
                  from t_subplan2
                  where a2 between 1 and 20)
            else (select avg(c2)
                  from t_subplan2
                  where a2 between 1 and 20) end bucket1 ,
       case when (select count(*)
                  from t_subplan2
                  where a2 between 1 and 20) > 25
             then (select avg(b2)
                  from t_subplan2
                  where a2 between 1 and 20)
            else (select avg(c2)
                  from t_subplan2
                  where a2 between 1 and 20) end bucket2
from t_subplan1
where a1 = 5 or a1 = 6
;
       bucket1       |      bucket2       
---------------------+--------------------
 11.5000000000000000 | 4.7727272727272727
 11.5000000000000000 | 4.7727272727272727
(2 rows)

explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2))
 group by a1
 order by a1, cnt
 limit 10;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 2 (returns $1)
           ->  Row Adapter
                 ->  Vector Aggregate
                       InitPlan 1 (returns $0)
                         ->  Row Adapter
                               ->  Vector Aggregate
                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                           ->  Vector Aggregate
                                                 ->  CStore Scan on t_subplan2 t2
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan1 t1
                                         Filter: ((a1)::numeric > $0)
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                             ->  Vector Sonic Hash Join
                                                   Hash Cond: (t_subplan1.a1 = t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                         ->  CStore Scan on t_subplan1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->ng0)
                                                         ->  CStore Scan on t_subplan2
                                                               Filter: ((c2)::numeric > $1)
(31 rows)

select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2))
 group by a1
 order by a1, cnt
 limit 10;
 a1 | cnt 
----+-----
  3 |   1
  4 |   1
  5 |   1
  6 |   1
  7 |   1
  8 |   1
  9 |   1
 10 |   1
 11 |   1
 15 |   1
(10 rows)

explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2))
 group by a1
 order by a1, cnt
 offset (select avg(d2) from t_subplan2);
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 2 (returns $1)
           ->  Row Adapter
                 ->  Vector Aggregate
                       InitPlan 1 (returns $0)
                         ->  Row Adapter
                               ->  Vector Aggregate
                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                           ->  Vector Aggregate
                                                 ->  CStore Scan on t_subplan2 t2
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan1 t1
                                         Filter: ((a1)::numeric > $0)
         InitPlan 3 (returns $2)
           ->  Row Adapter
                 ->  Vector Streaming (type: GATHER)
                       ->  Vector Aggregate
                             ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                   ->  Vector Aggregate
                                         ->  CStore Scan on t_subplan2
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                             ->  Vector Sonic Hash Join
                                                   Hash Cond: (t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                         ->  CStore Scan on t_subplan1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->ng0)
                                                         ->  CStore Scan on t_subplan2
                                                               Filter: ((c2)::numeric > $1)
(38 rows)

select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2))
 group by a1
 order by a1, cnt
 offset (select avg(d2) from t_subplan2);
 a1 | cnt 
----+-----
  7 |   1
  8 |   1
  9 |   1
 10 |   1
 11 |   1
 15 |   1
 16 |   1
 17 |   1
 18 |   1
 19 |   1
 20 |   1
 21 |   1
 22 |   1
 23 |   1
 27 |   1
 28 |   1
 29 |   1
 30 |   1
 31 |   1
 32 |   1
 33 |   1
 34 |   1
 35 |   1
 39 |   1
 40 |   1
 41 |   1
 42 |   1
 43 |   1
 44 |   1
 45 |   1
 46 |   1
 47 |   1
(32 rows)

-- 2. subplan
explain (costs off)
with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2)
order by 1
limit 10;
                                                                                                               QUERY PLAN                                                                                                                
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: (sum((nodegroup_subplan_test.t_subplan1.c1 + nodegroup_subplan_test.t_subplan2.c2)))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: (sum((nodegroup_subplan_test.t_subplan1.c1 + nodegroup_subplan_test.t_subplan2.c2)))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Nest Loop
                                       Join Filter: ((nodegroup_subplan_test.t_subplan2.d2 = ctr2.d2) AND (((sum((nodegroup_subplan_test.t_subplan1.c1 + nodegroup_subplan_test.t_subplan2.c2))))::numeric > ((avg(ctr2.total) * 1.2))))
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                                   ->  Vector Sonic Hash Join
                                                         Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                               ->  CStore Scan on t_subplan1
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->ng0)
                                                               ->  CStore Scan on t_subplan2
                                       ->  Vector Materialize
                                             ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                                   ->  Vector Hash Aggregate
                                                         Group By Key: ctr2.d2
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                               ->  Vector Subquery Scan on ctr2
                                                                     ->  Vector Sonic Hash Aggregate
                                                                           Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                                                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                                                                 ->  Vector Sonic Hash Join
                                                                                       Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                                                             ->  CStore Scan on t_subplan1
                                                                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->ng0)
                                                                                             ->  CStore Scan on t_subplan2
(34 rows)

with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2)
order by 1
limit 10;
 total 
-------
    22
    26
    32
    32
    37
    38
    38
    43
    49
(9 rows)

explain (costs off)
with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2
and ctr1.d2+ctr2.d2 < (select avg(total)*3
from t ctr3
where ctr2.d2=ctr3.d2))
order by 1
limit 10;
                                                                                          QUERY PLAN                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: ctr1.total
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: ctr1.total
                           ->  Vector Subquery Scan on ctr1
                                 Filter: ((ctr1.total)::numeric > (SubPlan 1))
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                       ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                             ->  Vector Sonic Hash Join
                                                   Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                         ->  CStore Scan on t_subplan1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->ng0)
                                                         ->  CStore Scan on t_subplan2
                                 SubPlan 1
                                   ->  Row Adapter
                                         ->  Vector Aggregate
                                               ->  Vector Nest Loop
                                                     Join Filter: (((ctr1.d2 + ctr2.d2))::numeric < ((avg(ctr3.total) * 3::numeric)))
                                                     ->  Vector Result
                                                           Filter: (ctr2.d2 = ctr1.d2)
                                                           ->  Vector Materialize
                                                                 ->  Vector Streaming(type: BROADCAST ng: group1->GenGroup)
                                                                       ->  Vector Subquery Scan on ctr2
                                                                             ->  Vector Sonic Hash Aggregate
                                                                                   Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                                                                   ->  Vector Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                                                                         ->  Vector Sonic Hash Join
                                                                                               Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                                                               ->  Vector Streaming(type: REDISTRIBUTE)
                                                                                                     ->  CStore Scan on t_subplan1
                                                                                               ->  Vector Streaming(type: REDISTRIBUTE ng: ng1->ng0)
                                                                                                     ->  CStore Scan on t_subplan2
                                                     ->  Vector Result
                                                           Filter: (ctr3.d2 = ctr1.d2)
                                                           ->  Vector Materialize
                                                                 ->  Vector Streaming(type: BROADCAST ng: group1->GenGroup)
                                                                       ->  Vector Hash Aggregate
                                                                             Group By Key: ctr3.d2
                                                                             ->  Vector Subquery Scan on ctr3
                                                                                   ->  Vector Sonic Hash Aggregate
                                                                                         Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                                                                         ->  Vector Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                                                                               ->  Vector Sonic Hash Join
                                                                                                     Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                                                                     ->  Vector Streaming(type: REDISTRIBUTE)
                                                                                                           ->  CStore Scan on t_subplan1
                                                                                                     ->  Vector Streaming(type: REDISTRIBUTE ng: ng1->ng0)
                                                                                                           ->  CStore Scan on t_subplan2
(53 rows)

with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2
and ctr1.d2+ctr2.d2 < (select avg(total)*3
from t ctr3
where ctr2.d2=ctr3.d2))
order by 1
limit 10;
 total 
-------
    22
    26
    32
    32
    37
    38
    38
    43
    49
(9 rows)

explain (costs off)
with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2
and ctr1.d2+ctr2.d2 < (select avg(total)*3
from t ctr3
where ctr2.d2=ctr3.d2
and ctr1.d1 = ctr3.d1))
order by 1
limit 10;
                                                                                              QUERY PLAN                                                                                              
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: ctr1.total
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: ctr1.total
                           ->  Vector Subquery Scan on ctr1
                                 Filter: ((ctr1.total)::numeric > (SubPlan 2))
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                       ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                             ->  Vector Sonic Hash Join
                                                   Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                         ->  CStore Scan on t_subplan1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->ng0)
                                                         ->  CStore Scan on t_subplan2
                                 SubPlan 2
                                   ->  Row Adapter
                                         ->  Vector Aggregate
                                               ->  Vector Result
                                                     Filter: ((ctr1.d2 = ctr2.d2) AND (((ctr1.d2 + ctr2.d2))::numeric < (SubPlan 1)))
                                                     ->  Vector Materialize
                                                           ->  Vector Streaming(type: BROADCAST ng: group1->GenGroup)
                                                                 ->  Vector Subquery Scan on ctr2
                                                                       ->  Vector Sonic Hash Aggregate
                                                                             Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                                                             ->  Vector Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                                                                   ->  Vector Sonic Hash Join
                                                                                         Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                                                         ->  Vector Streaming(type: REDISTRIBUTE)
                                                                                               ->  CStore Scan on t_subplan1
                                                                                         ->  Vector Streaming(type: REDISTRIBUTE ng: ng1->ng0)
                                                                                               ->  CStore Scan on t_subplan2
                                                     SubPlan 1
                                                       ->  Row Adapter
                                                             ->  Vector Aggregate
                                                                   ->  Vector Result
                                                                         Filter: ((ctr2.d2 = ctr3.d2) AND (ctr1.d1 = ctr3.d1))
                                                                         ->  Vector Materialize
                                                                               ->  Vector Streaming(type: BROADCAST ng: group1->GenGroup)
                                                                                     ->  Vector Subquery Scan on ctr3
                                                                                           ->  Vector Sonic Hash Aggregate
                                                                                                 Group By Key: nodegroup_subplan_test.t_subplan1.d1, nodegroup_subplan_test.t_subplan2.d2
                                                                                                 ->  Vector Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                                                                                       ->  Vector Sonic Hash Join
                                                                                                             Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                                                                             ->  Vector Streaming(type: REDISTRIBUTE)
                                                                                                                   ->  CStore Scan on t_subplan1
                                                                                                             ->  Vector Streaming(type: REDISTRIBUTE ng: ng1->ng0)
                                                                                                                   ->  CStore Scan on t_subplan2
(52 rows)

with t as
(select d1
,d2
,sum(c1+c2) as total
from t_subplan1
,t_subplan2
where a1 = a2
group by d1
,d2)
 select  total
from t ctr1
where ctr1.total > (select avg(total)*1.2
from t ctr2
where ctr1.d2 = ctr2.d2
and ctr1.d2+ctr2.d2 < (select avg(total)*3
from t ctr3
where ctr2.d2=ctr3.d2
and ctr1.d1 = ctr3.d1))
order by 1
limit 10;
 total 
-------
    22
    26
    32
    32
    37
    38
    38
    43
    49
(9 rows)

explain (costs off)
select * from t_subplan1 t1
where
 exists (select * from t_subplan2 t2
	where t1.a1=t2.a2) and
 (exists (select * from t_subplan2 t2
	where t1.b1+20=t2.b2) or
  exists (select * from t_subplan2 t2
	where t1.c1 = t2.c2))
order by 1,2,3,4;
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: t1.a1, t1.b1, t1.c1, t1.d1
         ->  Vector Sort
               Sort Key: t1.a1, t1.b1, t1.c1, t1.d1
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Sonic Hash Join
                           Hash Cond: (t1.a1 = t2.a2)
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                                 ->  Vector Hash Left Join
                                       Hash Cond: (t1.c1 = t2.c2)
                                       Filter: ((t2.b2 IS NOT NULL) OR (t2.c2 IS NOT NULL))
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  Vector Hash Left Join
                                                   Hash Cond: (((t1.b1 + 20)) = t2.b2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                                         ->  CStore Scan on t_subplan1 t1
                                                   ->  Vector Sonic Hash Aggregate
                                                         Group By Key: t2.b2
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->group1)
                                                               ->  CStore Scan on t_subplan2 t2
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: t2.c2
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->group1)
                                                   ->  CStore Scan on t_subplan2 t2
                           ->  Vector Sonic Hash Aggregate
                                 Group By Key: t2.a2
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: t2.a2
                                             ->  CStore Scan on t_subplan2 t2
(31 rows)

;
select * from t_subplan1 t1
where
 exists (select * from t_subplan2 t2
	where t1.a1=t2.a2) and
 (exists (select * from t_subplan2 t2
	where t1.b1+20=t2.b2) or
  exists (select * from t_subplan2 t2
	where t1.c1 = t2.c2))
order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  0 | 18 |  7 |  2
  1 |  1 |  1 |  1
  1 | 19 |  8 |  3
  2 |  0 |  9 |  4
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
  6 |  6 |  6 |  0
  7 |  7 |  7 |  1
  8 |  8 |  8 |  2
  9 |  9 |  9 |  3
 10 | 10 | 10 |  4
 11 | 11 | 11 |  5
 13 | 13 |  0 |  1
 14 | 14 |  1 |  2
 15 | 15 |  2 |  3
 16 | 16 |  3 |  4
 17 | 17 |  4 |  5
 18 | 18 |  5 |  0
 19 | 19 |  6 |  1
 20 |  0 |  7 |  2
 21 |  1 |  8 |  3
 22 |  2 |  9 |  4
 23 |  3 | 10 |  5
 24 |  4 | 11 |  0
 25 |  5 | 12 |  1
 26 |  6 |  0 |  2
 27 |  7 |  1 |  3
 28 |  8 |  2 |  4
 29 |  9 |  3 |  5
 30 | 10 |  4 |  0
 31 | 11 |  5 |  1
 32 | 12 |  6 |  2
 33 | 13 |  7 |  3
 34 | 14 |  8 |  4
 35 | 15 |  9 |  5
 36 | 16 | 10 |  0
 37 | 17 | 11 |  1
 39 | 19 |  0 |  3
 40 |  0 |  1 |  4
 41 |  1 |  2 |  5
 42 |  2 |  3 |  0
 43 |  3 |  4 |  1
 44 |  4 |  5 |  2
 45 |  5 |  6 |  3
 46 |  6 |  7 |  4
 47 |  7 |  8 |  5
(48 rows)

;
-- 3. initplan & subplan
explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1)
 group by a1
 order by a1, cnt
 limit 10;
                                                                                          QUERY PLAN                                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan1
                                         Filter: ((a1 + b1) < 200)
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  Vector Nest Loop
                                                   Join Filter: ((nodegroup_subplan_test.t_subplan1.c1 = t2.c2) AND ((nodegroup_subplan_test.t_subplan1.b1)::numeric > (1.2 * (avg(t2.b2)))))
                                                   ->  Vector Sonic Hash Aggregate
                                                         Group By Key: t2.c2
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->group1)
                                                               ->  CStore Scan on t_subplan2 t2
                                                   ->  Vector Materialize
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                                               ->  Vector Sonic Hash Join
                                                                     Hash Cond: (nodegroup_subplan_test.t_subplan1.a1 = t_subplan2.a2)
                                                                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                                           ->  CStore Scan on t_subplan1
                                                                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->ng0)
                                                                           ->  CStore Scan on t_subplan2
                                                                                 Filter: ((c2)::numeric > $0)
(33 rows)

 
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1)
 group by a1
 order by a1, cnt
 limit 10;
 a1 | cnt 
----+-----
 17 |   1
 18 |   1
 19 |   1
 30 |   1
 31 |   1
(5 rows)

 
explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1 and
			 t_subplan1.d1 < (select max(d2) from t_subplan2))
 group by a1
 order by a1, cnt
 limit 10;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan1
                                         Filter: ((a1 + b1) < 200)
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  Vector Nest Loop
                                                   Join Filter: (nodegroup_subplan_test.t_subplan1.a1 = nodegroup_subplan_test.t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                                         ->  CStore Scan on t_subplan1
                                                               Filter: ((b1)::numeric > (1.2 * (SubPlan 3)))
                                                               SubPlan 3
                                                                 ->  Row Adapter
                                                                       ->  Vector Aggregate
                                                                             InitPlan 2 (returns $1)
                                                                               ->  Row Adapter
                                                                                     ->  Vector Aggregate
                                                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                                 ->  Vector Aggregate
                                                                                                       ->  CStore Scan on t_subplan2 (min-max optimization)
                                                                             ->  Vector Result
                                                                                   Filter: ((nodegroup_subplan_test.t_subplan1.d1 < $1) AND (t2.c2 = nodegroup_subplan_test.t_subplan1.c1))
                                                                                   ->  Vector Materialize
                                                                                         ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                               ->  CStore Scan on t_subplan2 t2
                                                   ->  Vector Materialize
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->group1)
                                                               ->  CStore Scan on t_subplan2
                                                                     Filter: ((c2)::numeric > $0)
(41 rows)

select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1 and
			 t_subplan1.d1 < (select max(d2) from t_subplan2))
 group by a1
 order by a1, cnt
 limit 10;
 a1 | cnt 
----+-----
 17 |   1
 18 |   1
 19 |   1
 30 |   1
 31 |   1
(5 rows)

explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1 and
			 t2.d2 > (select min(d1) from t_subplan1))
 group by a1
 order by a1, cnt
 limit 10;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan1
                                         Filter: ((a1 + b1) < 200)
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: nodegroup_subplan_test.t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  Vector Nest Loop
                                                   Join Filter: (nodegroup_subplan_test.t_subplan1.a1 = t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->group1)
                                                         ->  CStore Scan on t_subplan2
                                                               Filter: ((c2)::numeric > $0)
                                                   ->  Vector Materialize
                                                         ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                                               ->  Vector Sonic Hash Join
                                                                     Hash Cond: (nodegroup_subplan_test.t_subplan1.c1 = t2.c2)
                                                                     Join Filter: ((nodegroup_subplan_test.t_subplan1.b1)::numeric > (1.2 * (avg(t2.b2))))
                                                                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                                           ->  CStore Scan on t_subplan1
                                                                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng0)
                                                                           ->  Vector Sonic Hash Aggregate
                                                                                 Group By Key: t2.c2
                                                                                 InitPlan 2 (returns $1)
                                                                                   ->  Row Adapter
                                                                                         ->  Vector Aggregate
                                                                                               ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                                                                     ->  Vector Aggregate
                                                                                                           ->  CStore Scan on t_subplan1 (min-max optimization)
                                                                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->group1)
                                                                                       ->  CStore Scan on t_subplan2 t2
                                                                                             Filter: (d2 > $1)
(42 rows)

select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select avg (d1)
              from t_subplan1
               where a1+b1<200 )
        and b1 > 1.2 *
             (select avg(b2)
             from t_subplan2 t2
             where t2.c2=t_subplan1.c1 and
			 t2.d2 > (select min(d1) from t_subplan1))
 group by a1
 order by a1, cnt
 limit 10;
 a1 | cnt 
----+-----
 16 |   1
 17 |   1
 18 |   1
 19 |   1
 30 |   1
 31 |   1
 32 |   1
(7 rows)

explain (costs off)
select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2
					where t1.d1=t2.d2))
 group by a1
 order by a1, cnt
 limit 10;
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Limit
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: group1->GenGroup)
                             ->  Vector Aggregate
                                   ->  Vector Sonic Hash Join
                                         Hash Cond: (t1.d1 = t2.d2)
                                         Join Filter: ((t1.a1)::numeric > (avg(t2.a2)))
                                         ->  Vector Streaming(type: REDISTRIBUTE ng: ng0->group1)
                                               ->  CStore Scan on t_subplan1 t1
                                         ->  Vector Sonic Hash Aggregate
                                               Group By Key: t2.d2
                                               ->  Vector Streaming(type: REDISTRIBUTE ng: ng1->group1)
                                                     ->  CStore Scan on t_subplan2 t2
         ->  Vector Streaming (type: GATHER)
               Merge Sort Key: t_subplan1.a1, (count(*))
               ->  Vector Limit
                     ->  Vector Sort
                           Sort Key: t_subplan1.a1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: t_subplan1.a1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng0->group1)
                                             ->  Vector Sonic Hash Join
                                                   Hash Cond: (t_subplan1.a1 = t_subplan2.a2)
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                         ->  CStore Scan on t_subplan1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng1->ng0)
                                                         ->  CStore Scan on t_subplan2
                                                               Filter: ((c2)::numeric > $0)
(32 rows)

select  a1, count(*) cnt
 from t_subplan1
 ,t_subplan2
 where a1 = a2
		and c2 >
             (select (avg (d1))
              from t_subplan1 t1
               where a1 > 
					(select avg(a2)
					from t_subplan2 t2
					where t1.d1=t2.d2))
 group by a1
 order by a1, cnt
 limit 10;
 a1 | cnt 
----+-----
  3 |   1
  4 |   1
  5 |   1
  6 |   1
  7 |   1
  8 |   1
  9 |   1
 10 |   1
 11 |   1
 15 |   1
(10 rows)

-- Set up some simple test tables
CREATE TABLE INT4_TBL(f1 int4) with (orientation=column,autovacuum_enabled = off) to group ng2;
INSERT INTO INT4_TBL(f1) VALUES ('   0  ');
INSERT INTO INT4_TBL(f1) VALUES ('123456     ');
INSERT INTO INT4_TBL(f1) VALUES ('    -123456');
INSERT INTO INT4_TBL(f1) VALUES ('2147483647');
INSERT INTO INT4_TBL(f1) VALUES ('-2147483647');
INSERT INTO INT4_TBL(f1) VALUES (NULL);
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	varchar(64),
	stringu2	varchar(64),
	string4		varchar(64)
) WITH (orientation=column) to group ng1;
--?COPY tenk1 FROM '.*'
CREATE TABLE SUBSELECT_TBL (
  f1 integer,
  f2 integer,
  f3 float
) with (orientation=column,autovacuum_enabled = off) distribute by hash(f1, f2, f3) to group ng3;
INSERT INTO SUBSELECT_TBL VALUES (1, 2, 3);
INSERT INTO SUBSELECT_TBL VALUES (2, 3, 4);
INSERT INTO SUBSELECT_TBL VALUES (3, 4, 5);
INSERT INTO SUBSELECT_TBL VALUES (1, 1, 1);
INSERT INTO SUBSELECT_TBL VALUES (2, 2, 2);
INSERT INTO SUBSELECT_TBL VALUES (3, 3, 3);
INSERT INTO SUBSELECT_TBL VALUES (6, 7, 8);
INSERT INTO SUBSELECT_TBL VALUES (8, 9, NULL);
SELECT '' AS eight, * FROM SUBSELECT_TBL ORDER BY f1, f2, f3;
 eight | f1 | f2 | f3 
-------+----+----+----
       |  1 |  1 |  1
       |  1 |  2 |  3
       |  2 |  2 |  2
       |  2 |  3 |  4
       |  3 |  3 |  3
       |  3 |  4 |  5
       |  6 |  7 |  8
       |  8 |  9 |   
(8 rows)

-- Uncorrelated subselects
explain (costs off)
SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT 1) ORDER BY 2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: subselect_tbl.f1
         ->  Vector Sort
               Sort Key: subselect_tbl.f1
               ->  Vector Hash Semi Join
                     Hash Cond: (subselect_tbl.f1 = (1))
                     ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                           ->  CStore Scan on subselect_tbl
                     ->  Vector Streaming(type: BROADCAST ng: group1->ng3)
                           ->  Vector Adapter
                                 ->  Result
(12 rows)

SELECT '' AS two, f1 AS "Constant Select" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT 1) ORDER BY 2;
 two | Constant Select 
-----+-----------------
     |               1
     |               1
(2 rows)

explain (costs off)
SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL) 
  ORDER BY 2;
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: nodegroup_subplan_test.subselect_tbl.f1
         ->  Vector Sort
               Sort Key: nodegroup_subplan_test.subselect_tbl.f1
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Sonic Hash Join
                           Hash Cond: (nodegroup_subplan_test.subselect_tbl.f1 = nodegroup_subplan_test.subselect_tbl.f2)
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  CStore Scan on subselect_tbl
                           ->  Vector Sonic Hash Aggregate
                                 Group By Key: nodegroup_subplan_test.subselect_tbl.f2
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: nodegroup_subplan_test.subselect_tbl.f2
                                             ->  CStore Scan on subselect_tbl
(16 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL) 
  ORDER BY 2;
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  1
     |                  2
     |                  2
     |                  3
     |                  3
(6 rows)

explain (costs off)
SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
    f2 IN (SELECT f1 FROM SUBSELECT_TBL)) 
    ORDER BY 2;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: nodegroup_subplan_test.subselect_tbl.f1
         ->  Vector Sort
               Sort Key: nodegroup_subplan_test.subselect_tbl.f1
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Hash Right Semi Join
                           Hash Cond: (nodegroup_subplan_test.subselect_tbl.f2 = nodegroup_subplan_test.subselect_tbl.f1)
                           ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                 ->  Vector Sonic Hash Join
                                       Hash Cond: (nodegroup_subplan_test.subselect_tbl.f2 = nodegroup_subplan_test.subselect_tbl.f1)
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  CStore Scan on subselect_tbl
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: nodegroup_subplan_test.subselect_tbl.f1
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                   ->  Vector Sonic Hash Aggregate
                                                         Group By Key: nodegroup_subplan_test.subselect_tbl.f1
                                                         ->  CStore Scan on subselect_tbl
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  CStore Scan on subselect_tbl
(21 rows)

SELECT '' AS six, f1 AS "Uncorrelated Field" FROM SUBSELECT_TBL
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE
    f2 IN (SELECT f1 FROM SUBSELECT_TBL)) 
    ORDER BY 2;
 six | Uncorrelated Field 
-----+--------------------
     |                  1
     |                  1
     |                  2
     |                  2
     |                  3
     |                  3
(6 rows)

explain (costs off)
SELECT '' AS three, f1, f2
  FROM SUBSELECT_TBL
  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                         WHERE f3 IS NOT NULL) 
                         ORDER BY f1, f2;
                                                                                                                                                                                                                          QUERY PLAN                                                                                                                                                                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: nodegroup_subplan_test.subselect_tbl.f1, nodegroup_subplan_test.subselect_tbl.f2
         ->  Vector Sort
               Sort Key: nodegroup_subplan_test.subselect_tbl.f1, nodegroup_subplan_test.subselect_tbl.f2
               ->  Vector Nest Loop Anti Join
                     Join Filter: (((nodegroup_subplan_test.subselect_tbl.f1 = nodegroup_subplan_test.subselect_tbl.f2) OR (nodegroup_subplan_test.subselect_tbl.f1 IS NULL) OR (nodegroup_subplan_test.subselect_tbl.f2 IS NULL)) AND ((nodegroup_subplan_test.subselect_tbl.f2 = (nodegroup_subplan_test.subselect_tbl.f3)::integer) OR (nodegroup_subplan_test.subselect_tbl.f2 IS NULL) OR ((nodegroup_subplan_test.subselect_tbl.f3)::integer IS NULL)))
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng3->group1)
                           ->  CStore Scan on subselect_tbl
                     ->  Vector Materialize
                           ->  Vector Streaming(type: BROADCAST dop: 1/2 ng: ng3->group1)
                                 ->  CStore Scan on subselect_tbl
                                       Filter: (f3 IS NOT NULL)
(13 rows)

SELECT '' AS three, f1, f2
  FROM SUBSELECT_TBL
  WHERE (f1, f2) NOT IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                         WHERE f3 IS NOT NULL) 
                         ORDER BY f1, f2;
 three | f1 | f2 
-------+----+----
       |  1 |  2
       |  6 |  7
       |  8 |  9
(3 rows)

-- Correlated subselects
explain (costs off)
SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1) 
  ORDER BY f1, f2;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: upper.f1, upper.f2
         ->  Vector Sort
               Sort Key: upper.f1, upper.f2
               ->  CStore Scan on subselect_tbl upper
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Row Adapter
                             ->  Vector Result
                                   Filter: (subselect_tbl.f1 = upper.f1)
                                   ->  Vector Materialize
                                         ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                               ->  CStore Scan on subselect_tbl
(14 rows)

SELECT '' AS six, f1 AS "Correlated Field", f2 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN (SELECT f2 FROM SUBSELECT_TBL WHERE f1 = upper.f1) 
  ORDER BY f1, f2;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            1
     |                1 |            2
     |                2 |            2
     |                2 |            3
     |                3 |            3
     |                3 |            4
(6 rows)

explain (costs off)
SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN
    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3)
    ORDER BY 2, 3;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: upper.f1, upper.f3
         ->  Vector Sort
               Sort Key: upper.f1, upper.f3
               ->  CStore Scan on subselect_tbl upper
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Row Adapter
                             ->  Vector Result
                                   Filter: ((upper.f2)::double precision = subselect_tbl.f3)
                                   ->  Vector Materialize
                                         ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                               ->  CStore Scan on subselect_tbl
(14 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f1 IN
    (SELECT f2 FROM SUBSELECT_TBL WHERE CAST(upper.f2 AS float) = f3)
    ORDER BY 2, 3;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            1
     |                2 |            2
     |                2 |            4
     |                3 |            3
     |                3 |            5
(5 rows)

explain (costs off)
SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
               WHERE f2 = CAST(f3 AS integer)) 
               ORDER BY 2, 3;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: upper.f1, upper.f3
         ->  Vector Sort
               Sort Key: upper.f1, upper.f3
               ->  CStore Scan on subselect_tbl upper
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Row Adapter
                             ->  Vector Result
                                   ->  Vector Materialize
                                         ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                               ->  CStore Scan on subselect_tbl
                                                     Filter: (f2 = (f3)::integer)
(14 rows)

SELECT '' AS six, f1 AS "Correlated Field", f3 AS "Second Field"
  FROM SUBSELECT_TBL upper
  WHERE f3 IN (SELECT upper.f1 + f2 FROM SUBSELECT_TBL
               WHERE f2 = CAST(f3 AS integer)) 
               ORDER BY 2, 3;
 six | Correlated Field | Second Field 
-----+------------------+--------------
     |                1 |            3
     |                2 |            4
     |                3 |            5
     |                6 |            8
(4 rows)

explain (costs off)
SELECT '' AS five, f1 AS "Correlated Field"
  FROM SUBSELECT_TBL
  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                     WHERE f3 IS NOT NULL) 
                     ORDER BY 2;
                                                                                                          QUERY PLAN                                                                                                           
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: nodegroup_subplan_test.subselect_tbl.f1
         ->  Vector Sort
               Sort Key: nodegroup_subplan_test.subselect_tbl.f1
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Hash Semi Join
                           Hash Cond: ((nodegroup_subplan_test.subselect_tbl.f1 = nodegroup_subplan_test.subselect_tbl.f2) AND (nodegroup_subplan_test.subselect_tbl.f2 = (nodegroup_subplan_test.subselect_tbl.f3)::integer))
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  CStore Scan on subselect_tbl
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  CStore Scan on subselect_tbl
                                       Filter: (f3 IS NOT NULL)
(13 rows)

SELECT '' AS five, f1 AS "Correlated Field"
  FROM SUBSELECT_TBL
  WHERE (f1, f2) IN (SELECT f2, CAST(f3 AS int4) FROM SUBSELECT_TBL
                     WHERE f3 IS NOT NULL) 
                     ORDER BY 2;
 five | Correlated Field 
------+------------------
      |                1
      |                2
      |                2
      |                3
      |                3
(5 rows)

--
-- Use some existing tables in the regression test
--
explain (costs off)
SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
  FROM SUBSELECT_TBL ss
  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
                   WHERE f1 != ss.f1 AND f1 < 2147483647) 
                   ORDER BY 2, 3;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: ss.f1, ss.f3
         ->  Vector Sort
               Sort Key: ss.f1, ss.f3
               ->  CStore Scan on subselect_tbl ss
                     Filter: (NOT (SubPlan 1))
                     SubPlan 1
                       ->  Row Adapter
                             ->  Vector Result
                                   Filter: (int4_tbl.f1 <> ss.f1)
                                   ->  Vector Materialize
                                         ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                               ->  CStore Scan on int4_tbl
                                                     Filter: (f1 < 2147483647)
(15 rows)

SELECT '' AS eight, ss.f1 AS "Correlated Field", ss.f3 AS "Second Field"
  FROM SUBSELECT_TBL ss
  WHERE f1 NOT IN (SELECT f1+1 FROM INT4_TBL
                   WHERE f1 != ss.f1 AND f1 < 2147483647) 
                   ORDER BY 2, 3;
 eight | Correlated Field | Second Field 
-------+------------------+--------------
       |                2 |            2
       |                2 |            4
       |                3 |            3
       |                3 |            5
       |                6 |            8
       |                8 |             
(6 rows)

explain (costs off)
select f1, float8(count(*)) / (select count(*) from int4_tbl)
from int4_tbl group by f1 order by f1;
                                      QUERY PLAN                                       
---------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: nodegroup_subplan_test.int4_tbl.f1
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on int4_tbl
         ->  Vector Sort
               Sort Key: nodegroup_subplan_test.int4_tbl.f1
               ->  Vector Hash Aggregate
                     Group By Key: nodegroup_subplan_test.int4_tbl.f1
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng2->group1)
                           ->  CStore Scan on int4_tbl
(15 rows)

select f1, float8(count(*)) / (select count(*) from int4_tbl)
from int4_tbl group by f1 order by f1;
     f1      |     ?column?     
-------------+------------------
 -2147483647 | .166666666666667
     -123456 | .166666666666667
           0 | .166666666666667
      123456 | .166666666666667
  2147483647 | .166666666666667
             | .166666666666667
(6 rows)

--
-- Test cases to catch unpleasant interactions between IN-join processing
-- and subquery pullup.
--
-- delelte this sentence, because the output is related with number of nodes
--select count(*) from
--  (select 1 from tenk1 a
--   where unique1 IN (select hundred from tenk1 b)) ss;
explain (costs off)
select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Aggregate
         ->  Vector Streaming (type: GATHER)
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Aggregate
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  Vector Hash Right Semi Join
                                       Hash Cond: (b.hundred = a.unique1)
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                             ->  CStore Scan on tenk1 b
                                       ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                             ->  CStore Scan on tenk1 a
(12 rows)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

explain (costs off)
select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Aggregate
         ->  Vector Streaming (type: GATHER)
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Aggregate
                           ->  Vector Sonic Hash Join
                                 Hash Cond: (a.unique1 = b.hundred)
                                 ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                       ->  CStore Scan on tenk1 a
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                                       ->  Vector Sonic Hash Aggregate
                                             Group By Key: b.hundred
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->group1)
                                                   ->  CStore Scan on tenk1 b
(14 rows)

select count(*) from
  (select 1 from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
   100
(1 row)

explain (costs off)
select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Aggregate
         ->  Vector Streaming (type: GATHER)
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     ->  Vector Aggregate
                           ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                 ->  Vector Sonic Hash Join
                                       Hash Cond: (a.unique1 = b.hundred)
                                       ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                             ->  CStore Scan on tenk1 a
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                                             ->  Vector Sonic Hash Aggregate
                                                   Group By Key: b.hundred
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->group1)
                                                         ->  CStore Scan on tenk1 b
(15 rows)

select count(distinct ss.ten) from
  (select ten from tenk1 a
   where unique1 IN (select distinct hundred from tenk1 b)) ss;
 count 
-------
    10
(1 row)

--
-- Test cases to check for overenthusiastic optimization of
-- "IN (SELECT DISTINCT ...)" and related cases.  Per example from
-- Luca Pireddu and Michael Fuhr.
--
-- Enforce use of COMMIT instead of 2PC for temporary objects
-- CREATE TEMP TABLE subselect_foo (id integer);
CREATE  TABLE subselect_foo (id integer) with (orientation = column) to group ng1;
-- CREATE TEMP TABLE bar (id1 integer, id2 integer);
CREATE  TABLE subselect_bar (id1 integer, id2 integer) with (orientation = column) to group ng2;
INSERT INTO subselect_foo VALUES (1);
INSERT INTO subselect_bar VALUES (1, 1);
INSERT INTO subselect_bar VALUES (2, 2);
INSERT INTO subselect_bar VALUES (3, 1);
-- These cases require an extra level of distinct-ing above subquery s
explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM subselect_bar) AS s);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Hash Semi Join
                     Hash Cond: (subselect_foo.id = s.id2)
                     ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                           ->  CStore Scan on subselect_foo
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                           ->  Vector Subquery Scan on s
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: subselect_bar.id1, subselect_bar.id2
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng2->group1)
                                             ->  CStore Scan on subselect_bar
(13 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT id1, id2 FROM subselect_bar) AS s);
 id 
----
  1
(1 row)

explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id1,id2 FROM subselect_bar GROUP BY id1,id2) AS s);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Hash Semi Join
                     Hash Cond: (subselect_foo.id = s.id2)
                     ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                           ->  CStore Scan on subselect_foo
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                           ->  Vector Subquery Scan on s
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: subselect_bar.id1, subselect_bar.id2
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng2->group1)
                                             ->  CStore Scan on subselect_bar
(13 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id1,id2 FROM subselect_bar GROUP BY id1,id2) AS s);
 id 
----
  1
(1 row)

explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id1, id2 FROM subselect_bar UNION
                      SELECT id1, id2 FROM subselect_bar) AS s);
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Hash Semi Join
                     Hash Cond: (subselect_foo.id = s.id2)
                     ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                           ->  CStore Scan on subselect_foo
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng2->ng1)
                           ->  Vector Subquery Scan on s
                                 ->  Vector Sonic Hash Aggregate
                                       Group By Key: nodegroup_subplan_test.subselect_bar.id1, nodegroup_subplan_test.subselect_bar.id2
                                       ->  Vector Append
                                             ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                                   ->  CStore Scan on subselect_bar
                                             ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                                                   ->  CStore Scan on subselect_bar
(16 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id1, id2 FROM subselect_bar UNION
                      SELECT id1, id2 FROM subselect_bar) AS s);
 id 
----
  1
(1 row)

-- These cases do not
explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM subselect_bar) AS s);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Hash Join
   Hash Cond: (subselect_foo.id = s.id2)
   ->  Data Node Scan on subselect_foo "_REMOTE_TABLE_QUERY_"
   ->  Hash
         ->  Subquery Scan on s
               ->  Unique
                     ->  Sort
                           Sort Key: subselect_bar.id2
                           ->  Data Node Scan on subselect_bar "_REMOTE_TABLE_QUERY_"
(9 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT DISTINCT ON (id2) id1, id2 FROM subselect_bar) AS s);
 id 
----
  1
(1 row)

explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM subselect_bar GROUP BY id2) AS s);
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Sonic Hash Join
                     Hash Cond: (subselect_foo.id = subselect_bar.id2)
                     ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 2/2)
                           ->  CStore Scan on subselect_foo
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: group1->ng1)
                           ->  Vector Sonic Hash Aggregate
                                 Group By Key: subselect_bar.id2
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng2->group1)
                                       ->  CStore Scan on subselect_bar
(12 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM subselect_bar GROUP BY id2) AS s);
 id 
----
  1
(1 row)

explain (costs off)
SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM subselect_bar UNION
                      SELECT id2 FROM subselect_bar) AS s);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Sonic Hash Join
                     Hash Cond: (subselect_foo.id = nodegroup_subplan_test.subselect_bar.id2)
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2 ng: ng1->ng2)
                           ->  CStore Scan on subselect_foo
                     ->  Vector Sonic Hash Aggregate
                           Group By Key: nodegroup_subplan_test.subselect_bar.id2
                           ->  Vector Append
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  CStore Scan on subselect_bar
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  CStore Scan on subselect_bar
(14 rows)

SELECT * FROM subselect_foo WHERE id IN
    (SELECT id2 FROM (SELECT id2 FROM subselect_bar UNION
                      SELECT id2 FROM subselect_bar) AS s);
 id 
----
  1
(1 row)

--
-- Test case to catch problems with multiply nested sub-SELECTs not getting
-- recalculated properly.  Per bug report from Didier Moens.
--
CREATE TABLE orderstest (
    approver_ref integer,
    po_ref integer,
    ordercanceled boolean
) with (orientation = column,autovacuum_enabled = off) to group ng3;
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 5, false);
INSERT INTO orderstest VALUES (66, 6, false);
INSERT INTO orderstest VALUES (66, 7, false);
INSERT INTO orderstest VALUES (66, 1, true);
INSERT INTO orderstest VALUES (66, 8, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (77, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
INSERT INTO orderstest VALUES (66, 1, false);
INSERT INTO orderstest VALUES (1, 1, false);
CREATE VIEW orders_view AS
SELECT *,
(SELECT CASE
   WHEN ord.approver_ref=1 THEN '---' ELSE 'Approved'
 END) AS "Approved",
(SELECT CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (SELECT CASE
		WHEN ord.po_ref=1
		THEN
		 (SELECT CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status",
(CASE
 WHEN ord.ordercanceled
 THEN 'Canceled'
 ELSE
  (CASE
		WHEN ord.po_ref=1
		THEN
		 (CASE
				WHEN ord.approver_ref=1
				THEN '---'
				ELSE 'Approved'
			END)
		ELSE 'PO'
	END)
END) AS "Status_OK"
FROM orderstest ord;
explain (costs off)
SELECT * FROM orders_view 
ORDER BY approver_ref, po_ref, ordercanceled;
                               QUERY PLAN                                
-------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: ord.approver_ref, ord.po_ref, ord.ordercanceled
         ->  Vector Sort
               Sort Key: ord.approver_ref, ord.po_ref, ord.ordercanceled
               ->  CStore Scan on orderstest ord
                     SubPlan 1
                       ->  Result
                     SubPlan 4
                       ->  Result
                             InitPlan 3 (returns $4)
                               ->  Result
                                     InitPlan 2 (returns $2)
                                       ->  Result
(14 rows)

SELECT * FROM orders_view 
ORDER BY approver_ref, po_ref, ordercanceled;
 approver_ref | po_ref | ordercanceled | Approved |  Status  | Status_OK 
--------------+--------+---------------+----------+----------+-----------
            1 |      1 | f             | ---      | ---      | ---
            1 |      1 | f             | ---      | ---      | ---
            1 |      1 | f             | ---      | ---      | ---
           66 |      1 | f             | Approved | Approved | Approved
           66 |      1 | f             | Approved | Approved | Approved
           66 |      1 | t             | Approved | Canceled | Canceled
           66 |      5 | f             | Approved | PO       | PO
           66 |      6 | f             | Approved | PO       | PO
           66 |      7 | f             | Approved | PO       | PO
           66 |      8 | f             | Approved | PO       | PO
           77 |      1 | f             | Approved | Approved | Approved
(11 rows)

DROP TABLE orderstest cascade;
NOTICE:  drop cascades to view orders_view
explain (costs off)
select f1, ss1 as relabel from
    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
     from int4_tbl a) ss 
     ORDER BY f1, relabel;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: a.f1, ((SubPlan 1))
         ->  Vector Sort
               Sort Key: a.f1, ((SubPlan 1))
               ->  CStore Scan on int4_tbl a
                     SubPlan 1
                       ->  Row Adapter
                             ->  Vector Aggregate
                                   ->  Vector Result
                                         Filter: (b.f1 >= a.f1)
                                         ->  Vector Materialize
                                               ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                                     ->  CStore Scan on int4_tbl b
(14 rows)

select f1, ss1 as relabel from
    (select *, (select sum(f1) from int4_tbl b where f1 >= a.f1) as ss1
     from int4_tbl a) ss 
     ORDER BY f1, relabel;
     f1      |  relabel   
-------------+------------
 -2147483647 |          0
     -123456 | 2147483647
           0 | 2147607103
      123456 | 2147607103
  2147483647 | 2147483647
             |           
(6 rows)

--
-- Test cases involving PARAM_EXEC parameters and min/max index optimizations.
-- Per bug report from David Sanchez i Gregori.
--
explain (costs off)
select * from (
  select max(unique1) from tenk1 as a
  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
) ss;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Aggregate
               ->  Vector Streaming(type: BROADCAST dop: 1/2 ng: ng1->GenGroup)
                     ->  Vector Aggregate
                           ->  Vector Hash Semi Join
                                 Hash Cond: (a.unique2 = b.thousand)
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  CStore Scan on tenk1 a
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                       ->  CStore Scan on tenk1 b
(11 rows)

select * from (
  select max(unique1) from tenk1 as a
  where exists (select 1 from tenk1 as b where b.thousand = a.unique2)
) ss;
 max  
------
 9997
(1 row)

explain (costs off)
select * from (
  select min(unique1) from tenk1 as a
  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
) ss;
                                  QUERY PLAN                                   
-------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Aggregate
               InitPlan 1 (returns $0)
                 ->  Row Adapter
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  CStore Scan on tenk1 b
                                   Filter: (unique2 = 10000)
               ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                     ->  Vector Aggregate
                           ->  Vector Result
                                 One-Time Filter: (NOT $0)
                                 ->  CStore Scan on tenk1 a
(13 rows)

select * from (
  select min(unique1) from tenk1 as a
  where not exists (select 1 from tenk1 as b where b.unique2 = 10000)
) ss;
 min 
-----
   0
(1 row)

--
-- Test case for bug #4290: bogus calculation of subplan param sets
--
create  table ta (id int, val int) with (orientation=column) to group ng1;
insert into ta values(1,1);
insert into ta values(2,2);
create  table tb (id int, aval int) with (orientation=column) to group ng2;
insert into tb values(1,1);
insert into tb values(2,1);
insert into tb values(3,2);
insert into tb values(4,2);
create  table tc (id int, aid int) with (orientation=column) to group ng3;
insert into tc values(1,1);
insert into tc values(2,2);
explain (costs off)
select
  ( select min(tb.id) from tb
    where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
from tc 
ORDER BY min_tb_id;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: ((SubPlan 2))
         ->  Vector Sort
               Sort Key: ((SubPlan 2))
               ->  CStore Scan on tc
                     SubPlan 2
                       ->  Row Adapter
                             ->  Vector Aggregate
                                   InitPlan 1 (returns $1)
                                     ->  Row Adapter
                                           ->  Vector Result
                                                 Filter: (ta.id = tc.aid)
                                                 ->  Vector Materialize
                                                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                             ->  CStore Scan on ta
                                   ->  Vector Result
                                         Filter: (tb.aval = $1)
                                         ->  Vector Materialize
                                               ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                                     ->  CStore Scan on tb
(21 rows)

select
  ( select min(tb.id) from tb
    where tb.aval = (select ta.val from ta where ta.id = tc.aid) ) as min_tb_id
from tc 
ORDER BY min_tb_id;
 min_tb_id 
-----------
         1
         3
(2 rows)

--
-- Test case for 8.3 "failed to locate grouping columns" bug
--
-- create temp table t1 (f1 numeric(14,0), f2 varchar(30));
create  table subselect_t1 (f1 numeric(14,0), f2 varchar(30)) with (orientation=column) to group ng0;
explain (costs off)
select * from
  (select distinct f1, f2, (select f2 from subselect_t1 x where x.f1 = up.f1) as fs
   from subselect_t1 up) ss
group by f1,f2,fs;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Sonic Hash Aggregate
                     Group By Key: up.f1, up.f2, ((SubPlan 1))
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                           ->  Vector Hash Aggregate
                                 Group By Key: up.f1, up.f2, ((SubPlan 1))
                                 ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                       ->  CStore Scan on subselect_t1 up
                                             SubPlan 1
                                               ->  Row Adapter
                                                     ->  Vector Result
                                                           Filter: (x.f1 = up.f1)
                                                           ->  Vector Materialize
                                                                 ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                                       ->  CStore Scan on subselect_t1 x
(17 rows)

select * from
  (select distinct f1, f2, (select f2 from subselect_t1 x where x.f1 = up.f1) as fs
   from subselect_t1 up) ss
group by f1,f2,fs;
 f1 | f2 | fs 
----+----+----
(0 rows)

--
-- Check that whole-row Vars reading the result of a subselect don't include
-- any junk columns therein
--
explain (costs off)
select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
                       QUERY PLAN                       
--------------------------------------------------------
 Subquery Scan on q
   ->  Sort
         Sort Key: int4_tbl.f1
         ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
(4 rows)

select q from (select max(f1) from int4_tbl group by f1 order by f1) q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
 ()
(6 rows)

explain (costs off)
with q as (select max(f1) from int4_tbl group by f1 order by f1)
  select q from q;
                        QUERY PLAN                        
----------------------------------------------------------
 CTE Scan on q
   CTE q
     ->  Sort
           Sort Key: int4_tbl.f1
           ->  Data Node Scan on "__REMOTE_GROUP_QUERY__"
(5 rows)

with q as (select max(f1) from int4_tbl group by f1 order by f1)
  select q from q;
       q       
---------------
 (-2147483647)
 (-123456)
 (0)
 (123456)
 (2147483647)
 ()
(6 rows)

--
-- Test case for sublinks pushed down into subselects via join alias expansion
--
explain (costs off)
select
  (select sq1) as qq1
from
  (select exists(select 1 from int4_tbl where f1 = f1) as sq1, 42 as dummy
   from int4_tbl) sq0
  join
  int4_tbl i4 on dummy = i4.f1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         InitPlan 2 (returns $1)
           ->  Result
                 InitPlan 1 (returns $0)
                   ->  Row Adapter
                         ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                               ->  CStore Scan on int4_tbl
                                     Filter: (f1 IS NOT NULL)
         ->  Vector Nest Loop
               ->  Vector Streaming(type: BROADCAST dop: 1/2)
                     ->  CStore Scan on int4_tbl i4
                           Filter: (42 = f1)
               ->  CStore Scan on int4_tbl
(14 rows)

select
  (select sq1) as qq1
from
  (select exists(select 1 from int4_tbl where f1 = f1) as sq1, 42 as dummy
   from int4_tbl) sq0
  join
  int4_tbl i4 on dummy = i4.f1;
 qq1 
-----
(0 rows)

--
-- Test case for cross-type partial matching in hashed subplan (bug #7597)
--
-- create temp table outer_7597 (f1 int4, f2 int4);
create  table outer_7597 (f1 int4, f2 int4) with (orientation=column) to group ng0;
insert into outer_7597 values (0, 0);
insert into outer_7597 values (1, 0);
insert into outer_7597 values (0, null);
insert into outer_7597 values (1, null);
-- create temp table inner_7597(c1 int8, c2 int8);
create  table inner_7597(c1 int8, c2 int8) with (orientation=column) to group ng1;
insert into inner_7597 values(0, null);
explain (costs off)
select * from outer_7597 where (f1, f2) not in (select * from inner_7597) order by 1, 2;
                                                                                                       QUERY PLAN                                                                                                       
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         Merge Sort Key: outer_7597.f1, outer_7597.f2
         ->  Vector Sort
               Sort Key: outer_7597.f1, outer_7597.f2
               ->  Vector Nest Loop Anti Join
                     Join Filter: (((outer_7597.f1 = inner_7597.c1) OR (outer_7597.f1 IS NULL) OR (inner_7597.c1 IS NULL)) AND ((outer_7597.f2 = inner_7597.c2) OR (outer_7597.f2 IS NULL) OR (inner_7597.c2 IS NULL)))
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                           ->  CStore Scan on outer_7597
                     ->  Vector Materialize
                           ->  Vector Streaming(type: BROADCAST dop: 1/2 ng: ng1->group1)
                                 ->  CStore Scan on inner_7597
(12 rows)

select * from outer_7597 where (f1, f2) not in (select * from inner_7597) order by 1, 2;
 f1 | f2 
----+----
  1 |  0
  1 |   
(2 rows)

--
-- Test case for planner bug with nested EXISTS handling
--
explain (costs off)
select a.thousand from tenk1 a, tenk1 b
where a.thousand = b.thousand
  and exists ( select 1 from tenk1 c where b.hundred = c.hundred
                   and not exists ( select 1 from tenk1 d
                                    where a.thousand = d.thousand ) );
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
               ->  Vector Hash Semi Join
                     Hash Cond: (b.hundred = c.hundred)
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                           ->  Vector Sonic Hash Join
                                 Hash Cond: (a.thousand = b.thousand)
                                 ->  Vector Streaming(type: SPLIT BROADCAST dop: 2/2)
                                       ->  Vector Hash Anti Join
                                             Hash Cond: (a.thousand = d.thousand)
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                   ->  CStore Scan on tenk1 a
                                             ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                                                   ->  CStore Scan on tenk1 d
                                 ->  CStore Scan on tenk1 b
                     ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/2)
                           ->  CStore Scan on tenk1 c
(18 rows)

select a.thousand from tenk1 a, tenk1 b
where a.thousand = b.thousand
  and exists ( select 1 from tenk1 c where b.hundred = c.hundred
                   and not exists ( select 1 from tenk1 d
                                    where a.thousand = d.thousand ) );
 thousand 
----------
(0 rows)

-- other sdv failed case
create table t_subplan3(a3 int, b3 int) with (orientation=column,autovacuum_enabled = off) distribute by replication  to group ng3
partition by range(a3) (partition p1 values less than (25), partition p2 values less than (maxvalue));
insert into t_subplan3 values(1, 20);
insert into t_subplan3 values(27, 27);
explain (costs off)
select * from t_subplan3 where b3=(select max(b2) from t_subplan2);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 ->  Vector Aggregate
                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                             ->  Vector Aggregate
                                   ->  CStore Scan on t_subplan2 (min-max optimization)
         ->  Vector Partition Iterator
               Iterations: 2
               ->  Partitioned CStore Scan on t_subplan3
                     Filter: (b3 = $0)
                     Selected Partitions:  1..2
(13 rows)

select * from t_subplan3 where b3=(select max(b2) from t_subplan2);
 a3 | b3 
----+----
 27 | 27
(1 row)

explain (costs off)
select count(*) from t_subplan3 t1 group by a3,b3
having not exists
(select sum(t2.b3), t2.a3, t2.b3, rank() over (partition by t1.b3 order by t2.a3) from t_subplan3 t2
group by 2,3 order by 1,2,3,4);
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Hash Aggregate
               Group By Key: t1.a3, t1.b3
               Filter: (NOT (SubPlan 1))
               ->  Vector Partition Iterator
                     Iterations: 2
                     ->  Partitioned CStore Scan on t_subplan3 t1
                           Selected Partitions:  1..2
               SubPlan 1
                 ->  Row Adapter
                       ->  Vector Sort
                             Sort Key: (sum(t2.b3)), t2.a3, t2.b3, (rank() OVER (ORDER BY t2.a3 USING = NULLS LAST))
                             ->  Vector WindowAgg
                                   ->  Vector Sort
                                         Sort Key: t2.a3
                                         ->  Vector Hash Aggregate
                                               Group By Key: t2.a3, t2.b3
                                               ->  Vector Materialize
                                                     ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                                           ->  Vector Partition Iterator
                                                                 Iterations: 2
                                                                 ->  Partitioned CStore Scan on t_subplan3 t2
                                                                       Selected Partitions:  1..2
(24 rows)

select count(*) from t_subplan3 t1 group by a3,b3
having not exists
(select sum(t2.b3), t2.a3, t2.b3, rank() over (partition by t1.b3 order by t2.a3) from t_subplan3 t2
group by 2,3 order by 1,2,3,4);
 count 
-------
(0 rows)

explain (costs off, verbose on)
select c1, d1 from t_subplan1
where exists(select b3 from t_subplan3 where a3>=2)
group by c1, d1 order by c1+1 desc, 2 desc limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan3.a3, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
   ->  Vector Limit
         Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
         InitPlan 1 (returns $1)
           ->  Row Adapter
                 Output: ('Dummy')
                 ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                       Output: ('Dummy')
                       ->  Vector Partition Iterator
                             Output: 'Dummy'
                             Iterations: 2
                             ->  Partitioned CStore Scan on nodegroup_subplan_test.t_subplan3
                                   Output: 'Dummy'
                                   Filter: (t_subplan3.a3 >= 2)
                                   Selected Partitions:  1..2
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
               Merge Sort Key: ((t_subplan1.c1 + 1)) DESC, t_subplan1.d1 DESC
               ->  Vector Limit
                     Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
                     ->  Vector Sort
                           Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
                           Sort Key: ((t_subplan1.c1 + 1)) DESC, t_subplan1.d1 DESC
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
                                 ->  Vector Limit
                                       Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
                                       ->  Vector Sort
                                             Output: t_subplan1.c1, t_subplan1.d1, ((t_subplan1.c1 + 1))
                                             Sort Key: ((t_subplan1.c1 + 1)) DESC, t_subplan1.d1 DESC
                                             ->  Vector Sonic Hash Aggregate
                                                   Output: t_subplan1.c1, t_subplan1.d1, (t_subplan1.c1 + 1)
                                                   Group By Key: t_subplan1.c1, t_subplan1.d1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                                         Output: t_subplan1.c1, t_subplan1.d1
                                                         Distribute Key: t_subplan1.c1, t_subplan1.d1
                                                         ->  Vector Result
                                                               Output: t_subplan1.c1, t_subplan1.d1
                                                               One-Time Filter: $1
                                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                     Output: t_subplan1.c1, t_subplan1.d1
                                                                     Distribute Key: t_subplan1.a1, t_subplan1.b1
(43 rows)

select c1, d1 from t_subplan1
where exists(select b3 from t_subplan3 where a3>=2)
group by c1, d1 order by c1+1 desc, 2 desc limit 5;
 c1 | d1 
----+----
 12 |  5
 12 |  4
 12 |  3
 12 |  2
 12 |  1
(5 rows)

explain (costs off, verbose on)
select * from t_subplan2 where
 exists (select d1 from t_subplan1 where d1<8 and
  exists (select b1 from t_subplan1 where c1<20 and
   exists (select * from t_subplan1 where d1<9 and d1 >1 order by d1 limit 7) order by c1,b1 limit 10))
and exists( select max(a1),count(b1),c2 from t_subplan1 group by c2 having c2>2 or c2 is null)
order by a2, b2, c2, d2 limit 10;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                         QUERY PLAN                                                                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
   ->  Vector Limit
         Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
         InitPlan 3 (returns $2)
           ->  Row Adapter
                 Output: ('Dummy')
                 ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                       Output: ('Dummy')
                       ->  Vector Result
                             Output: ('Dummy')
                             One-Time Filter: $1
                             InitPlan 2 (returns $1)
                               ->  Row Adapter
                                     Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                     ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                           Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                           ->  Vector Limit
                                                 Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                 InitPlan 1 (returns $0)
                                                   ->  Row Adapter
                                                         Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                         ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                               Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                               ->  Vector Limit
                                                                     Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                                     ->  Vector Streaming(type: BROADCAST)
                                                                           Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                                           Merge Sort Key: nodegroup_subplan_test.t_subplan1.d1
                                                                           ->  Vector Limit
                                                                                 Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                                                 ->  Vector Sort
                                                                                       Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                                                       Sort Key: nodegroup_subplan_test.t_subplan1.d1
                                                                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                                             Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                                                             Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                                             Filter: ((nodegroup_subplan_test.t_subplan1.d1 < 9) AND (nodegroup_subplan_test.t_subplan1.d1 > 1))
                                                 ->  Vector Sort
                                                       Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                       Sort Key: nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.b1
                                                       ->  Vector Streaming(type: BROADCAST)
                                                             Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                             ->  Vector Limit
                                                                   Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                                   ->  Vector Sort
                                                                         Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                                         Sort Key: nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.b1
                                                                         ->  Vector Result
                                                                               Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                                               One-Time Filter: $0
                                                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                                     Output: nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1
                                                                                     Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                                     Filter: (nodegroup_subplan_test.t_subplan1.c1 < 20)
                             ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                   Output: 'Dummy'
                                   Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                   Filter: (nodegroup_subplan_test.t_subplan1.d1 < 8)
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               Merge Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               ->  Vector Limit
                     Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                     ->  Vector Sort
                           Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                           Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                           ->  Vector Limit
                                 Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                 ->  Vector Sort
                                       Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                       Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                       ->  Vector Result
                                             Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                             One-Time Filter: $2
                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                   Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                                   Distribute Key: t_subplan2.a2, t_subplan2.b2
                                                   Filter: (SubPlan 4)
                                                   SubPlan 4
                                                     ->  Row Adapter
                                                           Output: (max(nodegroup_subplan_test.t_subplan1.a1)), (count(nodegroup_subplan_test.t_subplan1.b1)), ($3)
                                                           ->  Vector Sort Aggregate
                                                                 Output: max(nodegroup_subplan_test.t_subplan1.a1), count(nodegroup_subplan_test.t_subplan1.b1), (t_subplan2.c2)
                                                                 Group By Key: t_subplan2.c2
                                                                 ->  Vector Result
                                                                       Output: t_subplan2.c2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                       Filter: ((t_subplan2.c2 > 2) OR (t_subplan2.c2 IS NULL))
                                                                       ->  Vector Materialize
                                                                             Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                                                   Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                                         Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                                                         Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
(95 rows)

select * from t_subplan2 where
 exists (select d1 from t_subplan1 where d1<8 and
  exists (select b1 from t_subplan1 where c1<20 and
   exists (select * from t_subplan1 where d1<9 and d1 >1 order by d1 limit 7) order by c1,b1 limit 10))
and exists( select max(a1),count(b1),c2 from t_subplan1 group by c2 having c2>2 or c2 is null)
order by a2, b2, c2, d2 limit 10;
 a2 | b2 | c2 | d2 
----+----+----+----
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
  6 |  6 |  6 |  6
  7 |  7 |  7 |  7
  8 |  8 |  8 |  8
  9 |  9 |  9 |  0
 10 | 10 | 10 |  1
 11 | 11 | 11 |  2
 15 | 15 |  3 |  6
(10 rows)

explain (costs off, verbose on)
select * from t_subplan2 where
 exists( select max(a1),count(b1),c2 from t_subplan1 group by rollup(c2,c2) having c2>2 and c2 is not null)
order by a2,b2,c2,d2 limit 10;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
   ->  Vector Limit
         Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               Merge Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               ->  Vector Limit
                     Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                     ->  Vector Sort
                           Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                           Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                           ->  Vector Limit
                                 Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                 ->  Vector Sort
                                       Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                       Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                             Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                                             Distribute Key: t_subplan2.a2, t_subplan2.b2
                                             Filter: (SubPlan 1)
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: (max(t_subplan1.a1)), (count(t_subplan1.b1)), ($0)
                                                     ->  Vector Sort Aggregate
                                                           Output: max(t_subplan1.a1), count(t_subplan1.b1), (t_subplan2.c2)
                                                           Group By Key: t_subplan2.c2
                                                           Group By Key: t_subplan2.c2
                                                           Group By Key: ()
                                                           Filter: (((t_subplan2.c2) > 2) AND ((t_subplan2.c2) IS NOT NULL))
                                                           ->  Vector Result
                                                                 Output: t_subplan2.c2, t_subplan1.a1, t_subplan1.b1
                                                                 ->  Vector Materialize
                                                                       Output: t_subplan1.a1, t_subplan1.b1
                                                                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                                             Output: t_subplan1.a1, t_subplan1.b1
                                                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                                   Output: t_subplan1.a1, t_subplan1.b1
                                                                                   Distribute Key: t_subplan1.a1, t_subplan1.b1
(39 rows)

select * from t_subplan2 where
 exists( select max(a1),count(b1),c2 from t_subplan1 group by rollup(c2,c2) having c2>2 and c2 is not null)
order by a2,b2,c2,d2 limit 10;
 a2 | b2 | c2 | d2 
----+----+----+----
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
  6 |  6 |  6 |  6
  7 |  7 |  7 |  7
  8 |  8 |  8 |  8
  9 |  9 |  9 |  0
 10 | 10 | 10 |  1
 11 | 11 | 11 |  2
 15 | 15 |  3 |  6
(10 rows)

-- test any, all, rowcompare, array sublink
explain (costs off, verbose on)
select * from t_subplan1 where a1 in (select count(c2) from t_subplan2) or d1=0 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: ((hashed SubPlan 1) OR (t_subplan1.d1 = 0))
                     SubPlan 1
                       ->  Row Adapter
                             Output: (count((count(t_subplan2.c2))))
                             ->  Vector Materialize
                                   Output: (count((count(t_subplan2.c2))))
                                   ->  Vector Aggregate
                                         Output: count((count(t_subplan2.c2)))
                                         ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                               Output: (count(t_subplan2.c2))
                                               ->  Vector Aggregate
                                                     Output: count(t_subplan2.c2)
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                           Output: t_subplan2.c2
                                                           Distribute Key: t_subplan2.a2, t_subplan2.b2
(26 rows)

select * from t_subplan1 where a1 in (select count(c2) from t_subplan2) or d1=0 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  6 |  6 |  6 |  0
 12 | 12 | 12 |  0
 18 | 18 |  5 |  0
 24 |  4 | 11 |  0
 30 | 10 |  4 |  0
 36 | 16 | 10 |  0
 42 |  2 |  3 |  0
 48 |  8 |  9 |  0
 50 | 10 | 11 |  2
 54 | 14 |  2 |  0
 60 |  0 |  8 |  0
 66 |  6 |  1 |  0
 72 | 12 |  7 |  0
 78 | 18 |  0 |  0
 84 |  4 |  6 |  0
 90 | 10 | 12 |  0
 96 | 16 |  5 |  0
(17 rows)

explain (costs off, verbose on)
select * from t_subplan1 where a1 in (select count(c2) from t_subplan2 where c1>d2 minus all select d1 from t_subplan2) or d1=0 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: ((SubPlan 1) OR (t_subplan1.d1 = 0))
                     SubPlan 1
                       ->  Row Adapter
                             Output: "*SELECT* 1".count, (0)
                             ->  Vector HashSetOp Except All
                                   Output: "*SELECT* 1".count, (0)
                                   ->  Vector Append
                                         ->  Vector Subquery Scan on "*SELECT* 1"
                                               Output: "*SELECT* 1".count, 0
                                               ->  Vector Aggregate
                                                     Output: count(nodegroup_subplan_test.t_subplan2.c2)
                                                     ->  Vector Result
                                                           Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                           Filter: (t_subplan1.c1 > nodegroup_subplan_test.t_subplan2.d2)
                                                           ->  Vector Materialize
                                                                 Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                 ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                       Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                             Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                             Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                         ->  Vector Subquery Scan on "*SELECT* 2"
                                               Output: "*SELECT* 2".d1, 1
                                               ->  Vector Result
                                                     Output: t_subplan1.d1
                                                     ->  Vector Materialize
                                                           Output: ('Dummy')
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: ('Dummy')
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: 'Dummy'
                                                                       Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(43 rows)

select * from t_subplan1 where a1 in (select count(c2) from t_subplan2 where c1>d2 minus all select d1 from t_subplan2) or d1=0 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  6 |  6 |  6 |  0
 12 | 12 | 12 |  0
 18 | 18 |  5 |  0
 24 |  4 | 11 |  0
 30 | 10 |  4 |  0
 36 | 16 | 10 |  0
 42 |  2 |  3 |  0
 48 |  8 |  9 |  0
 50 | 10 | 11 |  2
 54 | 14 |  2 |  0
 60 |  0 |  8 |  0
 66 |  6 |  1 |  0
 72 | 12 |  7 |  0
 78 | 18 |  0 |  0
 84 |  4 |  6 |  0
 90 | 10 | 12 |  0
 96 | 16 |  5 |  0
(17 rows)

explain (costs off, verbose on)
select * from t_subplan1 where a1 in (select count(c2)::int from t_subplan2 where c1>d2 union all select d1 from t_subplan2) or d1=0 order by 1,2,3,4 limit 5;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Limit
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  Vector Limit
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     ->  Vector Sort
                           Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           ->  Vector Limit
                                 Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                 ->  Vector Sort
                                       Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             Filter: ((SubPlan 1) OR (t_subplan1.d1 = 0))
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: ((count(nodegroup_subplan_test.t_subplan2.c2))::integer)
                                                     ->  Vector Append
                                                           ->  Vector Aggregate
                                                                 Output: (count(nodegroup_subplan_test.t_subplan2.c2))::integer
                                                                 ->  Vector Result
                                                                       Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                       Filter: (t_subplan1.c1 > nodegroup_subplan_test.t_subplan2.d2)
                                                                       ->  Vector Materialize
                                                                             Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                   Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                         Output: nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan2.d2
                                                                                         Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                           ->  Vector Result
                                                                 Output: t_subplan1.d1
                                                                 ->  Vector Materialize
                                                                       Output: ('Dummy')
                                                                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                             Output: ('Dummy')
                                                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                   Output: 'Dummy'
                                                                                   Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(46 rows)

select * from t_subplan1 where a1 in (select count(c2)::int from t_subplan2 where c1>d2 union all select d1 from t_subplan2) or d1=0 order by 1,2,3,4 limit 5;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
(5 rows)

explain (costs off, verbose on)
select b1, count(*) from t_subplan1
where c1 = all (select b2 from t_subplan2 where b2>4)
or d1 != all (select c2 from t_subplan2 where c2>10)
group by b1 order by 1, 2 limit 5;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.b1, (count(*))
   ->  Vector Limit
         Output: t_subplan1.b1, (count(*))
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.b1, (count(*))
               Merge Sort Key: t_subplan1.b1, (count(*))
               ->  Vector Limit
                     Output: t_subplan1.b1, (count(*))
                     ->  Vector Sort
                           Output: t_subplan1.b1, (count(*))
                           Sort Key: t_subplan1.b1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 Output: t_subplan1.b1, (count(*))
                                 ->  Vector Sonic Hash Aggregate
                                       Output: t_subplan1.b1, count(*)
                                       Group By Key: t_subplan1.b1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                             Output: t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                             Distribute Key: t_subplan1.b1
                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                   Output: t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                                   Distribute Key: t_subplan1.a1, t_subplan1.b1
                                                   Filter: ((SubPlan 1) OR (SubPlan 2))
                                                   SubPlan 1
                                                     ->  Row Adapter
                                                           Output: nodegroup_subplan_test.t_subplan2.b2
                                                           ->  Vector Materialize
                                                                 Output: nodegroup_subplan_test.t_subplan2.b2
                                                                 ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                       Output: nodegroup_subplan_test.t_subplan2.b2
                                                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                             Output: nodegroup_subplan_test.t_subplan2.b2
                                                                             Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                                             Filter: (nodegroup_subplan_test.t_subplan2.b2 > 4)
                                                   SubPlan 2
                                                     ->  Row Adapter
                                                           Output: nodegroup_subplan_test.t_subplan2.c2
                                                           ->  Vector Materialize
                                                                 Output: nodegroup_subplan_test.t_subplan2.c2
                                                                 ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                       Output: nodegroup_subplan_test.t_subplan2.c2
                                                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                             Output: nodegroup_subplan_test.t_subplan2.c2
                                                                             Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                                             Filter: (nodegroup_subplan_test.t_subplan2.c2 > 10)
(46 rows)

select b1, count(*) from t_subplan1
where c1 = all (select b2 from t_subplan2 where b2>4)
or d1 != all (select c2 from t_subplan2 where c2>10)
group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
  0 |     5
  1 |     5
  2 |     5
  3 |     5
  4 |     5
(5 rows)

 
select b1, count(*) from t_subplan5
where c1 = all (select b2 from t_subplan6 where b2>4)
or d1 != all (select c2 from t_subplan6 where c2>10)
group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
  0 |     5
  1 |     5
  2 |     5
  3 |     5
  4 |     5
(5 rows)

explain (costs off, verbose on)
select b1, count(*) from t_subplan1
where c1 = any (select b2 from t_subplan2 where b2>4)
or d1 != any (select c2 from t_subplan2 where c2>10)
group by b1 order by 1, 2 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.c2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.b1, (count(*))
   ->  Vector Limit
         Output: t_subplan1.b1, (count(*))
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.b1, (count(*))
               Merge Sort Key: t_subplan1.b1, (count(*))
               ->  Vector Limit
                     Output: t_subplan1.b1, (count(*))
                     ->  Vector Sort
                           Output: t_subplan1.b1, (count(*))
                           Sort Key: t_subplan1.b1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 Output: t_subplan1.b1, (count(*))
                                 ->  Vector Limit
                                       Output: t_subplan1.b1, (count(*))
                                       ->  Vector Sort
                                             Output: t_subplan1.b1, (count(*))
                                             Sort Key: t_subplan1.b1, (count(*))
                                             ->  Vector Sonic Hash Aggregate
                                                   Output: t_subplan1.b1, count(*)
                                                   Group By Key: t_subplan1.b1
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1)
                                                         Output: t_subplan1.b1
                                                         Distribute Key: t_subplan1.b1
                                                         ->  Vector Hash Left Join
                                                               Output: t_subplan1.b1
                                                               Hash Cond: (t_subplan1.c1 = nodegroup_subplan_test.t_subplan2.b2)
                                                               Filter: ((nodegroup_subplan_test.t_subplan2.b2 IS NOT NULL) OR (SubPlan 1))
                                                               ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                                                     Output: t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                                                     Distribute Key: t_subplan1.c1
                                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                           Output: t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                                                           Distribute Key: t_subplan1.a1, t_subplan1.b1
                                                               ->  Vector Sonic Hash Aggregate
                                                                     Output: nodegroup_subplan_test.t_subplan2.b2
                                                                     Group By Key: nodegroup_subplan_test.t_subplan2.b2
                                                                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng1->group1)
                                                                           Output: nodegroup_subplan_test.t_subplan2.b2
                                                                           Distribute Key: nodegroup_subplan_test.t_subplan2.b2
                                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                 Output: nodegroup_subplan_test.t_subplan2.b2
                                                                                 Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                                                 Filter: (nodegroup_subplan_test.t_subplan2.b2 > 4)
                                                               SubPlan 1
                                                                 ->  Row Adapter
                                                                       Output: nodegroup_subplan_test.t_subplan2.c2
                                                                       ->  Vector Materialize
                                                                             Output: nodegroup_subplan_test.t_subplan2.c2
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                   Output: nodegroup_subplan_test.t_subplan2.c2
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                         Output: nodegroup_subplan_test.t_subplan2.c2
                                                                                         Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                                                         Filter: (nodegroup_subplan_test.t_subplan2.c2 > 10)
(56 rows)

select b1, count(*) from t_subplan1
where c1 = any (select b2 from t_subplan2 where b2>4)
or d1 != any (select c2 from t_subplan2 where c2>10)
group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
  0 |     5
  1 |     5
  2 |     5
  3 |     5
  4 |     5
(5 rows)

select b1, count(*) from t_subplan5
where c1 = any (select b2 from t_subplan6 where b2>4)
or d1 != any (select c2 from t_subplan6 where c2>10)
group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
  0 |     5
  1 |     5
  2 |     5
  3 |     5
  4 |     5
(5 rows)

select b1, count(*) from t_subplan5
where (c1 > 10 and c1 = any (select b2 from t_subplan6 where b2>4))
or d1 != any (select c2 from t_subplan6 where c2>10)
group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
  0 |     5
  1 |     5
  2 |     5
  3 |     5
  4 |     5
(5 rows)

explain (costs off, verbose on)
select * from t_subplan1 where (10,15)<=(select b1, min(b2) from t_subplan2 group by b1) order by a1, b1, c1, d1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (SubPlan 1)
                     SubPlan 1
                       ->  Row Adapter
                             Output: ($0), (min(t_subplan2.b2))
                             ->  Vector Sort Aggregate
                                   Output: (t_subplan1.b1), min(t_subplan2.b2)
                                   Group By Key: t_subplan1.b1
                                   ->  Vector Result
                                         Output: t_subplan1.b1, t_subplan2.b2
                                         ->  Vector Materialize
                                               Output: t_subplan2.b2
                                               ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                     Output: t_subplan2.b2
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                           Output: t_subplan2.b2
                                                           Distribute Key: t_subplan2.a2, t_subplan2.b2
(27 rows)

select * from t_subplan1 where (10,15)<=(select b1, min(b2) from t_subplan2 group by b1) order by a1, b1, c1, d1;
 a1 | b1 | c1 | d1 
----+----+----+----
  0 | 18 |  7 |  2
  1 | 19 |  8 |  3
 11 | 11 | 11 |  5
 12 | 12 | 12 |  0
 13 | 13 |  0 |  1
 14 | 14 |  1 |  2
 15 | 15 |  2 |  3
 16 | 16 |  3 |  4
 17 | 17 |  4 |  5
 18 | 18 |  5 |  0
 19 | 19 |  6 |  1
 31 | 11 |  5 |  1
 32 | 12 |  6 |  2
 33 | 13 |  7 |  3
 34 | 14 |  8 |  4
 35 | 15 |  9 |  5
 36 | 16 | 10 |  0
 37 | 17 | 11 |  1
 38 | 18 | 12 |  2
 39 | 19 |  0 |  3
 51 | 11 | 12 |  3
 52 | 12 |  0 |  4
 53 | 13 |  1 |  5
 54 | 14 |  2 |  0
 55 | 15 |  3 |  1
 56 | 16 |  4 |  2
 57 | 17 |  5 |  3
 58 | 18 |  6 |  4
 59 | 19 |  7 |  5
 71 | 11 |  6 |  5
 72 | 12 |  7 |  0
 73 | 13 |  8 |  1
 74 | 14 |  9 |  2
 75 | 15 | 10 |  3
 76 | 16 | 11 |  4
 77 | 17 | 12 |  5
 78 | 18 |  0 |  0
 79 | 19 |  1 |  1
 91 | 11 |  0 |  1
 92 | 12 |  1 |  2
 93 | 13 |  2 |  3
 94 | 14 |  3 |  4
 95 | 15 |  4 |  5
 96 | 16 |  5 |  0
 97 | 17 |  6 |  1
(45 rows)

select * from t_subplan5 where (10,15)<=(select b1, min(b2) from t_subplan6 group by b1) order by a1, b1, c1, d1;
 a1 | b1 | c1 | d1 
----+----+----+----
  0 | 18 |  7 |  2
  1 | 19 |  8 |  3
 11 | 11 | 11 |  5
 12 | 12 | 12 |  0
 13 | 13 |  0 |  1
 14 | 14 |  1 |  2
 15 | 15 |  2 |  3
 16 | 16 |  3 |  4
 17 | 17 |  4 |  5
 18 | 18 |  5 |  0
 19 | 19 |  6 |  1
 31 | 11 |  5 |  1
 32 | 12 |  6 |  2
 33 | 13 |  7 |  3
 34 | 14 |  8 |  4
 35 | 15 |  9 |  5
 36 | 16 | 10 |  0
 37 | 17 | 11 |  1
 38 | 18 | 12 |  2
 39 | 19 |  0 |  3
 51 | 11 | 12 |  3
 52 | 12 |  0 |  4
 53 | 13 |  1 |  5
 54 | 14 |  2 |  0
 55 | 15 |  3 |  1
 56 | 16 |  4 |  2
 57 | 17 |  5 |  3
 58 | 18 |  6 |  4
 59 | 19 |  7 |  5
 71 | 11 |  6 |  5
 72 | 12 |  7 |  0
 73 | 13 |  8 |  1
 74 | 14 |  9 |  2
 75 | 15 | 10 |  3
 76 | 16 | 11 |  4
 77 | 17 | 12 |  5
 78 | 18 |  0 |  0
 79 | 19 |  1 |  1
 91 | 11 |  0 |  1
 92 | 12 |  1 |  2
 93 | 13 |  2 |  3
 94 | 14 |  3 |  4
 95 | 15 |  4 |  5
 96 | 16 |  5 |  0
 97 | 17 |  6 |  1
(45 rows)

explain (costs off, verbose on)
select * from t_subplan1 where (b1,c1) < (select a2, b2 from t_subplan2 where b2=4 and a2=4) order by a1, b1, c1, d1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         InitPlan 1 (returns $0,$1)
           ->  Row Adapter
                 Output: t_subplan2.a2, t_subplan2.b2
                 ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                       Output: t_subplan2.a2, t_subplan2.b2
                       ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                             Output: t_subplan2.a2, t_subplan2.b2
                             Distribute Key: t_subplan2.a2, t_subplan2.b2
                             Filter: ((t_subplan2.b2 = 4) AND (t_subplan2.a2 = 4))
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (ROW(t_subplan1.b1, t_subplan1.c1) < ROW($0, $1))
(21 rows)

select * from t_subplan1 where (b1,c1) < (select a2, b2 from t_subplan2 where b2=4 and a2=4) order by a1, b1, c1, d1;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
  2 |  0 |  9 |  4
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
 20 |  0 |  7 |  2
 21 |  1 |  8 |  3
 22 |  2 |  9 |  4
 23 |  3 | 10 |  5
 40 |  0 |  1 |  4
 41 |  1 |  2 |  5
 42 |  2 |  3 |  0
 43 |  3 |  4 |  1
 60 |  0 |  8 |  0
 61 |  1 |  9 |  1
 62 |  2 | 10 |  2
 63 |  3 | 11 |  3
 80 |  0 |  2 |  2
 81 |  1 |  3 |  3
 82 |  2 |  4 |  4
 83 |  3 |  5 |  5
(20 rows)

select * from t_subplan5 where (b1,c1) < (select a2, b2 from t_subplan6 where b2=4 and a2=4) order by a1, b1, c1, d1;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
  2 |  0 |  9 |  4
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
 20 |  0 |  7 |  2
 21 |  1 |  8 |  3
 22 |  2 |  9 |  4
 23 |  3 | 10 |  5
 40 |  0 |  1 |  4
 41 |  1 |  2 |  5
 42 |  2 |  3 |  0
 43 |  3 |  4 |  1
 60 |  0 |  8 |  0
 61 |  1 |  9 |  1
 62 |  2 | 10 |  2
 63 |  3 | 11 |  3
 80 |  0 |  2 |  2
 81 |  1 |  3 |  3
 82 |  2 |  4 |  4
 83 |  3 |  5 |  5
(20 rows)

explain (costs off, verbose on)
select * from t_subplan1 where array(select max(b2) from t_subplan2 group by b1)=array(select min(b2) from t_subplan2 group by b1);
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Distribute Key: t_subplan1.a1, t_subplan1.b1
               Filter: ((SubPlan 1) = (SubPlan 2))
               SubPlan 1
                 ->  Row Adapter
                       Output: (max(nodegroup_subplan_test.t_subplan2.b2)), ($0)
                       ->  Vector Sort Aggregate
                             Output: max(nodegroup_subplan_test.t_subplan2.b2), (t_subplan1.b1)
                             Group By Key: t_subplan1.b1
                             ->  Vector Result
                                   Output: t_subplan1.b1, nodegroup_subplan_test.t_subplan2.b2
                                   ->  Vector Materialize
                                         Output: nodegroup_subplan_test.t_subplan2.b2
                                         ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                               Output: nodegroup_subplan_test.t_subplan2.b2
                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                     Output: nodegroup_subplan_test.t_subplan2.b2
                                                     Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
               SubPlan 2
                 ->  Row Adapter
                       Output: (min(nodegroup_subplan_test.t_subplan2.b2)), ($1)
                       ->  Vector Sort Aggregate
                             Output: min(nodegroup_subplan_test.t_subplan2.b2), (t_subplan1.b1)
                             Group By Key: t_subplan1.b1
                             ->  Vector Result
                                   Output: t_subplan1.b1, nodegroup_subplan_test.t_subplan2.b2
                                   ->  Vector Materialize
                                         Output: nodegroup_subplan_test.t_subplan2.b2
                                         ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                               Output: nodegroup_subplan_test.t_subplan2.b2
                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                     Output: nodegroup_subplan_test.t_subplan2.b2
                                                     Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(38 rows)

select * from t_subplan1 where array(select max(b2) from t_subplan2 group by b1)=array(select min(b2) from t_subplan2 group by b1);
 a1 | b1 | c1 | d1 
----+----+----+----
(0 rows)

explain (costs off, verbose on)
select array(select max(b2) from t_subplan2 group by b1) from t_subplan1 order by a1, b1, c1, d1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1)), t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: ((SubPlan 1)), t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: ((SubPlan 1)), t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: (SubPlan 1), t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     SubPlan 1
                       ->  Row Adapter
                             Output: (max(t_subplan2.b2)), ($0)
                             ->  Vector Sort Aggregate
                                   Output: max(t_subplan2.b2), (t_subplan1.b1)
                                   Group By Key: t_subplan1.b1
                                   ->  Vector Result
                                         Output: t_subplan1.b1, t_subplan2.b2
                                         ->  Vector Materialize
                                               Output: t_subplan2.b2
                                               ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                     Output: t_subplan2.b2
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                           Output: t_subplan2.b2
                                                           Distribute Key: t_subplan2.a2, t_subplan2.b2
(26 rows)

select array(select max(b2) from t_subplan2 group by b1) from t_subplan1 order by a1, b1, c1, d1;
 array 
-------
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
 {27}
(100 rows)

explain (costs off, verbose on)
select array(select a1 from t_subplan1 where t_subplan1.b1=t_subplan2.b2 order by 1) from t_subplan2 order by a2, b2, c2, d2;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
   ->  Vector Streaming (type: GATHER)
         Output: ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
         Merge Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
         ->  Vector Sort
               Output: ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               Sort Key: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
               ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                     Output: (SubPlan 1), t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.d2
                     Distribute Key: t_subplan2.a2, t_subplan2.b2
                     SubPlan 1
                       ->  Row Adapter
                             Output: t_subplan1.a1
                             ->  Vector Sort
                                   Output: t_subplan1.a1
                                   Sort Key: t_subplan1.a1
                                   ->  Vector Result
                                         Output: t_subplan1.a1
                                         Filter: (t_subplan1.b1 = t_subplan2.b2)
                                         ->  Vector Materialize
                                               Output: t_subplan1.a1, t_subplan1.b1
                                               ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                     Output: t_subplan1.a1, t_subplan1.b1
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                           Output: t_subplan1.a1, t_subplan1.b1
                                                           Distribute Key: t_subplan1.a1, t_subplan1.b1
(27 rows)

select array(select a1 from t_subplan1 where t_subplan1.b1=t_subplan2.b2 order by 1) from t_subplan2 order by a2, b2, c2, d2;
      array       
------------------
 {}
 {1,21,41,61,81}
 {}
 {2,22,42,62,82}
 {}
 {3,23,43,63,83}
 {4,24,44,64,84}
 {5,25,45,65,85}
 {6,26,46,66,86}
 {7,27,47,67,87}
 {8,28,48,68,88}
 {9,29,49,69,89}
 {10,30,50,70,90}
 {11,31,51,71,91}
 {12,32,52,72,92}
 {13,33,53,73,93}
 {14,34,54,74,94}
 {15,35,55,75,95}
 {16,36,56,76,96}
 {17,37,57,77,97}
 {0,18,38,58,78}
 {1,19,39,59,79}
 {}
 {}
 {}
 {}
 {}
 {}
 {}
 {}
 {2,20,40,60,80}
 {1,21,41,61,81}
 {2,22,42,62,82}
 {3,23,43,63,83}
 {4,24,44,64,84}
 {5,25,45,65,85}
 {6,26,46,66,86}
 {7,27,47,67,87}
 {8,28,48,68,88}
 {9,29,49,69,89}
 {10,30,50,70,90}
 {11,31,51,71,91}
 {12,32,52,72,92}
 {13,33,53,73,93}
 {14,34,54,74,94}
 {15,35,55,75,95}
 {16,36,56,76,96}
 {17,37,57,77,97}
 {0,18,38,58,78}
 {1,19,39,59,79}
(50 rows)

-- test cte sublink
explain (costs off, verbose on)
select (with cte(foo) as (select a1) select foo from cte) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1))
   ->  Vector Limit
         Output: ((SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 1))
               Merge Sort Key: ((SubPlan 1))
               ->  Vector Limit
                     Output: ((SubPlan 1))
                     ->  Vector Sort
                           Output: ((SubPlan 1))
                           Sort Key: ((SubPlan 1))
                           ->  Vector Limit
                                 Output: ((SubPlan 1))
                                 ->  Vector Sort
                                       Output: ((SubPlan 1))
                                       Sort Key: ((SubPlan 1))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 1)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Result
                                                     Output: t_subplan1.a1
(23 rows)

select (with cte(foo) as (select a1) select foo from cte) from t_subplan1 order by 1 limit 3;
 foo 
-----
   0
   1
   1
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (select a1 from dual) select foo from cte) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1))
   ->  Vector Limit
         Output: ((SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 1))
               Merge Sort Key: ((SubPlan 1))
               ->  Vector Limit
                     Output: ((SubPlan 1))
                     ->  Vector Sort
                           Output: ((SubPlan 1))
                           Sort Key: ((SubPlan 1))
                           ->  Vector Limit
                                 Output: ((SubPlan 1))
                                 ->  Vector Sort
                                       Output: ((SubPlan 1))
                                       Sort Key: ((SubPlan 1))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 1)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Subquery Scan on dual
                                                     Output: t_subplan1.a1
                                                     ->  Result
                                                           Output: 'X'::text
(25 rows)

select (with cte(foo) as (select a1 from dual) select foo from cte) from t_subplan1 order by 1 limit 3;
 foo 
-----
   0
   1
   1
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (values(b1)) values((select foo from cte))) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 2))
   ->  Vector Limit
         Output: ((SubPlan 2))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 2))
               Merge Sort Key: ((SubPlan 2))
               ->  Vector Limit
                     Output: ((SubPlan 2))
                     ->  Vector Sort
                           Output: ((SubPlan 2))
                           Sort Key: ((SubPlan 2))
                           ->  Vector Limit
                                 Output: ((SubPlan 2))
                                 ->  Vector Sort
                                       Output: ((SubPlan 2))
                                       Sort Key: ((SubPlan 2))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 2)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 2
                                               ->  Values Scan on "*VALUES*"
                                                     Output: "*VALUES*".column1
                                                     InitPlan 1 (returns $1)
                                                       ->  Values Scan on "*VALUES*"
                                                             Output: "*VALUES*".column1
(26 rows)

select (with cte(foo) as (values(b1)) values((select foo from cte))) from t_subplan1 order by 1 limit 3;
 column1 
---------
       0
       0
       0
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (select avg(a1) from t_subplan1) select foo from cte) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ($0)
   ->  Vector Limit
         Output: ($0)
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 Output: (pg_catalog.avg((avg(nodegroup_subplan_test.t_subplan1.a1))))
                 ->  Vector Aggregate
                       Output: pg_catalog.avg((avg(nodegroup_subplan_test.t_subplan1.a1)))
                       ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                             Output: (avg(nodegroup_subplan_test.t_subplan1.a1))
                             ->  Vector Aggregate
                                   Output: avg(nodegroup_subplan_test.t_subplan1.a1)
                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                         Output: nodegroup_subplan_test.t_subplan1.a1
                                         Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
         ->  Vector Streaming (type: GATHER)
               Output: ($0)
               ->  Vector Limit
                     Output: ($0)
                     ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                           Output: $0
                           Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
(23 rows)

select (with cte(foo) as (select avg(a1) from t_subplan1) select foo from cte) from t_subplan1 order by 1 limit 3;
         foo         
---------------------
 47.5600000000000000
 47.5600000000000000
 47.5600000000000000
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) select foo from cte) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1))
   ->  Vector Limit
         Output: ((SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 1))
               Merge Sort Key: ((SubPlan 1))
               ->  Vector Limit
                     Output: ((SubPlan 1))
                     ->  Vector Sort
                           Output: ((SubPlan 1))
                           Sort Key: ((SubPlan 1))
                           ->  Vector Limit
                                 Output: ((SubPlan 1))
                                 ->  Vector Sort
                                       Output: ((SubPlan 1))
                                       Sort Key: ((SubPlan 1))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 1)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: ($0)
                                                     ->  Vector Limit
                                                           Output: (t_subplan1.b1)
                                                           ->  Vector Sort
                                                                 Output: (t_subplan1.b1)
                                                                 Sort Key: (t_subplan1.b1)
                                                                 ->  Vector Result
                                                                       Output: t_subplan1.b1
                                                                       ->  Vector Materialize
                                                                             Output: ('Dummy')
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                   Output: ('Dummy')
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                         Output: 'Dummy'
                                                                                         Distribute Key: t_subplan2.a2, t_subplan2.b2
(37 rows)

select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) select foo from cte) from t_subplan1 order by 1 limit 3;
 foo 
-----
   0
   0
   0
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) select foo+t_subplan1.c1 from cte) from t_subplan1 order by 1 limit 3; 
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1))
   ->  Vector Limit
         Output: ((SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 1))
               Merge Sort Key: ((SubPlan 1))
               ->  Vector Limit
                     Output: ((SubPlan 1))
                     ->  Vector Sort
                           Output: ((SubPlan 1))
                           Sort Key: ((SubPlan 1))
                           ->  Vector Limit
                                 Output: ((SubPlan 1))
                                 ->  Vector Sort
                                       Output: ((SubPlan 1))
                                       Sort Key: ((SubPlan 1))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 1)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: ((cte.foo + $0))
                                                     ->  Vector Subquery Scan on cte
                                                           Output: (cte.foo + t_subplan1.c1)
                                                           ->  Vector Limit
                                                                 Output: (t_subplan1.b1)
                                                                 ->  Vector Sort
                                                                       Output: (t_subplan1.b1)
                                                                       Sort Key: (t_subplan1.b1)
                                                                       ->  Vector Result
                                                                             Output: t_subplan1.b1
                                                                             ->  Vector Materialize
                                                                                   Output: ('Dummy')
                                                                                   ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                         Output: ('Dummy')
                                                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                               Output: 'Dummy'
                                                                                               Distribute Key: t_subplan2.a2, t_subplan2.b2
(39 rows)

select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) select foo+t_subplan1.c1 from cte) from t_subplan1 order by 1 limit 3; 
 ?column? 
----------
        1
        2
        2
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) values((select foo from cte))) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                   QUERY PLAN                                                                   
------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 2))
   ->  Vector Limit
         Output: ((SubPlan 2))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 2))
               Merge Sort Key: ((SubPlan 2))
               ->  Vector Limit
                     Output: ((SubPlan 2))
                     ->  Vector Sort
                           Output: ((SubPlan 2))
                           Sort Key: ((SubPlan 2))
                           ->  Vector Limit
                                 Output: ((SubPlan 2))
                                 ->  Vector Sort
                                       Output: ((SubPlan 2))
                                       Sort Key: ((SubPlan 2))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 2)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 2
                                               ->  Values Scan on "*VALUES*"
                                                     Output: "*VALUES*".column1
                                                     InitPlan 1 (returns $1)
                                                       ->  Row Adapter
                                                             Output: (t_subplan1.b1)
                                                             ->  Vector Limit
                                                                   Output: (t_subplan1.b1)
                                                                   ->  Vector Sort
                                                                         Output: (t_subplan1.b1)
                                                                         Sort Key: (t_subplan1.b1)
                                                                         ->  Vector Result
                                                                               Output: t_subplan1.b1
                                                                               ->  Vector Materialize
                                                                                     Output: ('Dummy')
                                                                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                           Output: ('Dummy')
                                                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                                 Output: 'Dummy'
                                                                                                 Distribute Key: t_subplan2.a2, t_subplan2.b2
(40 rows)

select (with cte(foo) as (select t_subplan1.b1 from t_subplan2 limit 1) values((select foo from cte))) from t_subplan1 order by 1 limit 3;
 column1 
---------
       0
       0
       0
(3 rows)

explain (costs off, verbose on)
select (with cte(foo) as (values(b1)) select foo from cte) from t_subplan1 order by 1 limit 3;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 1))
   ->  Vector Limit
         Output: ((SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 1))
               Merge Sort Key: ((SubPlan 1))
               ->  Vector Limit
                     Output: ((SubPlan 1))
                     ->  Vector Sort
                           Output: ((SubPlan 1))
                           Sort Key: ((SubPlan 1))
                           ->  Vector Limit
                                 Output: ((SubPlan 1))
                                 ->  Vector Sort
                                       Output: ((SubPlan 1))
                                       Sort Key: ((SubPlan 1))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 1)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Values Scan on "*VALUES*"
                                                     Output: "*VALUES*".column1
(23 rows)

select (with cte(foo) as (values(b1)) select foo from cte) from t_subplan1 order by 1 limit 3;
 foo 
-----
   0
   0
   0
(3 rows)

explain (costs off, verbose on)
select (select b1 from (values((select b1 from t_subplan2 limit 1), (select a1 from t_subplan2 limit 1))) as t(c,d)) from t_subplan1 order by 1 limit 3; 
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: ((SubPlan 3))
   ->  Vector Limit
         Output: ((SubPlan 3))
         ->  Vector Streaming (type: GATHER)
               Output: ((SubPlan 3))
               Merge Sort Key: ((SubPlan 3))
               ->  Vector Limit
                     Output: ((SubPlan 3))
                     ->  Vector Sort
                           Output: ((SubPlan 3))
                           Sort Key: ((SubPlan 3))
                           ->  Vector Limit
                                 Output: ((SubPlan 3))
                                 ->  Vector Sort
                                       Output: ((SubPlan 3))
                                       Sort Key: ((SubPlan 3))
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: (SubPlan 3)
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 3
                                               ->  Values Scan on "*VALUES*"
                                                     Output: t_subplan1.b1
                                                     InitPlan 1 (returns $1)
                                                       ->  Row Adapter
                                                             Output: (t_subplan1.b1)
                                                             ->  Vector Limit
                                                                   Output: (t_subplan1.b1)
                                                                   ->  Vector Sort
                                                                         Output: (t_subplan1.b1)
                                                                         Sort Key: (t_subplan1.b1)
                                                                         ->  Vector Result
                                                                               Output: t_subplan1.b1
                                                                               ->  Vector Materialize
                                                                                     Output: ('Dummy')
                                                                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                           Output: ('Dummy')
                                                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                                 Output: 'Dummy'
                                                                                                 Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                                     InitPlan 2 (returns $3)
                                                       ->  Row Adapter
                                                             Output: (t_subplan1.a1)
                                                             ->  Vector Limit
                                                                   Output: (t_subplan1.a1)
                                                                   ->  Vector Sort
                                                                         Output: (t_subplan1.a1)
                                                                         Sort Key: (t_subplan1.a1)
                                                                         ->  Vector Result
                                                                               Output: t_subplan1.a1
                                                                               ->  Vector Materialize
                                                                                     Output: ('Dummy')
                                                                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                           Output: ('Dummy')
                                                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                                 Output: 'Dummy'
                                                                                                 Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(57 rows)

select (select b1 from (values((select b1 from t_subplan2 limit 1), (select a1 from t_subplan2 limit 1))) as t(c,d)) from t_subplan1 order by 1 limit 3; 
 b1 
----
  0
  0
  0
(3 rows)

-- test cte sublink applied in different subquery level
explain (costs off, verbose on)
select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', count(d2) from tmp))
 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (t_subplan1.c1 = (SubPlan 1))
                     SubPlan 1
                       ->  Row Adapter
                             Output: (count(*))
                             ->  Vector Aggregate
                                   Output: count(*)
                                   ->  Vector Aggregate
                                         Output: 'abc'::text, count(t_subplan2.d2)
                                         ->  Vector Result
                                               Output: t_subplan2.d2, t_subplan2.b2
                                               Filter: (t_subplan2.b2 = t_subplan1.a1)
                                               ->  Vector Materialize
                                                     Output: t_subplan2.d2, t_subplan2.b2
                                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                           Output: t_subplan2.d2, t_subplan2.b2
                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                 Output: t_subplan2.d2, t_subplan2.b2
                                                                 Distribute Key: t_subplan2.a2, t_subplan2.b2
(29 rows)

select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', count(d2) from tmp))
 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
 14 | 14 |  1 |  2
 27 |  7 |  1 |  3
 40 |  0 |  1 |  4
 53 | 13 |  1 |  5
 66 |  6 |  1 |  0
 79 | 19 |  1 |  1
 92 | 12 |  1 |  2
(8 rows)

explain (costs off, verbose on)
select * from t_subplan1 where a1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', d2 from tmp))
 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (t_subplan1.a1 = (SubPlan 1))
                     SubPlan 1
                       ->  Row Adapter
                             Output: (count(*))
                             ->  Vector Aggregate
                                   Output: count(*)
                                   ->  Vector Result
                                         Output: t_subplan2.b2
                                         Filter: (t_subplan2.b2 = t_subplan1.a1)
                                         ->  Vector Materialize
                                               Output: t_subplan2.b2
                                               ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                     Output: t_subplan2.b2
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                           Output: t_subplan2.b2
                                                           Distribute Key: t_subplan2.a2, t_subplan2.b2
(27 rows)

select * from t_subplan1 where a1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', d2 from tmp))
 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  2 |  0 |  9 |  4
  2 |  2 |  2 |  2
(2 rows)

explain (costs off, verbose on)
select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', count(d2) from tmp tmp1
 where d2>(select count(*) from tmp tmp2 where tmp2.d2=tmp1.d2)))
 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                      QUERY PLAN                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (t_subplan1.c1 = (SubPlan 2))
                     SubPlan 2
                       ->  Row Adapter
                             Output: (count(*))
                             ->  Vector Aggregate
                                   Output: count(*)
                                   ->  Vector Aggregate
                                         Output: 'abc'::text, count(nodegroup_subplan_test.t_subplan2.d2)
                                         ->  Vector Result
                                               Output: nodegroup_subplan_test.t_subplan2.d2, nodegroup_subplan_test.t_subplan2.b2
                                               Filter: ((nodegroup_subplan_test.t_subplan2.b2 = t_subplan1.a1) AND (nodegroup_subplan_test.t_subplan2.d2 > (SubPlan 1)))
                                               ->  Vector Materialize
                                                     Output: nodegroup_subplan_test.t_subplan2.d2, nodegroup_subplan_test.t_subplan2.b2
                                                     ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                           Output: nodegroup_subplan_test.t_subplan2.d2, nodegroup_subplan_test.t_subplan2.b2
                                                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                 Output: nodegroup_subplan_test.t_subplan2.d2, nodegroup_subplan_test.t_subplan2.b2
                                                                 Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                               SubPlan 1
                                                 ->  Row Adapter
                                                       Output: (count(*))
                                                       ->  Vector Aggregate
                                                             Output: count(*)
                                                             ->  Vector Result
                                                                   Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                   Filter: ((nodegroup_subplan_test.t_subplan2.b2 = t_subplan1.a1) AND (nodegroup_subplan_test.t_subplan2.d2 = nodegroup_subplan_test.t_subplan2.d2))
                                                                   ->  Vector Materialize
                                                                         Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                         ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                               Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                     Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                                     Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(44 rows)

select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', count(d2) from tmp tmp1
 where d2>(select count(*) from tmp tmp2 where tmp2.d2=tmp1.d2)))
 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
 14 | 14 |  1 |  2
 27 |  7 |  1 |  3
 40 |  0 |  1 |  4
 53 | 13 |  1 |  5
 66 |  6 |  1 |  0
 79 | 19 |  1 |  1
 92 | 12 |  1 |  2
(8 rows)

explain (costs off, verbose on)
select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', d2 from tmp tmp1
 where d2>(select count(*) from tmp tmp2 where tmp2.d2=tmp1.d2)))
 order by 1,2,3,4;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Sort
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     Distribute Key: t_subplan1.a1, t_subplan1.b1
                     Filter: (t_subplan1.c1 = (SubPlan 2))
                     SubPlan 2
                       ->  Row Adapter
                             Output: (count(*))
                             ->  Vector Aggregate
                                   Output: count(*)
                                   ->  Vector Result
                                         Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                         Filter: ((nodegroup_subplan_test.t_subplan2.b2 = t_subplan1.a1) AND (nodegroup_subplan_test.t_subplan2.d2 > (SubPlan 1)))
                                         ->  Vector Materialize
                                               Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                               ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                     Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                     ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                           Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                           Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
                                         SubPlan 1
                                           ->  Row Adapter
                                                 Output: (count(*))
                                                 ->  Vector Aggregate
                                                       Output: count(*)
                                                       ->  Vector Result
                                                             Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                             Filter: ((nodegroup_subplan_test.t_subplan2.b2 = t_subplan1.a1) AND (nodegroup_subplan_test.t_subplan2.d2 = nodegroup_subplan_test.t_subplan2.d2))
                                                             ->  Vector Materialize
                                                                   Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                   ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                         Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                               Output: nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan2.d2
                                                                               Distribute Key: nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2
(42 rows)

select * from t_subplan1 where c1 = (with tmp as (select d2 from t_subplan2 where b2=a1)
 select count(*) from (select 'abc', d2 from tmp tmp1
 where d2>(select count(*) from tmp tmp2 where tmp2.d2=tmp1.d2)))
 order by 1,2,3,4;
 a1 | b1 | c1 | d1 
----+----+----+----
  1 |  1 |  1 |  1
  2 |  2 |  2 |  2
 15 | 15 |  2 |  3
 39 | 19 |  0 |  3
 52 | 12 |  0 |  4
 65 |  5 |  0 |  5
 78 | 18 |  0 |  0
 91 | 11 |  0 |  1
(8 rows)

explain (costs off, verbose on)
select * from t_subplan1 left join
(select a2, b2, (select b1 from t_subplan1 limit 1) c2 from t_subplan2)
on b2=b1 and a1 not in (null)
inner join t_subplan1 t3 on t3.a1=t_subplan1.c1 where t3.a1=0 order by 1,2,3,4 limit 5;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                                                           QUERY PLAN                                                                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
   ->  Vector Limit
         Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
         InitPlan 1 (returns $0)
           ->  Row Adapter
                 Output: nodegroup_subplan_test.t_subplan1.b1
                 ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                       Output: nodegroup_subplan_test.t_subplan1.b1
                       ->  Vector Limit
                             Output: nodegroup_subplan_test.t_subplan1.b1
                             ->  Vector Streaming(type: BROADCAST)
                                   Output: nodegroup_subplan_test.t_subplan1.b1
                                   ->  Vector Limit
                                         Output: nodegroup_subplan_test.t_subplan1.b1
                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                               Output: nodegroup_subplan_test.t_subplan1.b1
                                               Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
         ->  Vector Streaming (type: GATHER)
               Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
               Merge Sort Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.d1
               ->  Vector Limit
                     Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
                     ->  Vector Sort
                           Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
                           Sort Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.d1
                           ->  Vector Nest Loop
                                 Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0), t3.a1, t3.b1, t3.c1, t3.d1
                                 ->  Vector Streaming(type: BROADCAST dop: 1/2)
                                       Output: t3.a1, t3.b1, t3.c1, t3.d1
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1 t3
                                             Output: t3.a1, t3.b1, t3.c1, t3.d1
                                             Distribute Key: t3.a1, t3.b1
                                             Filter: (t3.a1 = 0)
                                 ->  Vector Materialize
                                       Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0)
                                       ->  Vector Streaming(type: REDISTRIBUTE ng: group1->ng0)
                                             Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0)
                                             Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                             ->  Vector Nest Loop Left Join
                                                   Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1, t_subplan2.a2, t_subplan2.b2, ($0)
                                                   Join Filter: false
                                                   ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                                         Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                         Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                               Output: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan1.c1, nodegroup_subplan_test.t_subplan1.d1
                                                               Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                               Filter: (nodegroup_subplan_test.t_subplan1.c1 = 0)
                                                   ->  Vector Adapter
                                                         Output: t_subplan2.a2, t_subplan2.b2, ($0)
                                                         ->  Result
                                                               Output: t_subplan2.a2, t_subplan2.b2, $0
                                                               One-Time Filter: false
(54 rows)

select * from t_subplan1 left join
(select a2, b2, (select b1 from t_subplan1 limit 1) c2 from t_subplan2)
on b2=b1 and a1 not in (null)
inner join t_subplan1 t3 on t3.a1=t_subplan1.c1 where t3.a1=0 order by 1,2,3,4 limit 5;
 a1 | b1 | c1 | d1 | a2 | b2 | c2 | a1 | b1 | c1 | d1 
----+----+----+----+----+----+----+----+----+----+----
 13 | 13 |  0 |  1 |    |    |    |  0 | 18 |  7 |  2
 26 |  6 |  0 |  2 |    |    |    |  0 | 18 |  7 |  2
 39 | 19 |  0 |  3 |    |    |    |  0 | 18 |  7 |  2
 52 | 12 |  0 |  4 |    |    |    |  0 | 18 |  7 |  2
 65 |  5 |  0 |  5 |    |    |    |  0 | 18 |  7 |  2
(5 rows)

explain (costs off, verbose on)
select count(*) from t_subplan2 group by a2,b2 order by (a2,b2) > some(select min(a1), length(trim(b2)) from t_subplan1), 1;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1, nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2
   ->  Vector Streaming (type: GATHER)
         Output: (count(*)), ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2
         Merge Sort Key: ((SubPlan 1)), (count(*))
         ->  Vector Sort
               Output: (count(*)), ((SubPlan 1)), t_subplan2.a2, t_subplan2.b2
               Sort Key: ((SubPlan 1)), (count(*))
               ->  Vector Hash Aggregate
                     Output: count(*), (SubPlan 1), t_subplan2.a2, t_subplan2.b2
                     Group By Key: t_subplan2.a2, t_subplan2.b2
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng1->group1)
                           Output: t_subplan2.a2, t_subplan2.b2
                           Distribute Key: t_subplan2.a2, t_subplan2.b2
                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                 Output: t_subplan2.a2, t_subplan2.b2
                                 Distribute Key: t_subplan2.a2, t_subplan2.b2
                     SubPlan 1
                       ->  Row Adapter
                             Output: (min(t_subplan1.a1)), (length(btrim(($0)::text)))
                             ->  Vector Aggregate
                                   Output: min(t_subplan1.a1), length(btrim((t_subplan2.b2)::text))
                                   ->  Vector Materialize
                                         Output: t_subplan1.a1
                                         ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                               Output: t_subplan1.a1
                                               ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                     Output: t_subplan1.a1
                                                     Distribute Key: t_subplan1.a1, t_subplan1.b1
(29 rows)

select count(*) from t_subplan2 group by a2,b2 order by (a2,b2) > some(select min(a1), length(trim(b2)) from t_subplan1), 1 limit 10;
 count 
-------
     1
     1
     1
     1
     1
     1
     1
     1
     1
     1
(10 rows)

-- update
explain (costs off, verbose on)
update t_subplan2 set d2 = t1.b from (select max(a1) b from t_subplan1 group by c1 not in (select a1*0-1 from t_subplan1)) t1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                     QUERY PLAN                                                                                     
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   ->  Vector Streaming (type: GATHER)
         ->  Vector Update on nodegroup_subplan_test.t_subplan2
               ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                     Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t1.b, t_subplan2.ctid, t_subplan2.tableoid, t_subplan2.xc_node_id, t1.b
                     ->  Vector Nest Loop
                           Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t1.b, t_subplan2.ctid, t_subplan2.tableoid, t_subplan2.xc_node_id, t1.b
                           ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                 Output: t_subplan2.a2, t_subplan2.b2, t_subplan2.c2, t_subplan2.ctid, t_subplan2.tableoid, t_subplan2.xc_node_id
                                 Distribute Key: t_subplan2.a2, t_subplan2.b2
                           ->  Vector Materialize
                                 Output: t1.b
                                 ->  Vector Streaming(type: SPLIT BROADCAST dop: 2/2 ng: group1->ng1)
                                       Output: t1.b
                                       ->  Vector Subquery Scan on t1
                                             Output: t1.b
                                             ->  Vector Hash Aggregate
                                                   Output: max(nodegroup_subplan_test.t_subplan1.a1), ((NOT (hashed SubPlan 1)))
                                                   Group By Key: ((NOT (hashed SubPlan 1)))
                                                   ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                                         Output: ((NOT (hashed SubPlan 1))), nodegroup_subplan_test.t_subplan1.a1
                                                         Distribute Key: ((NOT (hashed SubPlan 1)))
                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                               Output: (NOT (hashed SubPlan 1)), nodegroup_subplan_test.t_subplan1.a1
                                                               Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
                                                               SubPlan 1
                                                                 ->  Row Adapter
                                                                       Output: (((nodegroup_subplan_test.t_subplan1.a1 * 0) - 1))
                                                                       ->  Vector Materialize
                                                                             Output: (((nodegroup_subplan_test.t_subplan1.a1 * 0) - 1))
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                                                                   Output: (((nodegroup_subplan_test.t_subplan1.a1 * 0) - 1))
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                                                         Output: ((nodegroup_subplan_test.t_subplan1.a1 * 0) - 1)
                                                                                         Distribute Key: nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1
(35 rows)

update t_subplan2 set d2 = t1.b from (select max(a1) b from t_subplan1 group by c1 not in (select a1*0-1 from t_subplan1)) t1;
explain (costs off, verbose on) 
select count(*) from t_subplan1 group by a1 having(avg(b1) = some (select b2 from t_subplan2)) order by 1 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), t_subplan1.a1
   ->  Vector Limit
         Output: (count(*)), t_subplan1.a1
         ->  Vector Streaming (type: GATHER)
               Output: (count(*)), t_subplan1.a1
               Merge Sort Key: (count(*))
               ->  Vector Limit
                     Output: (count(*)), t_subplan1.a1
                     ->  Vector Sort
                           Output: (count(*)), t_subplan1.a1
                           Sort Key: (count(*))
                           ->  Vector Limit
                                 Output: (count(*)), t_subplan1.a1
                                 ->  Vector Sort
                                       Output: (count(*)), t_subplan1.a1
                                       Sort Key: (count(*))
                                       ->  Vector Sonic Hash Aggregate
                                             Output: count(*), t_subplan1.a1
                                             Group By Key: t_subplan1.a1
                                             Filter: (hashed SubPlan 1)
                                             ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                                   Output: t_subplan1.a1, t_subplan1.b1
                                                   Distribute Key: t_subplan1.a1
                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                         Output: t_subplan1.a1, t_subplan1.b1
                                                         Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.b2
                                                     ->  Vector Materialize
                                                           Output: t_subplan2.b2
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: t_subplan2.b2
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: t_subplan2.b2
                                                                       Distribute Key: t_subplan2.a2, t_subplan2.b2
(37 rows)

select count(*) from t_subplan1 group by a1 having(avg(b1) = some (select b2 from t_subplan2)) order by 1 limit 5;
 count 
-------
     1
     1
     1
     1
     1
(5 rows)

explain (costs off, verbose on) 
select max(a1), b1 = some (select b2 from t_subplan2) from t_subplan1 group by b1 order by 1,2 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
   ->  Vector Limit
         Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
         ->  Vector Streaming (type: GATHER)
               Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
               Merge Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
               ->  Vector Limit
                     Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                     ->  Vector Sort
                           Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                           Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
                           ->  Vector Limit
                                 Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                                 ->  Vector Sort
                                       Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                                       Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
                                       ->  Vector Hash Aggregate
                                             Output: max(t_subplan1.a1), (hashed SubPlan 1), t_subplan1.b1
                                             Group By Key: t_subplan1.b1
                                             ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                                   Output: t_subplan1.b1, t_subplan1.a1
                                                   Distribute Key: t_subplan1.b1
                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                         Output: t_subplan1.b1, t_subplan1.a1
                                                         Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.b2
                                                     ->  Vector Materialize
                                                           Output: t_subplan2.b2
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: t_subplan2.b2
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: t_subplan2.b2
                                                                       Distribute Key: t_subplan2.a2, t_subplan2.b2
(36 rows)

select max(a1), b1 = some (select b2 from t_subplan2) from t_subplan1 group by b1 order by 1,2 limit 5;
 max | ?column? 
-----+----------
  78 | t
  79 | t
  80 | t
  81 | t
  82 | t
(5 rows)

explain (costs off, verbose on) 
select max(a1), min(b1) = some (select b2 from t_subplan2) from t_subplan1 group by b1 order by 1,2 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
   ->  Vector Limit
         Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
         ->  Vector Streaming (type: GATHER)
               Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
               Merge Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
               ->  Vector Limit
                     Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                     ->  Vector Sort
                           Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                           Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
                           ->  Vector Limit
                                 Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                                 ->  Vector Sort
                                       Output: (max(t_subplan1.a1)), ((hashed SubPlan 1)), t_subplan1.b1
                                       Sort Key: (max(t_subplan1.a1)), ((hashed SubPlan 1))
                                       ->  Vector Hash Aggregate
                                             Output: max(t_subplan1.a1), (hashed SubPlan 1), t_subplan1.b1
                                             Group By Key: t_subplan1.b1
                                             ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                                                   Output: t_subplan1.b1, t_subplan1.a1
                                                   Distribute Key: t_subplan1.b1
                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                         Output: t_subplan1.b1, t_subplan1.a1
                                                         Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.b2
                                                     ->  Vector Materialize
                                                           Output: t_subplan2.b2
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: t_subplan2.b2
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: t_subplan2.b2
                                                                       Distribute Key: t_subplan2.a2, t_subplan2.b2
(36 rows)

select max(a1), min(b1) = some (select b2 from t_subplan2) from t_subplan1 group by b1 order by 1,2 limit 5;
 max | ?column? 
-----+----------
  78 | t
  79 | t
  80 | t
  81 | t
  82 | t
(5 rows)

explain (costs off, verbose on) 
select a1, b1 from t_subplan1 group by a1, b1 having(grouping(b1)) = some (select b2 from t_subplan2) order by 1,2 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1
   ->  Vector Limit
         Output: t_subplan1.a1, t_subplan1.b1
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.a1, t_subplan1.b1
               Merge Sort Key: t_subplan1.a1, t_subplan1.b1
               ->  Vector Limit
                     Output: t_subplan1.a1, t_subplan1.b1
                     ->  Vector Sort
                           Output: t_subplan1.a1, t_subplan1.b1
                           Sort Key: t_subplan1.a1, t_subplan1.b1
                           ->  Vector Limit
                                 Output: t_subplan1.a1, t_subplan1.b1
                                 ->  Vector Sort
                                       Output: t_subplan1.a1, t_subplan1.b1
                                       Sort Key: t_subplan1.a1, t_subplan1.b1
                                       ->  Vector Sort Aggregate
                                             Output: t_subplan1.a1, t_subplan1.b1
                                             Group By Key: t_subplan1.a1, t_subplan1.b1
                                             Filter: (hashed SubPlan 1)
                                             ->  Vector Sort
                                                   Output: t_subplan1.a1, t_subplan1.b1
                                                   Sort Key: t_subplan1.a1, t_subplan1.b1
                                                   ->  Vector Streaming(type: LOCAL REDISTRIBUTE dop: 1/2)
                                                         Output: t_subplan1.a1, t_subplan1.b1
                                                         Distribute Key: t_subplan1.a1, t_subplan1.b1
                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                               Output: t_subplan1.a1, t_subplan1.b1
                                                               Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.b2
                                                     ->  Vector Materialize
                                                           Output: t_subplan2.b2
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: t_subplan2.b2
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: t_subplan2.b2
                                                                       Distribute Key: t_subplan2.a2, t_subplan2.b2
(40 rows)

select a1, b1 from t_subplan1 group by a1, b1 having(grouping(b1)) = some (select b2 from t_subplan2) order by 1,2 limit 5;
 a1 | b1 
----+----
  0 | 18
  1 |  1
  1 | 19
  2 |  0
  2 |  2
(5 rows)

explain (costs off, verbose on) 
select a1, rank() over(partition by a1)  = some (select a2  from t_subplan2) from t_subplan1 order by 1,2 limit 5;
WARNING:  Statistics in some tables or columns(nodegroup_subplan_test.t_subplan2.a2, nodegroup_subplan_test.t_subplan2.b2, nodegroup_subplan_test.t_subplan1.a1, nodegroup_subplan_test.t_subplan1.b1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, ((hashed SubPlan 1))
   ->  Vector Limit
         Output: t_subplan1.a1, ((hashed SubPlan 1))
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.a1, ((hashed SubPlan 1))
               Merge Sort Key: t_subplan1.a1, ((hashed SubPlan 1))
               ->  Vector Limit
                     Output: t_subplan1.a1, ((hashed SubPlan 1))
                     ->  Vector Sort
                           Output: t_subplan1.a1, ((hashed SubPlan 1))
                           Sort Key: t_subplan1.a1, ((hashed SubPlan 1))
                           ->  Vector Limit
                                 Output: t_subplan1.a1, ((hashed SubPlan 1))
                                 ->  Vector Sort
                                       Output: t_subplan1.a1, ((hashed SubPlan 1))
                                       Sort Key: t_subplan1.a1, ((hashed SubPlan 1))
                                       ->  Vector WindowAgg
                                             Output: t_subplan1.a1, (hashed SubPlan 1)
                                             ->  Vector Sort
                                                   Output: t_subplan1.a1
                                                   Sort Key: t_subplan1.a1
                                                   ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2)
                                                         Output: t_subplan1.a1
                                                         Distribute Key: t_subplan1.a1
                                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                               Output: t_subplan1.a1
                                                               Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.a2
                                                     ->  Vector Materialize
                                                           Output: t_subplan2.a2
                                                           ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                 Output: t_subplan2.a2
                                                                 ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                       Output: t_subplan2.a2
                                                                       Distribute Key: t_subplan2.a2, t_subplan2.b2
(38 rows)

select a1, rank() over(partition by a1)  = some (select a2  from t_subplan2) from t_subplan1 order by 1,2 limit 5;
 a1 | ?column? 
----+----------
  0 | t
  1 | t
  1 | t
  2 | t
  2 | t
(5 rows)

explain (costs off, verbose on) 
select * from t_subplan7 t1 where a1 in (select t1.a1 - 1 from t_subplan1);
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Row Adapter
   Output: t1.a1, t1.b1, t1.c1, t1.d1
   ->  Vector Streaming (type: GATHER)
         Output: t1.a1, t1.b1, t1.c1, t1.d1
         ->  CStore Scan on nodegroup_subplan_test.t_subplan7 t1
               Output: t1.a1, t1.b1, t1.c1, t1.d1
               Distribute Key: t1.a1, t1.b1
               Filter: (SubPlan 1)
               SubPlan 1
                 ->  Row Adapter
                       Output: (($0 - 1))
                       ->  Vector Result
                             Output: (t1.a1 - 1)
                             ->  Vector Materialize
                                   Output: ('Dummy')
                                   ->  Vector Streaming(type: BROADCAST ng: ng0->GenGroup)
                                         Output: ('Dummy')
                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                               Output: 'Dummy'
                                               Distribute Key: t_subplan1.a1, t_subplan1.b1
(20 rows)

select * from t_subplan7 t1 where a1 in (select t1.a1 - 1 from t_subplan1);
 a1 | b1 | c1 | d1 
----+----+----+----
(0 rows)

set work_mem = '1MB';
set enable_nestloop = off;
set enable_hashjoin = off;
explain (costs off, verbose on) 
select * from t_subplan1 where c1 > any(select c2 from t_subplan2 join t_subplan3 on a3 = a2 where b2 < b1) order by 1,2,3,4 limit 10;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                     QUERY PLAN                                                                     
----------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Limit
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  Vector Limit
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     ->  Vector Sort
                           Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           ->  Vector Limit
                                 Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                 ->  Vector Sort
                                       Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             Filter: (SubPlan 1)
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.c2
                                                     ->  Vector Merge Join
                                                           Output: t_subplan2.c2
                                                           Merge Cond: (t_subplan2.a2 = t_subplan3.a3)
                                                           ->  Vector Sort
                                                                 Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                 Sort Key: t_subplan2.a2
                                                                 ->  Vector Result
                                                                       Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                       Filter: (t_subplan2.b2 < t_subplan1.b1)
                                                                       ->  Vector Materialize
                                                                             Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                             ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                                   Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                         Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                                         Distribute Key: t_subplan2.a2, t_subplan2.b2
                                                           ->  Vector Sort
                                                                 Output: t_subplan3.a3
                                                                 Sort Key: t_subplan3.a3
                                                                 ->  Vector Materialize
                                                                       Output: t_subplan3.a3
                                                                       ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                                                             Output: t_subplan3.a3
                                                                             ->  Vector Partition Iterator
                                                                                   Output: t_subplan3.a3
                                                                                   Iterations: 2
                                                                                   ->  Partitioned CStore Scan on nodegroup_subplan_test.t_subplan3
                                                                                         Output: t_subplan3.a3
                                                                                         Selected Partitions:  1..2
(53 rows)

select * from t_subplan1 where c1 > any(select c2 from t_subplan2 join t_subplan3 on a3 = a2 where b2 < b1) order by 1,2,3,4 limit 10;
 a1 | b1 | c1 | d1 
----+----+----+----
  0 | 18 |  7 |  2
  1 | 19 |  8 |  3
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
  6 |  6 |  6 |  0
  7 |  7 |  7 |  1
  8 |  8 |  8 |  2
  9 |  9 |  9 |  3
(10 rows)

set enable_mergejoin=off;
set enable_hashjoin = on;
explain (costs off, verbose on) 
select * from t_subplan1 where c1 > any(select c2 from t_subplan2 join t_subplan3 on a3 = a2 where b2 < b1) order by 1,2,3,4 limit 10;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
   ->  Vector Limit
         Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               Merge Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
               ->  Vector Limit
                     Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                     ->  Vector Sort
                           Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                           ->  Vector Limit
                                 Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                 ->  Vector Sort
                                       Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       Sort Key: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                       ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                             Output: t_subplan1.a1, t_subplan1.b1, t_subplan1.c1, t_subplan1.d1
                                             Distribute Key: t_subplan1.a1, t_subplan1.b1
                                             Filter: (SubPlan 1)
                                             SubPlan 1
                                               ->  Row Adapter
                                                     Output: t_subplan2.c2
                                                     ->  Vector Sonic Hash Join
                                                           Output: t_subplan2.c2
                                                           Hash Cond: (t_subplan3.a3 = t_subplan2.a2)
                                                           ->  Vector Materialize
                                                                 Output: t_subplan3.a3
                                                                 ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                                                       Output: t_subplan3.a3
                                                                       ->  Vector Partition Iterator
                                                                             Output: t_subplan3.a3
                                                                             Iterations: 2
                                                                             ->  Partitioned CStore Scan on nodegroup_subplan_test.t_subplan3
                                                                                   Output: t_subplan3.a3
                                                                                   Selected Partitions:  1..2
                                                           ->  Vector Result
                                                                 Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                 Filter: (t_subplan2.b2 < t_subplan1.b1)
                                                                 ->  Vector Materialize
                                                                       Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                             Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                   Output: t_subplan2.c2, t_subplan2.a2, t_subplan2.b2
                                                                                   Distribute Key: t_subplan2.a2, t_subplan2.b2
(47 rows)

select * from t_subplan1 where c1 > any(select c2 from t_subplan2 join t_subplan3 on a3 = a2 where b2 < b1) order by 1,2,3,4 limit 10;
 a1 | b1 | c1 | d1 
----+----+----+----
  0 | 18 |  7 |  2
  1 | 19 |  8 |  3
  2 |  2 |  2 |  2
  3 |  3 |  3 |  3
  4 |  4 |  4 |  4
  5 |  5 |  5 |  5
  6 |  6 |  6 |  0
  7 |  7 |  7 |  1
  8 |  8 |  8 |  2
  9 |  9 |  9 |  3
(10 rows)

---add llt case
CREATE TABLE t_subplan08
(
   col_num	numeric(5, 0)
  ,col_int	int
  ,col_timestamptz	timestamptz
  ,col_varchar	varchar
  ,col_char	char(2)
  ,col_interval	interval
  ,col_timetz	timetz
  ,col_tinterval	tinterval
) with(orientation=column,autovacuum_enabled = off) to group ng0;
COPY t_subplan08(col_num, col_int, col_timestamptz, col_varchar, col_char, col_interval, col_timetz, col_tinterval) FROM stdin;
CREATE TABLE t_subplan09
(
   col_num	numeric(5, 0)
  ,col_int	int
  ,col_timestamptz	timestamptz
  ,col_varchar	varchar
  ,col_char	char(2)
  ,col_interval	interval
  ,col_timetz	timetz
  ,col_tinterval	tinterval
) with(orientation=column,autovacuum_enabled = off) to group ng2;
insert into t_subplan09 select * from t_subplan08;
insert into t_subplan09 values (NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
CREATE TABLE t_subplan10
(
   col_num	numeric(5, 0)
  ,col_int	int
  ,col_timestamptz	timestamptz
  ,col_varchar	varchar
  ,col_char	char(2)
  ,col_interval	interval
  ,col_timetz	timetz
  ,col_tinterval	tinterval
) with(orientation=column,autovacuum_enabled = off) to group ng3;
insert into t_subplan08 values (1,4,'2014-01-09 19:35:37','2014-11-09 19:35:37','j','8 day 13:34:56','1988-2-6 01:00:30+8', NULL);
explain (costs off, verbose on) 
select count(*) from t_subplan08 group by col_interval  having(min(col_interval)  = any(select col_interval  from t_subplan09));
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), t_subplan08.col_interval
   ->  Vector Streaming (type: GATHER)
         Output: (count(*)), t_subplan08.col_interval
         ->  Vector Hash Aggregate
               Output: count(*), t_subplan08.col_interval
               Group By Key: t_subplan08.col_interval
               Filter: (hashed SubPlan 1)
               ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                     Output: t_subplan08.col_interval
                     Distribute Key: t_subplan08.col_interval
                     ->  CStore Scan on nodegroup_subplan_test.t_subplan08
                           Output: t_subplan08.col_interval
                           Distribute Key: t_subplan08.col_num
               SubPlan 1
                 ->  Row Adapter
                       Output: t_subplan09.col_interval
                       ->  Vector Materialize
                             Output: t_subplan09.col_interval
                             ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                   Output: t_subplan09.col_interval
                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan09
                                         Output: t_subplan09.col_interval
                                         Distribute Key: t_subplan09.col_num
(24 rows)

select count(*) from t_subplan08 group by col_interval  having(min(col_interval)  = any(select col_interval  from t_subplan09));
 count 
-------
     1
     1
     1
     1
     1
     1
     1
     1
(8 rows)

explain (costs off, verbose on) 
select count(*) from t_subplan08 group by col_interval  having(min(col_interval)  = any(select col_interval  from t_subplan10));
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), t_subplan08.col_interval
   ->  Vector Streaming (type: GATHER)
         Output: (count(*)), t_subplan08.col_interval
         ->  Vector Hash Aggregate
               Output: count(*), t_subplan08.col_interval
               Group By Key: t_subplan08.col_interval
               Filter: (hashed SubPlan 1)
               ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                     Output: t_subplan08.col_interval
                     Distribute Key: t_subplan08.col_interval
                     ->  CStore Scan on nodegroup_subplan_test.t_subplan08
                           Output: t_subplan08.col_interval
                           Distribute Key: t_subplan08.col_num
               SubPlan 1
                 ->  Row Adapter
                       Output: t_subplan10.col_interval
                       ->  Vector Materialize
                             Output: t_subplan10.col_interval
                             ->  Vector Streaming(type: BROADCAST ng: ng3->GenGroup)
                                   Output: t_subplan10.col_interval
                                   ->  CStore Scan on nodegroup_subplan_test.t_subplan10
                                         Output: t_subplan10.col_interval
                                         Distribute Key: t_subplan10.col_num
(24 rows)

select count(*) from t_subplan08 group by col_interval  having(min(col_interval)  = any(select col_interval  from t_subplan10));
 count 
-------
(0 rows)

explain (costs off, verbose on)
select count(*) from t_subplan08 group by col_timetz  having(min(col_timetz)  = any(select col_timetz  from t_subplan09)) order by 1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), t_subplan08.col_timetz
   ->  Vector Streaming (type: GATHER)
         Output: (count(*)), t_subplan08.col_timetz
         Merge Sort Key: (count(*))
         ->  Vector Sort
               Output: (count(*)), t_subplan08.col_timetz
               Sort Key: (count(*))
               ->  Vector Hash Aggregate
                     Output: count(*), t_subplan08.col_timetz
                     Group By Key: t_subplan08.col_timetz
                     Filter: (hashed SubPlan 1)
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                           Output: t_subplan08.col_timetz
                           Distribute Key: t_subplan08.col_timetz
                           ->  CStore Scan on nodegroup_subplan_test.t_subplan08
                                 Output: t_subplan08.col_timetz
                                 Distribute Key: t_subplan08.col_num
                     SubPlan 1
                       ->  Row Adapter
                             Output: t_subplan09.col_timetz
                             ->  Vector Materialize
                                   Output: t_subplan09.col_timetz
                                   ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                         Output: t_subplan09.col_timetz
                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan09
                                               Output: t_subplan09.col_timetz
                                               Distribute Key: t_subplan09.col_num
(28 rows)

select count(*) from t_subplan08 group by col_timetz  having(min(col_timetz)  = any(select col_timetz  from t_subplan09)) order by 1;
 count 
-------
     1
     1
     1
     1
     2
     3
(6 rows)

explain (costs off, verbose on)
select count(*) from t_subplan08 group by col_char  having(min(col_char)  = any(select col_char  from t_subplan09)) order by 1;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Row Adapter
   Output: (count(*)), t_subplan08.col_char
   ->  Vector Streaming (type: GATHER)
         Output: (count(*)), t_subplan08.col_char
         Merge Sort Key: (count(*))
         ->  Vector Sort
               Output: (count(*)), t_subplan08.col_char
               Sort Key: (count(*))
               ->  Vector Hash Aggregate
                     Output: count(*), t_subplan08.col_char
                     Group By Key: t_subplan08.col_char
                     Filter: (hashed SubPlan 1)
                     ->  Vector Streaming(type: REDISTRIBUTE dop: 1/2 ng: ng0->group1)
                           Output: t_subplan08.col_char
                           Distribute Key: t_subplan08.col_char
                           ->  CStore Scan on nodegroup_subplan_test.t_subplan08
                                 Output: t_subplan08.col_char
                                 Distribute Key: t_subplan08.col_num
                     SubPlan 1
                       ->  Row Adapter
                             Output: t_subplan09.col_char
                             ->  Vector Materialize
                                   Output: t_subplan09.col_char
                                   ->  Vector Streaming(type: BROADCAST ng: ng2->GenGroup)
                                         Output: t_subplan09.col_char
                                         ->  CStore Scan on nodegroup_subplan_test.t_subplan09
                                               Output: t_subplan09.col_char
                                               Distribute Key: t_subplan09.col_num
(28 rows)

select count(*) from t_subplan08 group by col_char  having(min(col_char)  = any(select col_char  from t_subplan09)) order by 1;
 count 
-------
     1
     1
     1
     1
     1
     1
     2
(7 rows)

explain (costs off, verbose on)
select b1, count(*) from t_subplan1 where c1 = all (select b2 from t_subplan2 where b2 != c1) group by b1 order by 1, 2 limit 5;
--?.*
HINT:  Do analyze for them in order to generate optimized plan.
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: t_subplan1.b1, (count(*))
   ->  Vector Limit
         Output: t_subplan1.b1, (count(*))
         ->  Vector Streaming (type: GATHER)
               Output: t_subplan1.b1, (count(*))
               Merge Sort Key: t_subplan1.b1, (count(*))
               ->  Vector Limit
                     Output: t_subplan1.b1, (count(*))
                     ->  Vector Sort
                           Output: t_subplan1.b1, (count(*))
                           Sort Key: t_subplan1.b1, (count(*))
                           ->  Vector Streaming(type: LOCAL GATHER dop: 1/2)
                                 Output: t_subplan1.b1, (count(*))
                                 ->  Vector Sonic Hash Aggregate
                                       Output: t_subplan1.b1, count(*)
                                       Group By Key: t_subplan1.b1
                                       ->  Vector Streaming(type: SPLIT REDISTRIBUTE dop: 2/1 ng: ng0->group1)
                                             Output: t_subplan1.b1, t_subplan1.c1
                                             Distribute Key: t_subplan1.b1
                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan1
                                                   Output: t_subplan1.b1, t_subplan1.c1
                                                   Distribute Key: t_subplan1.a1, t_subplan1.b1
                                                   Filter: (SubPlan 1)
                                                   SubPlan 1
                                                     ->  Row Adapter
                                                           Output: t_subplan2.b2
                                                           ->  Vector Result
                                                                 Output: t_subplan2.b2
                                                                 Filter: (t_subplan2.b2 <> t_subplan1.c1)
                                                                 ->  Vector Materialize
                                                                       Output: t_subplan2.b2
                                                                       ->  Vector Streaming(type: BROADCAST ng: ng1->GenGroup)
                                                                             Output: t_subplan2.b2
                                                                             ->  CStore Scan on nodegroup_subplan_test.t_subplan2
                                                                                   Output: t_subplan2.b2
                                                                                   Distribute Key: t_subplan2.a2, t_subplan2.b2
(37 rows)

select b1, count(*) from t_subplan1 where c1 = all (select b2 from t_subplan2 where b2 != c1) group by b1 order by 1, 2 limit 5;
 b1 | count 
----+-------
(0 rows)

reset current_schema;
drop schema nodegroup_subplan_test cascade;
NOTICE:  drop cascades to 21 other objects
DETAIL:  drop cascades to table nodegroup_subplan_test.temp
drop cascades to table nodegroup_subplan_test.t_subplan1
drop cascades to table nodegroup_subplan_test.t_subplan2
drop cascades to table nodegroup_subplan_test.t_subplan5
drop cascades to table nodegroup_subplan_test.t_subplan6
drop cascades to table nodegroup_subplan_test.t_subplan7
drop cascades to table nodegroup_subplan_test.int4_tbl
drop cascades to table nodegroup_subplan_test.tenk1
drop cascades to table nodegroup_subplan_test.subselect_tbl
drop cascades to table nodegroup_subplan_test.subselect_foo
drop cascades to table nodegroup_subplan_test.subselect_bar
drop cascades to table nodegroup_subplan_test.ta
drop cascades to table nodegroup_subplan_test.tb
drop cascades to table nodegroup_subplan_test.tc
drop cascades to table nodegroup_subplan_test.subselect_t1
drop cascades to table nodegroup_subplan_test.outer_7597
drop cascades to table nodegroup_subplan_test.inner_7597
drop cascades to table nodegroup_subplan_test.t_subplan3
drop cascades to table nodegroup_subplan_test.t_subplan08
drop cascades to table nodegroup_subplan_test.t_subplan09
drop cascades to table nodegroup_subplan_test.t_subplan10
drop node group ng0;
drop node group ng1;
drop node group ng2;
drop node group ng3;
reset query_dop;
