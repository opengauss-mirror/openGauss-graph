--
--prepared execute bypass
--
set enable_opfusion=on;
set enable_bitmapscan=off;
set enable_seqscan=off;
set opfusion_debug_mode = 'log';
set log_min_messages=debug;
set logging_module = 'on(OPFUSION)';
set sql_beta_feature = 'index_cost_with_leaf_pages_only';
drop table if exists test_bypass_sq1;
NOTICE:  table "test_bypass_sq1" does not exist, skipping
create table test_bypass_sq1(col1 int, col2 int, col3 text);
create index itest_bypass_sq1 on test_bypass_sq1(col1,col2);
prepare p11 as insert into test_bypass_sq1 values($1,$2,$3);
prepare p12 as insert into test_bypass_sq1(col1,col2) values ($1,$2);
--bypass
explain execute p11(0,0,'test_insert');
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

execute p11(0,0,'test_insert');
execute p11(1,1,'test_insert');
execute p11(-1,-1,'test_insert2');
execute p11(2,2,'test_insert2');
execute p11(3,3,'test_insert3');
execute p11(0,0,'test_insert3');
explain execute p12(1,1);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

execute p12(1,1);
execute p12(2,2);
execute p12(0,0);
execute p11(null,null,null);
--bypass
prepare p13 as select * from test_bypass_sq1 where col1=$1 and col2=$2;
explain execute p13(0,0);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
   Index Cond: ((col1 = $1) AND (col2 = $2))
(3 rows)

execute p13(0,0);
 col1 | col2 |     col3     
------+------+--------------
    0 |    0 | 
    0 |    0 | test_insert3
    0 |    0 | test_insert
(3 rows)

prepare p13 as select col1,col2 from test_bypass_sq1 where col1=$1 and col2=$2;
ERROR:  prepared statement "p13" already exists
--bypass through index only scan
explain execute p13(0,0);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.27 rows=1 width=40)
   Index Cond: ((col1 = $1) AND (col2 = $2))
(3 rows)

execute p13(0,0);
 col1 | col2 |     col3     
------+------+--------------
    0 |    0 | 
    0 |    0 | test_insert3
    0 |    0 | test_insert
(3 rows)

set enable_indexonlyscan=off;
execute p13(0,0);
 col1 | col2 |     col3     
------+------+--------------
    0 |    0 | 
    0 |    0 | test_insert3
    0 |    0 | test_insert
(3 rows)

reset enable_indexonlyscan;
--not bypass (distribute key)
--prepare p14 as update test_bypass_sq1 set col1=col1+$4,col2=$5,col3=$3 where col1=$1 and col2=$2;
--execute p14 (0,0,'test_update',3,-1);
--bypass
prepare p15 as update test_bypass_sq1 set col2=col2+$4,col3=$3 where col1=$1 and col2=$2;
execute p15 (0,0,'test_update',-1);
--bypass
prepare p16 as update test_bypass_sq1 set col2=mod($1,$2)  where col1=$3 and col2=$4;
execute p16(5,3,1,1);
--bypass / set  enable_bitmapscan=off;
prepare p101 as update test_bypass_sq1 set col2=$1,col3=$2 where  col1=$3 ;
execute p101 (111,'test_update2',-1);
prepare p102 as select * from  test_bypass_sq1 where col1=$1;
execute p102 (1);
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
    1 |    2 | 
(2 rows)

prepare p1011 as insert into test_bypass_sq1 values(-3,-3,'test_pbe');
prepare p1013 as update test_bypass_sq1 set col2=10 where col1=-3;
prepare p1012 as select * from test_bypass_sq1 where col1=-3;
prepare p1014 as select * from test_bypass_sq1 where col1=-3 for update;
prepare p1015 as delete from test_bypass_sq1 where col1=-3;
explain execute p1011;
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq1  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

execute p1011;
explain execute p1012;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=40)
   Index Cond: (col1 = (-3))
(3 rows)

execute p1012;
 col1 | col2 |   col3   
------+------+----------
   -3 |   -3 | test_pbe
(1 row)

explain execute p1013;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=42)
         Index Cond: (col1 = (-3))
(4 rows)

execute p1013;
explain execute p1014;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 LockRows  (cost=0.00..24.42 rows=6 width=46)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=46)
         Index Cond: (col1 = (-3))
(4 rows)

execute p1014;
 col1 | col2 |   col3   
------+------+----------
   -3 |   10 | test_pbe
(1 row)

--bypass through index only scan
prepare p10141 as select col1,col2 from test_bypass_sq1 where col1=-3 for update;
execute p10141;
 col1 | col2 
------+------
   -3 |   10
(1 row)

execute p1015;
prepare p1020 as  select * from  test_bypass_sq1 where col1>0 order by col1 limit 1;
execute p1020;
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
(1 row)

prepare p1021 as select * from  test_bypass_sq1 where col1=$1 limit 1;
execute p1021(1);
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
(1 row)

--bypass through index only scan
prepare p10200 as  select col1,col2 from  test_bypass_sq1 where col1>0 order by col1 limit 1;
explain execute p10200;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..0.13 rows=1 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..51.06 rows=389 width=8)
         Index Cond: (col1 > 0)
(4 rows)

execute p10200;
 col1 | col2 
------+------
    1 |    2
(1 row)

prepare p10211 as select col1,col2 from  test_bypass_sq1 where col1=$1 limit 1;
explain execute p10211(1);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..4.06 rows=1 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
         Index Cond: (col1 = $1)
(4 rows)

execute p10211(1);
 col1 | col2 
------+------
    1 |    2
(1 row)

prepare p10212 as select col1,col2 from  test_bypass_sq1 where col1=$1 offset 1;
explain execute p10212(1);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=4.06..24.36 rows=5 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
         Index Cond: (col1 = $1)
(4 rows)

execute p10212(1);
 col1 | col2 
------+------
    1 |    2
(1 row)

prepare p10213 as select col1,col2 from  test_bypass_sq1 where col1=$1 limit 1 offset null;
explain execute p10213(1);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..4.06 rows=1 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
         Index Cond: (col1 = $1)
(4 rows)

execute p10213(1);
 col1 | col2 
------+------
    1 |    2
(1 row)

prepare p10214 as select col1,col2 from  test_bypass_sq1 where col1=$1 limit null offset null;
explain execute p10214(1);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..24.36 rows=6 width=8)
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
         Index Cond: (col1 = $1)
(4 rows)

execute p10214(1);
 col1 | col2 
------+------
    1 |    2
    1 |    2
(2 rows)

--not bypass
prepare p1022 as select * from  test_bypass_sq1 where col1=$1 limit $2;
explain execute p1022(0,3);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=0.00..4.06 rows=1 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=40)
         Index Cond: (col1 = $1)
(4 rows)

explain execute p1022(0,null);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=0.00..4.06 rows=1 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=40)
         Index Cond: (col1 = $1)
(4 rows)

prepare p1023 as select * from  test_bypass_sq1 where col1=$1 limit $2 offset $3;
explain execute p1023(0,3,2);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=4.06..8.12 rows=1 width=40)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=40)
         Index Cond: (col1 = $1)
(4 rows)

--bypass
prepare p1024 as select * from  test_bypass_sq1 where col1=0 order by col1 for update limit 1;
prepare p1025 as select * from  test_bypass_sq1 where col1=$1 for update limit 1;
execute p1024;
 col1 | col2 |    col3     
------+------+-------------
    0 |   -1 | test_update
(1 row)

execute p1025(1);
 col1 | col2 |    col3     
------+------+-------------
    1 |    2 | test_insert
(1 row)

--not bypass
prepare p1026 as select * from  test_bypass_sq1 where col1=$1 for update limit $2;
prepare p1027 as select * from  test_bypass_sq1 where col1=$1 for update limit $2 offset $3;
explain execute p1026(0,3);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=0.00..4.07 rows=1 width=46)
   ->  LockRows  (cost=0.00..24.42 rows=6 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=46)
               Index Cond: (col1 = $1)
(5 rows)

execute p1026(0,3);
 col1 | col2 |    col3     
------+------+-------------
    0 |   -1 | test_update
    0 |   -1 | test_update
    0 |   -1 | test_update
(3 rows)

explain execute p1027(0,3,2);
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=4.07..8.14 rows=1 width=46)
   ->  LockRows  (cost=0.00..24.42 rows=6 width=46)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=46)
               Index Cond: (col1 = $1)
(5 rows)

execute p1027(0,3,2);
 col1 | col2 |    col3     
------+------+-------------
    0 |   -1 | test_update
(1 row)

--bypass
prepare p103 as select col1,col2 from test_bypass_sq1 where col2=$1 order by col1;
execute p103 (2);
 col1 | col2 
------+------
    1 |    2
    1 |    2
    2 |    2
    2 |    2
(4 rows)

prepare p104 as select * from test_bypass_sq1 where col1=$1 order by col1;
execute p104 (3);
 col1 | col2 |     col3     
------+------+--------------
    3 |    3 | test_insert3
(1 row)

prepare p105 as select col1,col2 from test_bypass_sq1 where col2<$1 order by col1;
execute p105 (5);
 col1 | col2 
------+------
    0 |   -1
    0 |   -1
    0 |   -1
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |    3
(8 rows)

prepare p1051 as select col1,col2 from test_bypass_sq1 where col2<$1 order by col1 limit 3;
execute p1051(5);
 col1 | col2 
------+------
    0 |   -1
    0 |   -1
    0 |   -1
(3 rows)

prepare p1052 as select col1,col2 from test_bypass_sq1 where col1=$1 order by col1 for update limit 2;
execute p1052(2);
 col1 | col2 
------+------
    2 |    2
    2 |    2
(2 rows)

prepare p106 as select col1,col2 from test_bypass_sq1 where col1>$1 and col2>$2 order by col1;
explain execute p106 (0,1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..49.44 rows=130 width=8)
   Index Cond: ((col1 > $1) AND (col2 > $2))
(3 rows)

execute p106 (0,1);
 col1 | col2 
------+------
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |    3
(5 rows)

prepare p1061 as select col1,col2 from test_bypass_sq1 where col1 is not null and col2 is not null order by col1;
explain execute p1061;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..71.41 rows=1155 width=8)
   Index Cond: ((col1 IS NOT NULL) AND (col2 IS NOT NULL))
(3 rows)

execute p1061;
 col1 | col2 
------+------
   -1 |  111
    0 |   -1
    0 |   -1
    0 |   -1
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |    3
(9 rows)

prepare p1062 as select col1,col2 from test_bypass_sq1 where col1 is not null and col2 < $1 order by col1;
execute p1062 (3);
 col1 | col2 
------+------
    0 |   -1
    0 |   -1
    0 |   -1
    1 |    2
    1 |    2
    2 |    2
    2 |    2
(7 rows)

--bypass through index only scan
prepare p10601 as select col1,col2 from test_bypass_sq1 where col1>$1 and col2>$2 order by col1;
execute p10601 (0,1);
 col1 | col2 
------+------
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |    3
(5 rows)

--bypass
prepare p17 as select * from test_bypass_sq1 where col1=$1 and col2=$2 for update;
execute p17 (3,3);
 col1 | col2 |     col3     
------+------+--------------
    3 |    3 | test_insert3
(1 row)

--bypass (?)
prepare p18 as update test_bypass_sq1 set col2=$1*$2  where col1=$3 and col2=$4;
explain execute p18(3,7,3,3);
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..8.28 rows=1 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..8.28 rows=1 width=42)
         Index Cond: ((col1 = $3) AND (col2 = $4))
(4 rows)

execute p18(3,7,3,3);
prepare p181 as update test_bypass_sq1 set col2= $1 where col1 is null;
explain execute p181(111);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 [Bypass]
 Update on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=42)
   ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=42)
         Index Cond: (col1 IS NULL)
(4 rows)

execute p181(111);
--bypass
prepare p19 as delete from  test_bypass_sq1 where col1=$1 and col2=$2;
execute p19 (0,-1);
execute p11(null,null,'test_null');
prepare p191 as select * from test_bypass_sq1 where col1 is null  and col2 is null;
prepare p192 as delete from  test_bypass_sq1 where col1 is null  and col2 is null;
execute p191;
 col1 | col2 |   col3    
------+------+-----------
      |      | test_null
(1 row)

execute p192;
--bypass (order by is supported when ordered col is  in index)
prepare p111 as select col1,col2 from test_bypass_sq1 order by col1 desc;
execute p111;
 col1 | col2 
------+------
      |  111
    3 |   21
    2 |    2
    2 |    2
    1 |    2
    1 |    2
   -1 |  111
(7 rows)

prepare p112 as select col1,col2 from test_bypass_sq1 order by col1;
execute p112;
 col1 | col2 
------+------
   -1 |  111
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |   21
      |  111
(7 rows)

--bypass through index only scan
prepare p11301 as select col1,col2 from test_bypass_sq1 where col1 = $1 order by col1,col2 desc;
explain execute p11301 (2);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan Backward using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
   Index Cond: (col1 = $1)
(3 rows)

prepare p11401 as select col1,col2 from test_bypass_sq1 where col1 = $1 order by col1,col2;
explain execute p11401 (2);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
   Index Cond: (col1 = $1)
(3 rows)

set enable_indexonlyscan=off;
explain execute p11301 (2);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan Backward using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
   Index Cond: (col1 = $1)
(3 rows)

explain execute p11401 (2);
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [Bypass]
 Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..24.36 rows=6 width=8)
   Index Cond: (col1 = $1)
(3 rows)

reset enable_indexonlyscan;
--not bypass
prepare p115 as select * from test_bypass_sq1 order by col2 desc;
explain execute p115;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=1000000002226.45..1000000002229.37 rows=1167 width=40)
   Sort Key: col2 DESC
   ->  Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002167.00 rows=1167 width=40)
(4 rows)

prepare p116 as select * from test_bypass_sq1 order by col2;
explain execute p116;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=1000000002226.45..1000000002229.37 rows=1167 width=40)
   Sort Key: col2
   ->  Seq Scan on test_bypass_sq1  (cost=10000000000.00..1000000002167.00 rows=1167 width=40)
(4 rows)

-- bypass
prepare p117 as select col1, col2 from test_bypass_sq1 where true order by col1;
prepare p118 as select col2, col1 from test_bypass_sq1 order by col1;
prepare p119 as select col1, col2 from test_bypass_sq1 order by col1 desc;
execute p117;
 col1 | col2 
------+------
   -1 |  111
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    3 |   21
      |  111
(7 rows)

execute p118;
 col2 | col1 
------+------
  111 |   -1
    2 |    1
    2 |    1
    2 |    2
    2 |    2
   21 |    3
  111 |     
(7 rows)

execute p119;
 col1 | col2 
------+------
      |  111
    3 |   21
    2 |    2
    2 |    2
    1 |    2
    1 |    2
   -1 |  111
(7 rows)

prepare p120 as insert into test_bypass_sq1 select * from test_bypass_sq1 where col1>$1;
execute p120 (0);
--
drop table if exists test_bypass_sq2;
NOTICE:  table "test_bypass_sq2" does not exist, skipping
create table test_bypass_sq2(col1 int not null, col2 int);
create index itest_bypass_sq2 on test_bypass_sq2(col1);
--bypass
prepare p21 as insert into test_bypass_sq2(col1) values ($1);
execute p21(0);
--error
execute p21(null);
ERROR:  null value in column "col1" violates not-null constraint
DETAIL:  Failing row contains (null, null).
--bypass
prepare p22 as insert into test_bypass_sq2(col1,col2) values ($1,$2);
explain execute p22(1,null);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq2  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

execute p22(1,null);
execute p22(3,3);
execute p22(-1,-1);
execute p22(1,1);
execute p22(2,2);
execute p22(3,3);
--bypass
prepare p24 as update test_bypass_sq2 set col2 = col2+$1 where col1 = $2;
execute p24(1,0);
prepare p25 as select * from test_bypass_sq2  where col1 = $1;
execute p25(0);
 col1 | col2 
------+------
    0 |     
(1 row)

--bypass
prepare p26 as select * from test_bypass_sq2  where col1 >= $1 order by col1;
execute p26 (0);
 col1 | col2 
------+------
    0 |     
    1 |    1
    1 |     
    2 |    2
    3 |    3
    3 |    3
(6 rows)

prepare p261 as select * from test_bypass_sq2  where col1 >= $1 order by col1 limit 1;
execute p261 (0);
 col1 | col2 
------+------
    0 |     
(1 row)

prepare p262 as select * from test_bypass_sq2  where col1 = $1 order by col1 for update limit 2;
explain execute p262 (0);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.00..6.65 rows=2 width=14)
   ->  LockRows  (cost=0.00..36.55 rows=11 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=14)
               Index Cond: (col1 = $1)
(5 rows)

execute p262 (0);
 col1 | col2 
------+------
    0 |     
(1 row)

--bypass through index only scan
prepare p26101 as select col1 from test_bypass_sq2  where col1 >= $1 order by col1 limit 2;
execute p26101 (0);
 col1 
------
    0
    1
(2 rows)

--not bypass
prepare p201 as select * from test_bypass_sq2  where col2 = $1;
explain execute p201 (0);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003686.25 rows=11 width=8)
   Filter: (col2 = $1)
(3 rows)

explain execute p201 (null);
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003686.25 rows=11 width=8)
   Filter: (col2 = $1)
(3 rows)

prepare p202 as select * from test_bypass_sq2  where col1 = $1 and col2 = $2;
explain execute p202 (0,0);
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used indexscan with qual.
 Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.47 rows=1 width=8)
   Index Cond: (col1 = $1)
   Filter: (col2 = $2)
(4 rows)

--not bypass
prepare p203 as select t1.col3, t2.col2  from test_bypass_sq1 as t1 join test_bypass_sq2 as t2 on t1.col1=t2.col1;
explain execute p203;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Hash Join  (cost=80.34..307.71 rows=12539 width=36)
   Hash Cond: (t2.col1 = t1.col1)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2 t2  (cost=0.00..80.49 rows=2149 width=8)
   ->  Hash  (cost=65.76..65.76 rows=1167 width=36)
         ->  Index Scan using itest_bypass_sq1 on test_bypass_sq1 t1  (cost=0.00..65.76 rows=1167 width=36)
(6 rows)

prepare p204 as select count(*),col1 from test_bypass_sq1 group by col1;
explain execute p204;
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 GroupAggregate  (cost=0.00..73.59 rows=200 width=12)
   Group By Key: col1
   ->  Index Only Scan using itest_bypass_sq1 on test_bypass_sq1  (cost=0.00..65.76 rows=1167 width=4)
(4 rows)

--bypass (order by is supported when ordered col is in index)
prepare p211 as select col1,col2 from test_bypass_sq1 order by col1 desc;
execute p211;
 col1 | col2 
------+------
      |  111
    3 |   21
    3 |   21
    2 |    2
    2 |    2
    2 |    2
    2 |    2
    1 |    2
    1 |    2
    1 |    2
    1 |    2
   -1 |  111
(12 rows)

prepare p212 as select col1,col2 from test_bypass_sq1 order by col1;
execute p212;
 col1 | col2 
------+------
   -1 |  111
    1 |    2
    1 |    2
    1 |    2
    1 |    2
    2 |    2
    2 |    2
    2 |    2
    2 |    2
    3 |   21
    3 |   21
      |  111
(12 rows)

--not bypass
prepare p213 as select * from test_bypass_sq2 order by col1,col2;
explain execute p213;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Sort  (cost=1000000003267.94..1000000003273.31 rows=2149 width=8)
   Sort Key: col1, col2
   ->  Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003149.00 rows=2149 width=8)
(4 rows)

--bypass
prepare p27 as select * from test_bypass_sq2 where col1 = $1 limit 1;
execute p27(0);
 col1 | col2 
------+------
    0 |     
(1 row)

execute p27(1);
 col1 | col2 
------+------
    1 |    1
(1 row)

prepare p270 as select * from test_bypass_sq2 where col1 = $1 for update limit 1;
execute p270(0);
 col1 | col2 
------+------
    0 |     
(1 row)

execute p270(1);
 col1 | col2 
------+------
    1 |    1
(1 row)

prepare p271 as select * from test_bypass_sq2 where col1 > $1 order by col1 limit 2 offset 1;
execute p271(0);
 col1 | col2 
------+------
    1 |     
    2 |    2
(2 rows)

prepare p2710 as select * from test_bypass_sq2 where col1 > $1 for update limit 2 offset 1;
explain execute p2710(0);
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 [Bypass]
 Limit  (cost=0.09..0.27 rows=2 width=14)
   ->  LockRows  (cost=0.00..63.94 rows=716 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..56.78 rows=716 width=14)
               Index Cond: (col1 > $1)
(5 rows)

--not bypass
prepare p272 as select * from test_bypass_sq2 where col1 = $1 limit $2;
explain execute p272(0,3);
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=0.00..3.31 rows=1 width=8)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=8)
         Index Cond: (col1 = $1)
(4 rows)

prepare p2720 as select * from test_bypass_sq2 where col1 = $1 for update limit $2;
explain execute p2720(0,3);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit grammar with a non-constant value.
 Limit  (cost=0.00..3.32 rows=1 width=14)
   ->  LockRows  (cost=0.00..36.55 rows=11 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=14)
               Index Cond: (col1 = $1)
(5 rows)

prepare p273 as select * from test_bypass_sq2 where col1 = $1 limit -1;
explain execute p273(0);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit count grammar with const less than zero.
 Limit  (cost=0.00..3.31 rows=1 width=8)
   ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=8)
         Index Cond: (col1 = $1)
(4 rows)

--bypass
prepare p2730 as select * from test_bypass_sq2 where col1 = $1 for update limit -1;
explain execute p2730(0);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used limit count grammar with const less than zero.
 Limit  (cost=0.00..3.32 rows=1 width=14)
   ->  LockRows  (cost=0.00..36.55 rows=11 width=14)
         ->  Index Scan using itest_bypass_sq2 on test_bypass_sq2  (cost=0.00..36.44 rows=11 width=14)
               Index Cond: (col1 = $1)
(5 rows)

prepare p274 as select * from test_bypass_sq2 where col1 = $1 limit 0;
execute p274(0);
 col1 | col2 
------+------
(0 rows)

prepare p2740 as select * from test_bypass_sq2 where col1 = $1 for update limit 0;
execute p2740(0);
 col1 | col2 
------+------
(0 rows)

prepare p275 as select * from  test_bypass_sq2 where col1 is not null;
explain execute p275;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq2  (cost=10000000000.00..1000000003149.00 rows=2149 width=8)
(2 rows)

--
drop table if exists test_bypass_sq3;
NOTICE:  table "test_bypass_sq3" does not exist, skipping
create table test_bypass_sq3(col1 int default 1, col2 int, col3 timestamp);
create index itest_bypass_sq3 on test_bypass_sq3(col1);
--bypass
prepare p31 as insert into test_bypass_sq3(col2,col3) values ($1,$2);
--wrong input
execute p31(1,default);
ERROR:  syntax error at or near "default"
LINE 1: execute p31(1,default);
                      ^
--bypass
execute p31(3,null);
prepare p32 as insert into test_bypass_sq3 values($1,$2,$3);
execute p32(2,3,null);
execute p32 (3,3,null);
execute p32 (null,3,null);
--bypass(?)
execute p32 (-1,-1,current_timestamp);
--bypass
prepare p33 as select * from test_bypass_sq3 where col1 >= $1 order by col1;
execute p33(1);
 col1 | col2 | col3 
------+------+------
    1 |    3 | 
    2 |    3 | 
    3 |    3 | 
(3 rows)

execute p33(2);
 col1 | col2 | col3 
------+------+------
    2 |    3 | 
    3 |    3 | 
(2 rows)

prepare p34 as select col2 from test_bypass_sq3 where col1 = $1 for update;
prepare p35 as update test_bypass_sq3 set col2 = col2*3 where col1 = $1;
execute p34(2);
 col2 
------
    3
(1 row)

execute p35(2);
execute p34(1);
 col2 
------
    3
(1 row)

execute p35(1);
--not bypass
prepare p36 as select * from test_bypass_sq3 where col2 > 0;
explain execute p36(3);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query's scan operator is not index.
 Seq Scan on test_bypass_sq3  (cost=10000000000.00..1000000003220.00 rows=592 width=16)
   Filter: (col2 > 0)
(3 rows)

--bypass
prepare p37 as select * from test_bypass_sq3 where col1 is null;
execute p37;
 col1 | col2 | col3 
------+------+------
      |    3 | 
(1 row)

--test random index pos
drop table if exists test_bypass_sq4;
NOTICE:  table "test_bypass_sq4" does not exist, skipping
create table test_bypass_sq4(col1 int, col2 int, col3 int);
create index itest_bypass_sq4 on test_bypass_sq4(col3,col2);
prepare p40 as insert into test_bypass_sq4 values ($1,$2,$3);
execute p40 (11,21,31);
execute p40 (11,22,32);
execute p40 (12,23,32);
execute p40 (12,23,33);
execute p40 (13,24,33);
execute p40 (13,24,34);
execute p40 (14,25,34);
execute p40 (14,25,35);
execute p40 (55,55,55);
execute p40 (55,55,null);
execute p40  (55,null,55);
execute p40  (55,null,null);
explain execute p40 (null,null,null);
                         QUERY PLAN                          
-------------------------------------------------------------
 [Bypass]
 Insert on test_bypass_sq4  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

execute p40 (null,null,null);
prepare p401 as select col3, col1, col2 from test_bypass_sq4 where col2 >$1 order by 1,3;
execute p401 (22);
 col3 | col1 | col2 
------+------+------
   32 |   12 |   23
   33 |   12 |   23
   33 |   13 |   24
   34 |   13 |   24
   34 |   14 |   25
   35 |   14 |   25
   55 |   55 |   55
      |   55 |   55
(8 rows)

prepare p402 as  select * from test_bypass_sq4 where col2 =$1 and col3= $2 order by col2;
execute p402(22,32);
 col1 | col2 | col3 
------+------+------
   11 |   22 |   32
(1 row)

prepare p403 as select col3,col2,col3 from test_bypass_sq4 where col3 >= $1 and col2 >= $2 order by col3,col2;
execute p403 (33,22);
 col3 | col2 | col3 
------+------+------
   33 |   23 |   33
   33 |   24 |   33
   34 |   24 |   34
   34 |   25 |   34
   35 |   25 |   35
   55 |   55 |   55
(6 rows)

prepare p404 as select col2,col3,col2 from test_bypass_sq4 where col3 >= $1 and col2 >= $2 order by col3,col2;
execute p404 (34,22);
 col2 | col3 | col2 
------+------+------
   24 |   34 |   24
   25 |   34 |   25
   25 |   35 |   25
   55 |   55 |   55
(4 rows)

prepare p405 as select col3,col2,col3 from test_bypass_sq4 where col3 >= $1 and col2 >= $2 order by col3 for update;
execute p406 (33,22);
ERROR:  prepared statement "p406" does not exist
prepare p406 as select col2,col3,col2 from test_bypass_sq4 where col3 >= $1 and col2 >= $2 order by col3,col2 for update;
execute p406 (34,22);
 col2 | col3 | col2 
------+------+------
   24 |   34 |   24
   25 |   34 |   25
   25 |   35 |   25
   55 |   55 |   55
(4 rows)

prepare p407 as select col2,col3,col2 from test_bypass_sq4 where col3 is null and col2 is null order by col3,col2;
execute p407;
 col2 | col3 | col2 
------+------+------
      |      |     
      |      |     
(2 rows)

prepare p408 as select col2,col3 from test_bypass_sq4 where col3 is null and col2 is not null;
execute p408;
 col2 | col3 
------+------
   55 |     
(1 row)

prepare p409 as select col2,col3 from test_bypass_sq4 where col3 is not null order by col3 desc,col2 desc;
execute p409;
 col2 | col3 
------+------
      |   55
   55 |   55
   25 |   35
   25 |   34
   24 |   34
   24 |   33
   23 |   33
   23 |   32
   22 |   32
   21 |   31
(10 rows)

drop table if exists test_bypass_sq6;
NOTICE:  table "test_bypass_sq6" does not exist, skipping
create type complextype AS (f1 int, f2 text);
create table test_bypass_sq6(col1 int, col2 complextype,col3 text);
create index itest_bypass_sq6 on test_bypass_sq6(col1,col3);
--not bypass
prepare p601 as insert into test_bypass_sq6 values ($1,ROW($2, $3),$4);
explain execute p601 (1,1,'Simon1'::text,'test'::text);
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 [No Bypass]reason: Bypass not executed because query used unsupported DML target type.
 Insert on test_bypass_sq6  (cost=0.00..0.01 rows=1 width=0)
   ->  Result  (cost=0.00..0.01 rows=1 width=0)
(3 rows)

-- just insert
reset opfusion_debug_mode;
execute p601 (1,1,'Simon1'::text,'test'::text);
set opfusion_debug_mode = 'error';
ERROR:  invalid value for parameter "opfusion_debug_mode": "error"
HINT:  Available values: off, log.
--bypass
prepare p602 as select * from test_bypass_sq6 where col1 is not null;
execute p602;
 col1 |    col2    | col3 
------+------------+------
    1 | (1,Simon1) | test
(1 row)

prepare p603 as select * from test_bypass_sq6 where col3 =$1 for update;
execute p603 ('test'::text);
 col1 |    col2    | col3 
------+------------+------
    1 | (1,Simon1) | test
(1 row)

prepare p604 as update test_bypass_sq6 set col3= $1 where col1 = $2;
execute p604 ('test_2'::text,1);
prepare p605 as select col1 from test_bypass_sq6;
execute p605;
 col1 
------
    1
(1 row)

prepare p606 as select col3 from test_bypass_sq6 order by col1,col3;
execute p606;
  col3  
--------
 test_2
(1 row)

prepare p607 as select col1, col3 from test_bypass_sq6 where true;
execute p607;
 col1 |  col3  
------+--------
    1 | test_2
(1 row)

prepare p608 as update test_bypass_sq6 set col2=$1 where col1 = $2;
execute p608(ROW(2,'Ruby2'::text),1);
--notbypass
prepare p6071 as select * from test_bypass_sq6 where true;
explain execute p6071;
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Seq Scan on test_bypass_sq6  (cost=10000000000.00..1000000001833.00 rows=833 width=68)
(1 row)

prepare p609 as update test_bypass_sq6 set col2=ROW($1,$2) where col1 = $3;
explain execute p609 (3,'Ruby3'::text,1);
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 Update on test_bypass_sq6  (cost=0.00..20.32 rows=4 width=42)
   ->  Index Scan using itest_bypass_sq6 on test_bypass_sq6  (cost=0.00..20.32 rows=4 width=42)
         Index Cond: (col1 = $3)
(3 rows)

--bypass
prepare p6091 as delete from test_bypass_sq6 where col1 = $1;
execute p6091(1);
create table test_bypass_sq7(a int, b int);
create index itest_bypass_sq7 on test_bypass_sq7(a);
insert into test_bypass_sq7 values(1,2);
insert into test_bypass_sq7 values(2,2);
prepare p71 as select * from test_bypass_sq7 where a=$1;
execute p71(1);
 a | b 
---+---
 1 | 2
(1 row)

explain execute p71(1);
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 [Bypass]
 Index Scan using itest_bypass_sq7 on test_bypass_sq7  (cost=0.00..36.44 rows=11 width=8)
   Index Cond: (a = $1)
(3 rows)

execute p71(1);
 a | b 
---+---
 1 | 2
(1 row)

drop index itest_bypass_sq7;
execute p71(1);
 a | b 
---+---
 1 | 2
(1 row)

reset enable_seqscan;
reset enable_bitmapscan;
reset opfusion_debug_mode;
reset log_min_messages;
reset logging_module;
drop table test_bypass_sq1;
drop table test_bypass_sq2;
drop table test_bypass_sq3;
drop table test_bypass_sq4;
drop table test_bypass_sq6;
drop table test_bypass_sq7;
drop type complextype;
