--
--FOR BLACKLIST FEATURE: CREATE AGGERGATE„ÄÅINHERITS is not supported.
--
--
-- AGGREGATES
--
SELECT avg(four) AS avg_1 FROM onek;
       avg_1        
--------------------
 1.5000000000000000
(1 row)

SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
       avg_32        
---------------------
 32.6666666666666667
(1 row)

-- In 7.1, avg(float4) is computed using float8 arithmetic.
-- Round the result to 3 digits to avoid platform-specific results.
SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
 avg_107_943 
-------------
     107.943
(1 row)

SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
 avg_3_4 
---------
     3.4
(1 row)

SELECT sum(four) AS sum_1500 FROM onek;
 sum_1500 
----------
     1500
(1 row)

SELECT sum(a) AS sum_198 FROM aggtest;
 sum_198 
---------
     198
(1 row)

SELECT sum(b) AS avg_431_773 FROM aggtest;
 avg_431_773 
-------------
     431.773
(1 row)

SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
 avg_6_8 
---------
     6.8
(1 row)

SELECT max(four) AS max_3 FROM onek;
 max_3 
-------
     3
(1 row)

SELECT max(a) AS max_100 FROM aggtest;
 max_100 
---------
     100
(1 row)

SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
 max_324_78 
------------
     324.78
(1 row)

SELECT max(student.gpa) AS max_3_7 FROM student;
 max_3_7 
---------
     3.7
(1 row)

SELECT stddev_pop(b) FROM aggtest;
   stddev_pop    
-----------------
 131.10703231895
(1 row)

SELECT stddev_samp(b) FROM aggtest;
   stddev_samp    
------------------
 151.389360803998
(1 row)

SELECT var_pop(b) FROM aggtest;
     var_pop      
------------------
 17189.0539234823
(1 row)

SELECT var_samp(b) FROM aggtest;
     var_samp     
------------------
 22918.7385646431
(1 row)

SELECT stddev_pop(b::numeric) FROM aggtest;
    stddev_pop    
------------------
 131.107032862199
(1 row)

SELECT stddev_samp(b::numeric) FROM aggtest;
   stddev_samp    
------------------
 151.389361431288
(1 row)

SELECT var_pop(b::numeric) FROM aggtest;
      var_pop       
--------------------
 17189.054065929769
(1 row)

SELECT var_samp(b::numeric) FROM aggtest;
      var_samp      
--------------------
 22918.738754573025
(1 row)

-- population variance is defined for a single tuple, sample variance
-- is not
SELECT var_pop(1.0), var_samp(2.0);
 var_pop | var_samp 
---------+----------
       0 |         
(1 row)

SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
 stddev_pop | stddev_samp 
------------+-------------
          0 |            
(1 row)

-- SQL2003 binary aggregates
SELECT regr_count(b, a) FROM aggtest;
 regr_count 
------------
          4
(1 row)

SELECT regr_sxx(b, a) FROM aggtest;
 regr_sxx 
----------
     5099
(1 row)

SELECT regr_syy(b, a) FROM aggtest;
     regr_syy     
------------------
 68756.2156939293
(1 row)

SELECT regr_sxy(b, a) FROM aggtest;
     regr_sxy     
------------------
 2614.51582155004
(1 row)

SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
 regr_avgx |    regr_avgy     
-----------+------------------
      49.5 | 107.943152273074
(1 row)

SELECT regr_r2(b, a) FROM aggtest;
      regr_r2      
-------------------
 .0194977982031803
(1 row)

SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
    regr_slope    |  regr_intercept  
------------------+------------------
 .512750700441271 | 82.5619926012309
(1 row)

SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
    covar_pop    |    covar_samp    
-----------------+------------------
 653.62895538751 | 871.505273850014
(1 row)

SELECT corr(b, a) FROM aggtest;
       corr       
------------------
 .139634516517873
(1 row)

SELECT count(four) AS cnt_1000 FROM onek;
 cnt_1000 
----------
     1000
(1 row)

SELECT count(DISTINCT four) AS cnt_4 FROM onek;
 cnt_4 
-------
     4
(1 row)

select ten, count(*), sum(four) from onek
group by ten order by ten;
 ten | count | sum 
-----+-------+-----
   0 |   100 | 100
   1 |   100 | 200
   2 |   100 | 100
   3 |   100 | 200
   4 |   100 | 100
   5 |   100 | 200
   6 |   100 | 100
   7 |   100 | 200
   8 |   100 | 100
   9 |   100 | 200
(10 rows)

select ten, count(four), sum(DISTINCT four) from onek
group by ten order by ten;
 ten | count | sum 
-----+-------+-----
   0 |   100 |   2
   1 |   100 |   4
   2 |   100 |   2
   3 |   100 |   4
   4 |   100 |   2
   5 |   100 |   4
   6 |   100 |   2
   7 |   100 |   4
   8 |   100 |   2
   9 |   100 |   4
(10 rows)

-- user-defined aggregates
SELECT newavg(four) AS avg_1 FROM onek;
ERROR:  function newavg(integer) does not exist
LINE 1: SELECT newavg(four) AS avg_1 FROM onek;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: avg_1
SELECT newsum(four) AS sum_1500 FROM onek;
ERROR:  function newsum(integer) does not exist
LINE 1: SELECT newsum(four) AS sum_1500 FROM onek;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: sum_1500
SELECT newcnt(four) AS cnt_1000 FROM onek;
ERROR:  function newcnt(integer) does not exist
LINE 1: SELECT newcnt(four) AS cnt_1000 FROM onek;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: cnt_1000
SELECT newcnt(*) AS cnt_1000 FROM onek;
ERROR:  function newcnt() does not exist
LINE 1: SELECT newcnt(*) AS cnt_1000 FROM onek;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: cnt_1000
SELECT oldcnt(*) AS cnt_1000 FROM onek;
ERROR:  function oldcnt() does not exist
LINE 1: SELECT oldcnt(*) AS cnt_1000 FROM onek;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: cnt_1000
SELECT sum2(q1,q2) FROM int8_tbl;
ERROR:  function sum2(bigint, bigint) does not exist
LINE 1: SELECT sum2(q1,q2) FROM int8_tbl;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: sum2
-- check collation-sensitive matching between grouping expressions
select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
 ?column? | case | count 
----------+------+-------
 aa       |    1 |     1
 ba       |    0 |     1
(2 rows)

select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
 ?column? | case | count 
----------+------+-------
 aa       |    1 |     1
 ba       |    0 |     1
(2 rows)

-- test for outer-level aggregates
-- this should work
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four) 
order by ten;
 ten | sum 
-----+-----
   0 |   2
   2 |   2
   4 |   2
   6 |   2
   8 |   2
(5 rows)

-- this should fail because subquery has an agg of its own in WHERE
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b
               where sum(distinct a.four + b.four) = b.four);
ERROR:  aggregates not allowed in WHERE clause
LINE 4:                where sum(distinct a.four + b.four) = b.four)...
                             ^
-- Test handling of sublinks within outer-level aggregates.
-- Per bug report from Daniel Grace.
create table tenk1_bak as select * from tenk1 order by unique1, unique2 limit 1;
select
  (select max((select i.unique2 from tenk1_bak i where i.unique1 = o.unique1)))
from tenk1_bak o;
 max  
------
 9998
(1 row)

drop table tenk1_bak;
--
-- test for bitwise integer aggregates
--
-- Enforce use of COMMIT instead of 2PC for temporary objects
-- CREATE TEMPORARY TABLE bitwise_test(
CREATE  TABLE bitwise_test(
  i2 INT2,
  i4 INT4,
  i8 INT8,
  i INTEGER,
  x INT2,
  y BIT(4)
);
-- empty case
SELECT
  BIT_AND(i2) AS "?",
  BIT_OR(i4)  AS "?"
FROM bitwise_test;
 ? | ? 
---+---
   |  
(1 row)

COPY bitwise_test FROM STDIN NULL 'null';
SELECT
  BIT_AND(i2) AS "1",
  BIT_AND(i4) AS "1",
  BIT_AND(i8) AS "1",
  BIT_AND(i)  AS "?",
  BIT_AND(x)  AS "0",
  BIT_AND(y)  AS "0100",
  BIT_OR(i2)  AS "7",
  BIT_OR(i4)  AS "7",
  BIT_OR(i8)  AS "7",
  BIT_OR(i)   AS "?",
  BIT_OR(x)   AS "7",
  BIT_OR(y)   AS "1101"
FROM bitwise_test;
 1 | 1 | 1 | ? | 0 | 0100 | 7 | 7 | 7 | ? | 7 | 1101 
---+---+---+---+---+------+---+---+---+---+---+------
 1 | 1 | 1 | 1 | 0 | 0100 | 7 | 7 | 7 | 3 | 7 | 1101
(1 row)

--
-- test boolean aggregates
--
-- first test all possible transition and final states
SELECT
  -- boolean and transitions
  -- null because strict
  booland_statefunc(NULL, NULL)  IS NULL AS "t",
  booland_statefunc(TRUE, NULL)  IS NULL AS "t",
  booland_statefunc(FALSE, NULL) IS NULL AS "t",
  booland_statefunc(NULL, TRUE)  IS NULL AS "t",
  booland_statefunc(NULL, FALSE) IS NULL AS "t",
  -- and actual computations
  booland_statefunc(TRUE, TRUE) AS "t",
  NOT booland_statefunc(TRUE, FALSE) AS "t",
  NOT booland_statefunc(FALSE, TRUE) AS "t",
  NOT booland_statefunc(FALSE, FALSE) AS "t";
 t | t | t | t | t | t | t | t | t 
---+---+---+---+---+---+---+---+---
 t | t | t | t | t | t | t | t | t
(1 row)

SELECT
  -- boolean or transitions
  -- null because strict
  boolor_statefunc(NULL, NULL)  IS NULL AS "t",
  boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
  boolor_statefunc(FALSE, NULL) IS NULL AS "t",
  boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
  boolor_statefunc(NULL, FALSE) IS NULL AS "t",
  -- actual computations
  boolor_statefunc(TRUE, TRUE) AS "t",
  boolor_statefunc(TRUE, FALSE) AS "t",
  boolor_statefunc(FALSE, TRUE) AS "t",
  NOT boolor_statefunc(FALSE, FALSE) AS "t";
 t | t | t | t | t | t | t | t | t 
---+---+---+---+---+---+---+---+---
 t | t | t | t | t | t | t | t | t
(1 row)

-- CREATE TEMPORARY TABLE bool_test(
CREATE  TABLE bool_test(
  b1 BOOL,
  b2 BOOL,
  b3 BOOL,
  b4 BOOL);
-- empty case
SELECT
  BOOL_AND(b1)   AS "n",
  BOOL_OR(b3)    AS "n"
FROM bool_test;
 n | n 
---+---
   | 
(1 row)

COPY bool_test FROM STDIN NULL 'null';
SELECT
  BOOL_AND(b1)     AS "f",
  BOOL_AND(b2)     AS "t",
  BOOL_AND(b3)     AS "f",
  BOOL_AND(b4)     AS "n",
  BOOL_AND(NOT b2) AS "f",
  BOOL_AND(NOT b3) AS "t"
FROM bool_test;
 f | t | f | n | f | t 
---+---+---+---+---+---
 f | t | f |   | f | t
(1 row)

SELECT
  EVERY(b1)     AS "f",
  EVERY(b2)     AS "t",
  EVERY(b3)     AS "f",
  EVERY(b4)     AS "n",
  EVERY(NOT b2) AS "f",
  EVERY(NOT b3) AS "t"
FROM bool_test;
 f | t | f | n | f | t 
---+---+---+---+---+---
 f | t | f |   | f | t
(1 row)

SELECT
  BOOL_OR(b1)      AS "t",
  BOOL_OR(b2)      AS "t",
  BOOL_OR(b3)      AS "f",
  BOOL_OR(b4)      AS "n",
  BOOL_OR(NOT b2)  AS "f",
  BOOL_OR(NOT b3)  AS "t"
FROM bool_test;
 t | t | f | n | f | t 
---+---+---+---+---+---
 t | t | f |   | f | t
(1 row)

--
-- Test cases that should be optimized into indexscans instead of
-- the generic aggregate implementation.
-- In Postgres-XC, plans printed by explain are the ones created on the
-- coordinator. Coordinator does not generate index scan plans.
--
analyze tenk1;		-- ensure we get consistent plans here
-- Basic cases
explain (costs off)
  select min(unique1) from tenk1;
                         QUERY PLAN                         
------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan using tenk1_unique1 on tenk1
                 Index Cond: (unique1 IS NOT NULL)
(5 rows)

select min(unique1) from tenk1;
 min 
-----
   0
(1 row)

explain (costs off)
  select max(unique1) from tenk1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
                 Index Cond: (unique1 IS NOT NULL)
(5 rows)

select max(unique1) from tenk1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique1) from tenk1 where unique1 < 42;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 < 42))
(5 rows)

select max(unique1) from tenk1 where unique1 < 42;
 max 
-----
  41
(1 row)

explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42))
(5 rows)

select max(unique1) from tenk1 where unique1 > 42;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42000;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique1 on tenk1
                 Index Cond: ((unique1 IS NOT NULL) AND (unique1 > 42000))
(5 rows)

select max(unique1) from tenk1 where unique1 > 42000;
 max 
-----
    
(1 row)

-- multi-column index (uses tenk1_thous_tenthous)
explain (costs off)
  select max(tenthous) from tenk1 where thousand = 33;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1
                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
(5 rows)

select max(tenthous) from tenk1 where thousand = 33;
 max  
------
 9033
(1 row)

explain (costs off)
  select min(tenthous) from tenk1 where thousand = 33;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan using tenk1_thous_tenthous on tenk1
                 Index Cond: ((thousand = 33) AND (tenthous IS NOT NULL))
(5 rows)

select min(tenthous) from tenk1 where thousand = 33;
 min 
-----
  33
(1 row)

-- check parameter propagation into an indexscan subquery
explain (costs off)
  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
    from int4_tbl;
                                       QUERY PLAN                                        
-----------------------------------------------------------------------------------------
 Seq Scan on int4_tbl
   SubPlan 2
     ->  Result
           InitPlan 1 (returns $1)
             ->  Limit
                   ->  Index Only Scan using tenk1_unique1 on tenk1
                         Index Cond: ((unique1 IS NOT NULL) AND (unique1 > int4_tbl.f1))
(7 rows)

select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
from int4_tbl 
order by f1;
     f1      | gt 
-------------+----
 -2147483647 |  0
     -123456 |  0
           0 |  1
      123456 |   
  2147483647 |   
             |   
(6 rows)

-- check some cases that were handled incorrectly in 8.3.0
explain (costs off)
  select distinct max(unique2) from tenk1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 HashAggregate
   Group By Key: $0
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
                 Index Cond: (unique2 IS NOT NULL)
   ->  Result
(7 rows)

select distinct max(unique2) from tenk1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by 1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: ($0)
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
                 Index Cond: (unique2 IS NOT NULL)
   ->  Result
(7 rows)

select max(unique2) from tenk1 order by 1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2);
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: ($0)
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
                 Index Cond: (unique2 IS NOT NULL)
   ->  Result
(7 rows)

select max(unique2) from tenk1 order by max(unique2);
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2)+1;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: (($0 + 1))
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
                 Index Cond: (unique2 IS NOT NULL)
   ->  Result
(7 rows)

select max(unique2) from tenk1 order by max(unique2)+1;
 max  
------
 9999
(1 row)

explain (costs off)
  select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
                             QUERY PLAN                              
---------------------------------------------------------------------
 Sort
   Sort Key: (generate_series(1, 3)) DESC
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan Backward using tenk1_unique2 on tenk1
                 Index Cond: (unique2 IS NOT NULL)
   ->  Result
(7 rows)

select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
 max  | g 
------+---
 9999 | 3
 9999 | 2
 9999 | 1
(3 rows)

-- try it on an inheritance tree
create table minmaxtest(f1 int);
create table minmaxtest1() inherits (minmaxtest);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table minmaxtest2() inherits (minmaxtest);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create table minmaxtest3() inherits (minmaxtest);
ERROR:  CREATE TABLE ... INHERITS is not yet supported.
create index minmaxtesti on minmaxtest(f1);
create index minmaxtest1i on minmaxtest1(f1);
ERROR:  relation "minmaxtest1" does not exist
create index minmaxtest2i on minmaxtest2(f1 desc);
ERROR:  relation "minmaxtest2" does not exist
create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
ERROR:  relation "minmaxtest3" does not exist
insert into minmaxtest values(11), (12);
insert into minmaxtest1 values(13), (14);
ERROR:  relation "minmaxtest1" does not exist on datanode1
LINE 1: insert into minmaxtest1 values(13), (14);
                    ^
insert into minmaxtest2 values(15), (16);
ERROR:  relation "minmaxtest2" does not exist on datanode1
LINE 1: insert into minmaxtest2 values(15), (16);
                    ^
insert into minmaxtest3 values(17), (18);
ERROR:  relation "minmaxtest3" does not exist on datanode1
LINE 1: insert into minmaxtest3 values(17), (18);
                    ^
explain (costs off)
  select min(f1), max(f1) from minmaxtest;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Result
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan using minmaxtesti on minmaxtest
                 Index Cond: (f1 IS NOT NULL)
   InitPlan 2 (returns $1)
     ->  Limit
           ->  Index Only Scan Backward using minmaxtesti on minmaxtest
                 Index Cond: (f1 IS NOT NULL)
(9 rows)

select min(f1), max(f1) from minmaxtest;
 min | max 
-----+-----
  11 |  12
(1 row)

-- DISTINCT doesn't do anything useful here, but it shouldn't fail
explain (costs off)
  select distinct min(f1), max(f1) from minmaxtest;
                               QUERY PLAN                               
------------------------------------------------------------------------
 HashAggregate
   Group By Key: $0, $1
   InitPlan 1 (returns $0)
     ->  Limit
           ->  Index Only Scan using minmaxtesti on minmaxtest
                 Index Cond: (f1 IS NOT NULL)
   InitPlan 2 (returns $1)
     ->  Limit
           ->  Index Only Scan Backward using minmaxtesti on minmaxtest
                 Index Cond: (f1 IS NOT NULL)
   ->  Result
(11 rows)

select distinct min(f1), max(f1) from minmaxtest;
 min | max 
-----+-----
  11 |  12
(1 row)

drop table minmaxtest cascade;
--
-- Test combinations of DISTINCT and/or ORDER BY
--
select array_agg(a order by b)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
 array_agg 
-----------
 {3,4,2,1}
(1 row)

select array_agg(a order by a)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
 array_agg 
-----------
 {1,2,3,4}
(1 row)

select array_agg(a order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
 array_agg 
-----------
 {4,3,2,1}
(1 row)

select array_agg(b order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
 array_agg 
-----------
 {2,1,3,4}
(1 row)

select array_agg(distinct a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
  array_agg   
--------------
 {1,2,3,NULL}
(1 row)

select array_agg(distinct a order by a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
  array_agg   
--------------
 {1,2,3,NULL}
(1 row)

select array_agg(distinct a order by a desc)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
  array_agg   
--------------
 {NULL,3,2,1}
(1 row)

select array_agg(distinct a order by a desc nulls last)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
  array_agg   
--------------
 {3,2,1,NULL}
(1 row)
 
-- string_agg tests
select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
   string_agg   
----------------
 aaaa,bbbb,cccc
(1 row)

explain (verbose, costs off) select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
                     QUERY PLAN                      
-----------------------------------------------------
 Aggregate
   Output: string_agg("*VALUES*".column1, ','::text)
   ->  Values Scan on "*VALUES*"
         Output: "*VALUES*".column1
(4 rows)

select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
   string_agg   
----------------
 aaaa,bbbb,cccc
(1 row)

select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
 string_agg 
------------
 bbbbABcccc
(1 row)

select string_agg(a,',') from (values(null),(null)) g(a);
 string_agg 
------------
 
(1 row)

-- check some implicit casting cases, as per bug #5564
select string_agg(distinct f1, ',') from varchar_tbl;  -- ok
 string_agg 
------------
 a,ab,abcd
(1 row)

explain (verbose, costs off) select string_agg(distinct f1, ',') from varchar_tbl;  -- ok
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   Output: string_agg(DISTINCT (f1)::text, ','::text)
   ->  Seq Scan on public.varchar_tbl
         Output: f1
(4 rows)

select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
 string_agg 
------------
 a,ab,abcd
(1 row)

explain (verbose, costs off) select string_agg(distinct f1, ',' order by f1) from varchar_tbl;  -- ok
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   Output: string_agg(DISTINCT (f1)::text, ','::text ORDER BY (f1)::text)
   ->  Seq Scan on public.varchar_tbl
         Output: f1
(4 rows)

select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;  -- not ok
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select string_agg(distinct f1::text, ',' order by f1) from v...
                                                          ^
CONTEXT:  referenced column: string_agg
select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;  -- not ok
ERROR:  in an aggregate with DISTINCT, ORDER BY expressions must appear in argument list
LINE 1: select string_agg(distinct f1, ',' order by f1::text) from v...
                                                    ^
CONTEXT:  referenced column: string_agg
select string_agg(distinct f1::text, ',') from varchar_tbl;  -- ok
 string_agg 
------------
 a,ab,abcd
(1 row)

explain (verbose, costs off) select string_agg(distinct f1::text, ',') from varchar_tbl;  -- ok
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   Output: string_agg(DISTINCT (f1)::text, ','::text)
   ->  Seq Scan on public.varchar_tbl
         Output: f1
(4 rows)

select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
 string_agg 
------------
 a,ab,abcd
(1 row)

explain (verbose, costs off) select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;  -- ok
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   Output: string_agg(DISTINCT (f1)::text, ','::text ORDER BY (f1)::text)
   ->  Seq Scan on public.varchar_tbl
         Output: f1
(4 rows)

-- string_agg bytea tests
create table bytea_test_table(v bytea);
select string_agg(v, '' order by v) from bytea_test_table;
 string_agg 
------------
 
(1 row)

insert into bytea_test_table values(decode('ff','hex'));
select string_agg(v, '' order by v) from bytea_test_table;
 string_agg 
------------
 \xff
(1 row)

insert into bytea_test_table values(decode('aa','hex'));
select string_agg(v, '' order by v) from bytea_test_table;
 string_agg 
------------
 \xaaff
(1 row)

explain (verbose, costs off) select string_agg(v, '' order by v) from bytea_test_table;
                   QUERY PLAN                    
-------------------------------------------------
 Aggregate
   Output: string_agg(v, NULL::bytea ORDER BY v)
   ->  Seq Scan on public.bytea_test_table
         Output: v
(4 rows)

select string_agg(v, NULL order by v) from bytea_test_table;
 string_agg 
------------
 \xaaff
(1 row)

select string_agg(v, decode('ee', 'hex') order by v) from bytea_test_table;
 string_agg 
------------
 \xaaeeff
(1 row)

drop table bytea_test_table;
DROP TABLE bitwise_test CASCADE;
DROP TABLE bool_test CASCADE;
create table string_agg_dn(cino int, addr text, post_cde text, valid_flag char, id int);
insert into string_agg_dn values(1,'haidian','0102568','1', 2);
insert into string_agg_dn values(2,'shangdi','0106568','2', 3);
insert into string_agg_dn values(3,'changping','0105888','5', 5);
insert into string_agg_dn values(4,'nanjing','0565888','6', 6);
insert into string_agg_dn values(5,'haidian','0211167','1', 8);
explain (verbose off, costs off)
select
	 cino, 
	 substr(string_agg(addr , ';') , 
	 0, 
	 length(string_agg(addr , ';') ) - 1) addr, 
	 substr(string_agg(a.post_cde , ';'), 
	 0, 
	 length(string_agg(post_cde , ';')) - 1)  post_cde 
from (select cino, 
			
			replace(addr, CHR(13) || CHR(10),'') addr, 
			post_cde 
			from 
			( 
			select cino,addr,post_cde, 
			ROW_NUMBER() OVER(PARTITION BY cino order by cino) rn 
			 from (select cino, addr, post_cde 
			   from string_agg_dn where valid_flag='1' 
			   group by cino, addr, post_cde) 
			  ) 
	 where rn < 7) a 
group by cino; 
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 GroupAggregate
   Group By Key: __unnamed_subquery__.cino
   ->  Subquery Scan on __unnamed_subquery__
         Filter: (__unnamed_subquery__.rn < 7)
         ->  WindowAgg
               ->  Sort
                     Sort Key: string_agg_dn.cino
                     ->  HashAggregate
                           Group By Key: string_agg_dn.cino, string_agg_dn.addr, string_agg_dn.post_cde
                           ->  Seq Scan on string_agg_dn
                                 Filter: (valid_flag = '1'::bpchar)
(11 rows)

select
	 cino, 
	 substr(string_agg(addr , ';') , 
	 0, 
	 length(string_agg(addr , ';') ) - 1) addr, 
	 substr(string_agg(a.post_cde , ';'), 
	 0, 
	 length(string_agg(post_cde , ';')) - 1)  post_cde 
from (select cino, 
			
			replace(addr, CHR(13) || CHR(10),'') addr, 
			post_cde 
			from 
			( 
			select cino,addr,post_cde, 
			ROW_NUMBER() OVER(PARTITION BY cino order by cino) rn 
			 from (select cino, addr, post_cde 
			   from string_agg_dn where valid_flag='1' 
			   group by cino, addr, post_cde) 
			  ) 
	 where rn < 7) a 
group by cino order by cino;
 cino |  addr  | post_cde 
------+--------+----------
    1 | haidia | 010256
    5 | haidia | 021116
(2 rows)

select string_agg(addr, ';') from string_agg_dn;
                string_agg                 
-------------------------------------------
 haidian;shangdi;changping;nanjing;haidian
(1 row)

explain (verbose, costs off) select string_agg(addr, ';') from string_agg_dn;
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   Output: string_agg(addr, ';'::text)
   ->  Seq Scan on public.string_agg_dn
         Output: cino, addr, post_cde, valid_flag, id
(4 rows)

select string_agg(addr, ';' order by cino) from string_agg_dn;
                string_agg                 
-------------------------------------------
 haidian;shangdi;changping;nanjing;haidian
(1 row)

explain (verbose, costs off) select string_agg(addr, ';' order by cino) from string_agg_dn;
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   Output: string_agg(addr, ';'::text ORDER BY cino)
   ->  Seq Scan on public.string_agg_dn
         Output: cino, addr, post_cde, valid_flag, id
(4 rows)

select string_agg(addr, ';') from string_agg_dn where valid_flag='5' group by cino;
 string_agg 
------------
 changping
(1 row)

explain (verbose, costs off) select string_agg(addr, ';') from string_agg_dn where valid_flag='5' group by cino;
                        QUERY PLAN                        
----------------------------------------------------------
 HashAggregate
   Output: string_agg(addr, ';'::text), cino
   Group By Key: string_agg_dn.cino
   ->  Seq Scan on public.string_agg_dn
         Output: cino, addr
         Filter: (string_agg_dn.valid_flag = '5'::bpchar)
(6 rows)

select string_agg(cino, ';') from string_agg_dn where valid_flag='5' group by cino;
 string_agg 
------------
 3
(1 row)

explain (verbose, costs off) select string_agg(cino, ';') from string_agg_dn where valid_flag='5' group by id;
                        QUERY PLAN                        
----------------------------------------------------------
 HashAggregate
   Output: string_agg((cino)::text, ';'::text), id
   Group By Key: string_agg_dn.id
   ->  Seq Scan on public.string_agg_dn
         Output: id, cino
         Filter: (string_agg_dn.valid_flag = '5'::bpchar)
(6 rows)

select cino from string_agg_dn group by cino order by cino;
 cino 
------
    1
    2
    3
    4
    5
(5 rows)

explain (verbose, costs off) select cino from string_agg_dn group by cino order by cino;
                  QUERY PLAN                  
----------------------------------------------
 Sort
   Output: cino
   Sort Key: string_agg_dn.cino
   ->  HashAggregate
         Output: cino
         Group By Key: string_agg_dn.cino
         ->  Seq Scan on public.string_agg_dn
               Output: cino
(8 rows)

select max(id) from string_agg_dn having string_agg(cino, ';' order by cino) = '1;2;3;4;5';
 max 
-----
   8
(1 row)

explain (verbose, costs off) select max(id) from string_agg_dn having string_agg(cino, ';' order by cino) = '1;2;3;4;5';
                                                      QUERY PLAN                                                       
-----------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: max(id)
   Filter: (string_agg((string_agg_dn.cino)::text, ';'::text ORDER BY (string_agg_dn.cino)::text) = '1;2;3;4;5'::text)
   ->  Seq Scan on public.string_agg_dn
         Output: cino, addr, post_cde, valid_flag, id
(5 rows)

select string_agg(addr, ';'order by addr) from string_agg_dn  group by valid_flag order by 1;
   string_agg    
-----------------
 changping
 haidian;haidian
 nanjing
 shangdi
(4 rows)

explain (verbose, costs off) select string_agg(addr, ';'order by addr) from string_agg_dn  group by valid_flag;
                           QUERY PLAN                            
-----------------------------------------------------------------
 GroupAggregate
   Output: string_agg(addr, ';'::text ORDER BY addr), valid_flag
   Group By Key: string_agg_dn.valid_flag
   ->  Sort
         Output: valid_flag, addr
         Sort Key: string_agg_dn.valid_flag
         ->  Seq Scan on public.string_agg_dn
               Output: valid_flag, addr
(8 rows)

select string_agg(distinct addr, ';'order by addr) from string_agg_dn  group by valid_flag order by 1;
 string_agg 
------------
 changping
 haidian
 nanjing
 shangdi
(4 rows)

explain (verbose, costs off) select string_agg(distinct addr, ';'order by addr) from string_agg_dn  group by valid_flag;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 GroupAggregate
   Output: string_agg(DISTINCT addr, ';'::text ORDER BY addr), valid_flag
   Group By Key: string_agg_dn.valid_flag
   ->  Sort
         Output: valid_flag, addr
         Sort Key: string_agg_dn.valid_flag
         ->  Seq Scan on public.string_agg_dn
               Output: valid_flag, addr
(8 rows)

select string_agg(t1.cino,','order by t1.cino) from string_agg_dn t1,string_agg_dn t2 where t1.id=t2.id;
 string_agg 
------------
 1,2,3,4,5
(1 row)

explain (verbose, costs off) select string_agg(t1.cino,','order by t1.cino) from string_agg_dn t1,string_agg_dn t2 where t1.id=t2.id;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Aggregate
   Output: string_agg((t1.cino)::text, ','::text ORDER BY (t1.cino)::text)
   ->  Hash Join
         Output: t1.cino
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on public.string_agg_dn t1
               Output: t1.cino, t1.addr, t1.post_cde, t1.valid_flag, t1.id
         ->  Hash
               Output: t2.id
               ->  Seq Scan on public.string_agg_dn t2
                     Output: t2.id
(11 rows)

drop table string_agg_dn;
create table string_agg_dn_col(c1 int, c2 text) with (orientation = column);
insert into string_agg_dn_col values(1, 'test');
select c1, string_agg(c2,',') from string_agg_dn_col group by c1;
 c1 | string_agg 
----+------------
  1 | test
(1 row)

explain (verbose, costs off) select c1, string_agg(c2,',') from string_agg_dn_col group by c1;
                     QUERY PLAN                      
-----------------------------------------------------
 HashAggregate
   Output: c1, string_agg(c2, ','::text)
   Group By Key: string_agg_dn_col.c1
   ->  Row Adapter
         Output: c1, c2
         ->  CStore Scan on public.string_agg_dn_col
               Output: c1, c2
(7 rows)

drop table string_agg_dn_col;
create table string_agg_dn_dk_null(c1 int, c2 text, c3 regproc);
insert into string_agg_dn_dk_null values(1, 'test', 'sin');
select c3, string_agg(c2, ',') from string_agg_dn_dk_null group by c3;
 c3  | string_agg 
-----+------------
 sin | test
(1 row)

explain (verbose, costs off) select c3, string_agg(c2, ',') from string_agg_dn_dk_null group by c3;
                   QUERY PLAN                   
------------------------------------------------
 HashAggregate
   Output: c3, string_agg(c2, ','::text)
   Group By Key: string_agg_dn_dk_null.c3
   ->  Seq Scan on public.string_agg_dn_dk_null
         Output: c3, c2
(5 rows)

drop table string_agg_dn_dk_null;
-- test non-collection agg functions
create table t_collection(a1 int, b1 int, c1 int, d1 int);
insert into t_collection select generate_series(1, 100)%8, generate_series(1, 100)%7, generate_series(1, 100)%6, generate_series(1, 100)%5;
analyze t_collection;
-- normal
explain (costs off, verbose on)
select array_length(array_agg(d1), 1) from t_collection;
                QUERY PLAN                
------------------------------------------
 Aggregate
   Output: array_length(array_agg(d1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(d1), 1) from t_collection;
 array_length 
--------------
          100
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(d1), 1) from t_collection group by b1 order by 1;
                        QUERY PLAN                         
-----------------------------------------------------------
 Sort
   Output: (array_length(array_agg(d1), 1)), b1
   Sort Key: (array_length(array_agg(t_collection.d1), 1))
   ->  HashAggregate
         Output: array_length(array_agg(d1), 1), b1
         Group By Key: t_collection.b1
         ->  Seq Scan on public.t_collection
               Output: b1, d1
(8 rows)

select array_length(array_agg(d1), 1) from t_collection group by b1 order by 1;
 array_length 
--------------
           14
           14
           14
           14
           14
           15
           15
(7 rows)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1) from t_collection;
                    QUERY PLAN                     
---------------------------------------------------
 Aggregate
   Output: array_length(array_agg(DISTINCT d1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(distinct d1), 1) from t_collection;
 array_length 
--------------
            5
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1) from t_collection group by b1 order by 1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(DISTINCT d1), 1)), b1
   Sort Key: (array_length(array_agg(DISTINCT t_collection.d1), 1))
   ->  GroupAggregate
         Output: array_length(array_agg(DISTINCT d1), 1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1
(11 rows)

select array_length(array_agg(distinct d1), 1) from t_collection group by b1 order by 1;
 array_length 
--------------
            5
            5
            5
            5
            5
            5
            5
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':') from t_collection;
                           QUERY PLAN                            
-----------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(d1 order by d1), ':') from t_collection;
                                                                                             array_to_string                                                                                             
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':') from t_collection group by b1 order by 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(d1 ORDER BY d1), ':'::text)), b1
   Sort Key: (array_to_string(array_agg(t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1
(11 rows)

select array_to_string(array_agg(d1 order by d1), ':') from t_collection group by b1 order by 1;
        array_to_string        
-------------------------------
 0:0:0:1:1:1:2:2:2:3:3:3:4:4
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4
 0:0:0:1:1:1:2:2:2:3:3:4:4:4
 0:0:0:1:1:1:2:2:3:3:3:4:4:4
 0:0:0:1:1:2:2:2:3:3:3:4:4:4
 0:0:1:1:1:2:2:2:3:3:3:4:4:4
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':') from t_collection;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':') from t_collection;
 array_to_string 
-----------------
 0:1:2:3:4
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':') from t_collection group by b1 order by 1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text)), b1
   Sort Key: (array_to_string(array_agg(DISTINCT t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1
(11 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':') from t_collection group by b1 order by 1;
 array_to_string 
-----------------
 0:1:2:3:4
 0:1:2:3:4
 0:1:2:3:4
 0:1:2:3:4
 0:1:2:3:4
 0:1:2:3:4
 0:1:2:3:4
(7 rows)

-- count(distinct)
explain (costs off, verbose on)
select array_length(array_agg(d1), 1), count(distinct(c1)) from t_collection;
                          QUERY PLAN                          
--------------------------------------------------------------
 Aggregate
   Output: array_length(array_agg(d1), 1), count(DISTINCT c1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(d1), 1), count(distinct(c1)) from t_collection;
 array_length | count 
--------------+-------
          100 |     6
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(d1), 1), count(distinct(c1)) from t_collection group by b1 order by 1;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(d1), 1)), (count(DISTINCT c1)), b1
   Sort Key: (array_length(array_agg(t_collection.d1), 1))
   ->  GroupAggregate
         Output: array_length(array_agg(d1), 1), count(DISTINCT c1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_length(array_agg(d1), 1), count(distinct(c1)) from t_collection group by b1 order by 1;
 array_length | count 
--------------+-------
           14 |     6
           14 |     6
           14 |     6
           14 |     6
           14 |     6
           15 |     6
           15 |     6
(7 rows)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1), count(distinct(c1)) from t_collection;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Aggregate
   Output: array_length(array_agg(DISTINCT d1), 1), count(DISTINCT c1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(distinct d1), 1), count(distinct(c1)) from t_collection;
 array_length | count 
--------------+-------
            5 |     6
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1), count(distinct(c1)) from t_collection group by b1 order by 1;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(DISTINCT d1), 1)), (count(DISTINCT c1)), b1
   Sort Key: (array_length(array_agg(DISTINCT t_collection.d1), 1))
   ->  GroupAggregate
         Output: array_length(array_agg(DISTINCT d1), 1), count(DISTINCT c1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_length(array_agg(distinct d1), 1), count(distinct(c1)) from t_collection group by b1 order by 1;
 array_length | count 
--------------+-------
            5 |     6
            5 |     6
            5 |     6
            5 |     6
            5 |     6
            5 |     6
            5 |     6
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':'), count(distinct(c1)) from t_collection;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text), count(DISTINCT c1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(d1 order by d1), ':'), count(distinct(c1)) from t_collection;
                                                                                             array_to_string                                                                                             | count 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------
 0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4 |     6
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':'), count(distinct(c1)) from t_collection group by b1 order by 1;
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(d1 ORDER BY d1), ':'::text)), (count(DISTINCT c1)), b1
   Sort Key: (array_to_string(array_agg(t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text), count(DISTINCT c1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_to_string(array_agg(d1 order by d1), ':'), count(distinct(c1)) from t_collection group by b1 order by 1;
        array_to_string        | count 
-------------------------------+-------
 0:0:0:1:1:1:2:2:2:3:3:3:4:4   |     6
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4 |     6
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4 |     6
 0:0:0:1:1:1:2:2:2:3:3:4:4:4   |     6
 0:0:0:1:1:1:2:2:3:3:3:4:4:4   |     6
 0:0:0:1:1:2:2:2:3:3:3:4:4:4   |     6
 0:0:1:1:1:2:2:2:3:3:3:4:4:4   |     6
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':'), count(distinct(c1)) from t_collection;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text), count(DISTINCT c1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':'), count(distinct(c1)) from t_collection;
 array_to_string | count 
-----------------+-------
 0:1:2:3:4       |     6
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':'), count(distinct(c1)) from t_collection group by b1 order by 1;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text)), (count(DISTINCT c1)), b1
   Sort Key: (array_to_string(array_agg(DISTINCT t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text), count(DISTINCT c1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':'), count(distinct(c1)) from t_collection group by b1 order by 1;
 array_to_string | count 
-----------------+-------
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
 0:1:2:3:4       |     6
(7 rows)

-- multi non-collection agg
explain (costs off, verbose on)
select array_length(array_agg(d1), 1), array_length(array_agg(distinct c1), 1) from t_collection;
                                    QUERY PLAN                                     
-----------------------------------------------------------------------------------
 Aggregate
   Output: array_length(array_agg(d1), 1), array_length(array_agg(DISTINCT c1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(d1), 1), array_length(array_agg(distinct c1), 1) from t_collection;
 array_length | array_length 
--------------+--------------
          100 |            6
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(d1), 1), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(d1), 1)), (array_length(array_agg(DISTINCT c1), 1)), b1
   Sort Key: (array_length(array_agg(t_collection.d1), 1))
   ->  GroupAggregate
         Output: array_length(array_agg(d1), 1), array_length(array_agg(DISTINCT c1), 1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_length(array_agg(d1), 1), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
 array_length | array_length 
--------------+--------------
           14 |            6
           14 |            6
           14 |            6
           14 |            6
           14 |            6
           15 |            6
           15 |            6
(7 rows)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1), array_length(array_agg(distinct c1), 1) from t_collection;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Aggregate
   Output: array_length(array_agg(DISTINCT d1), 1), array_length(array_agg(DISTINCT c1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_length(array_agg(distinct d1), 1), array_length(array_agg(distinct c1), 1) from t_collection;
 array_length | array_length 
--------------+--------------
            5 |            6
(1 row)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(DISTINCT d1), 1)), (array_length(array_agg(DISTINCT c1), 1)), b1
   Sort Key: (array_length(array_agg(DISTINCT t_collection.d1), 1))
   ->  GroupAggregate
         Output: array_length(array_agg(DISTINCT d1), 1), array_length(array_agg(DISTINCT c1), 1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_length(array_agg(distinct d1), 1), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
 array_length | array_length 
--------------+--------------
            5 |            6
            5 |            6
            5 |            6
            5 |            6
            5 |            6
            5 |            6
            5 |            6
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text), array_length(array_agg(DISTINCT c1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection;
                                                                                             array_to_string                                                                                             | array_length 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------
 0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:1:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:2:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:3:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4:4 |            6
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(d1 ORDER BY d1), ':'::text)), (array_length(array_agg(DISTINCT c1), 1)), b1
   Sort Key: (array_to_string(array_agg(t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(d1 ORDER BY d1), ':'::text), array_length(array_agg(DISTINCT c1), 1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_to_string(array_agg(d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
        array_to_string        | array_length 
-------------------------------+--------------
 0:0:0:1:1:1:2:2:2:3:3:3:4:4   |            6
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4 |            6
 0:0:0:1:1:1:2:2:2:3:3:3:4:4:4 |            6
 0:0:0:1:1:1:2:2:2:3:3:4:4:4   |            6
 0:0:0:1:1:1:2:2:3:3:3:4:4:4   |            6
 0:0:0:1:1:2:2:2:3:3:3:4:4:4   |            6
 0:0:1:1:1:2:2:2:3:3:3:4:4:4   |            6
(7 rows)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Aggregate
   Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text), array_length(array_agg(DISTINCT c1), 1)
   ->  Seq Scan on public.t_collection
         Output: a1, b1, c1, d1
(4 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection;
 array_to_string | array_length 
-----------------+--------------
 0:1:2:3:4       |            6
(1 row)

explain (costs off, verbose on)
select array_to_string(array_agg(distinct d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: (array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text)), (array_length(array_agg(DISTINCT c1), 1)), b1
   Sort Key: (array_to_string(array_agg(DISTINCT t_collection.d1 ORDER BY t_collection.d1), ':'::text))
   ->  GroupAggregate
         Output: array_to_string(array_agg(DISTINCT d1 ORDER BY d1), ':'::text), array_length(array_agg(DISTINCT c1), 1), b1
         Group By Key: t_collection.b1
         ->  Sort
               Output: b1, d1, c1
               Sort Key: t_collection.b1
               ->  Seq Scan on public.t_collection
                     Output: b1, d1, c1
(11 rows)

select array_to_string(array_agg(distinct d1 order by d1), ':'), array_length(array_agg(distinct c1), 1) from t_collection group by b1 order by 1;
 array_to_string | array_length 
-----------------+--------------
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
 0:1:2:3:4       |            6
(7 rows)

select array_to_string(ARRAY[NULL, NULL, NULL, NULL, NULL], ',', NULL) is null;
 ?column? 
----------
 t
(1 row)

SELECT array_to_string(ARRAY[NULL, NULL, NULL, NULL, NULL], ',') is null;
 ?column? 
----------
 t
(1 row)

-- grouping sets
explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1) from t_collection group by rollup(a1) order by a1;  -- can't push down
                         QUERY PLAN                          
-------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(DISTINCT d1), 1)), a1
   Sort Key: t_collection.a1
   ->  GroupAggregate
         Output: array_length(array_agg(DISTINCT d1), 1), a1
         Group By Key: t_collection.a1
         Group By Key: ()
         ->  Sort
               Output: a1, d1
               Sort Key: t_collection.a1
               ->  Seq Scan on public.t_collection
                     Output: a1, d1
(12 rows)

select array_length(array_agg(distinct d1), 1) from t_collection group by rollup(a1) order by a1;  -- can't push down
 array_length 
--------------
            5
            5
            5
            5
            5
            5
            5
            5
            5
(9 rows)

explain (costs off, verbose on)
select array_length(array_agg(distinct d1), 1) from t_collection group by rollup(a1), c1 order by a1, c1; -- can push down
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Output: (array_length(array_agg(DISTINCT d1), 1)), a1, c1
   Sort Key: t_collection.a1, t_collection.c1
   ->  GroupAggregate
         Output: array_length(array_agg(DISTINCT d1), 1), a1, c1
         Group By Key: t_collection.c1, t_collection.a1
         Group By Key: t_collection.c1
         ->  Sort
               Output: a1, c1, d1
               Sort Key: t_collection.c1, t_collection.a1
               ->  Seq Scan on public.t_collection
                     Output: a1, c1, d1
(12 rows)

select array_length(array_agg(distinct d1), 1) from t_collection group by rollup(a1), c1 order by a1, c1; -- can push down
 array_length 
--------------
            4
            4
            4
            5
            4
            4
            4
            5
            4
            4
            5
            4
            4
            4
            5
            4
            4
            4
            4
            4
            4
            4
            4
            4
            5
            5
            5
            5
            5
            5
(30 rows)

explain (costs off, verbose on)
select array_agg(distinct d1 order by d1) from t_collection group by rollup(a1), c1 order by a1, c1; -- can push down
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Output: (array_agg(DISTINCT d1 ORDER BY d1)), a1, c1
   Sort Key: t_collection.a1, t_collection.c1
   ->  GroupAggregate
         Output: array_agg(DISTINCT d1 ORDER BY d1), a1, c1
         Group By Key: t_collection.c1, t_collection.a1
         Group By Key: t_collection.c1
         ->  Sort
               Output: a1, c1, d1
               Sort Key: t_collection.c1, t_collection.a1
               ->  Seq Scan on public.t_collection
                     Output: a1, c1, d1
(12 rows)

select array_agg(distinct d1 order by d1) from t_collection group by rollup(a1), c1 order by a1, c1; -- can push down
  array_agg  
-------------
 {1,2,3,4}
 {0,1,2,3}
 {0,1,3,4}
 {0,1,2,3,4}
 {1,2,3,4}
 {0,1,2,4}
 {0,1,2,3}
 {0,1,2,3,4}
 {0,2,3,4}
 {1,2,3,4}
 {0,1,2,3,4}
 {0,1,3,4}
 {0,1,2,4}
 {0,2,3,4}
 {0,1,2,3,4}
 {0,1,2,3}
 {0,1,3,4}
 {0,2,3,4}
 {0,1,3,4}
 {1,2,3,4}
 {0,1,2,4}
 {0,1,2,4}
 {0,2,3,4}
 {0,1,2,3}
 {0,1,2,3,4}
 {0,1,2,3,4}
 {0,1,2,3,4}
 {0,1,2,3,4}
 {0,1,2,3,4}
 {0,1,2,3,4}
(30 rows)

explain (costs off, verbose on)
select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by grouping sets(c1, d1) order by c1, d1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Output: c1, d1, (length(string_agg(DISTINCT (b1)::text, 'x'::text)))
   Sort Key: t_collection.c1, t_collection.d1
   ->  GroupAggregate
         Output: c1, d1, length(string_agg(DISTINCT (b1)::text, 'x'::text))
         Group By Key: t_collection.c1
         Sort Key: t_collection.d1
           Group By Key: t_collection.d1
         ->  Sort
               Output: c1, d1, b1
               Sort Key: t_collection.c1
               ->  Seq Scan on public.t_collection
                     Output: c1, d1, b1
(13 rows)

select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by grouping sets(c1, d1) order by c1, d1;
 c1 | d1 | length 
----+----+--------
  0 |    |     13
  1 |    |     13
  2 |    |     13
  3 |    |     13
  4 |    |     13
  5 |    |     13
    |  0 |     13
    |  1 |     13
    |  2 |     13
    |  3 |     13
    |  4 |     13
(11 rows)

explain (costs off, verbose on)
select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by grouping sets((c1, d1)) order by c1, d1;
                              QUERY PLAN                              
----------------------------------------------------------------------
 GroupAggregate
   Output: c1, d1, length(string_agg(DISTINCT (b1)::text, 'x'::text))
   Group By Key: t_collection.c1, t_collection.d1
   ->  Sort
         Output: c1, d1, b1
         Sort Key: t_collection.c1, t_collection.d1
         ->  Seq Scan on public.t_collection
               Output: c1, d1, b1
(8 rows)

select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by grouping sets((c1, d1)) order by c1, d1;
 c1 | d1 | length 
----+----+--------
  0 |  0 |      5
  0 |  1 |      7
  0 |  2 |      5
  0 |  3 |      5
  0 |  4 |      5
  1 |  0 |      5
  1 |  1 |      7
  1 |  2 |      7
  1 |  3 |      5
  1 |  4 |      5
  2 |  0 |      5
  2 |  1 |      5
  2 |  2 |      7
  2 |  3 |      7
  2 |  4 |      5
  3 |  0 |      5
  3 |  1 |      5
  3 |  2 |      5
  3 |  3 |      7
  3 |  4 |      7
  4 |  0 |      7
  4 |  1 |      5
  4 |  2 |      5
  4 |  3 |      5
  4 |  4 |      7
  5 |  0 |      7
  5 |  1 |      5
  5 |  2 |      5
  5 |  3 |      5
  5 |  4 |      5
(30 rows)

explain (costs off, verbose on)
select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by cube(c1, d1) order by c1, d1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Output: c1, d1, (length(string_agg(DISTINCT (b1)::text, 'x'::text)))
   Sort Key: t_collection.c1, t_collection.d1
   ->  GroupAggregate
         Output: c1, d1, length(string_agg(DISTINCT (b1)::text, 'x'::text))
         Group By Key: t_collection.c1, t_collection.d1
         Group By Key: t_collection.c1
         Group By Key: ()
         Sort Key: t_collection.d1
           Group By Key: t_collection.d1
         ->  Sort
               Output: c1, d1, b1
               Sort Key: t_collection.c1, t_collection.d1
               ->  Seq Scan on public.t_collection
                     Output: c1, d1, b1
(15 rows)

select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by cube(c1, d1) order by c1, d1;
 c1 | d1 | length 
----+----+--------
  0 |  0 |      5
  0 |  1 |      7
  0 |  2 |      5
  0 |  3 |      5
  0 |  4 |      5
  0 |    |     13
  1 |  0 |      5
  1 |  1 |      7
  1 |  2 |      7
  1 |  3 |      5
  1 |  4 |      5
  1 |    |     13
  2 |  0 |      5
  2 |  1 |      5
  2 |  2 |      7
  2 |  3 |      7
  2 |  4 |      5
  2 |    |     13
  3 |  0 |      5
  3 |  1 |      5
  3 |  2 |      5
  3 |  3 |      7
  3 |  4 |      7
  3 |    |     13
  4 |  0 |      7
  4 |  1 |      5
  4 |  2 |      5
  4 |  3 |      5
  4 |  4 |      7
  4 |    |     13
  5 |  0 |      7
  5 |  1 |      5
  5 |  2 |      5
  5 |  3 |      5
  5 |  4 |      5
  5 |    |     13
    |  0 |     13
    |  1 |     13
    |  2 |     13
    |  3 |     13
    |  4 |     13
    |    |     13
(42 rows)

explain (costs off, verbose on)
select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by cube(c1), d1 order by c1, d1;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Output: c1, d1, (length(string_agg(DISTINCT (b1)::text, 'x'::text)))
   Sort Key: t_collection.c1, t_collection.d1
   ->  GroupAggregate
         Output: c1, d1, length(string_agg(DISTINCT (b1)::text, 'x'::text))
         Group By Key: t_collection.d1, t_collection.c1
         Group By Key: t_collection.d1
         ->  Sort
               Output: c1, d1, b1
               Sort Key: t_collection.d1, t_collection.c1
               ->  Seq Scan on public.t_collection
                     Output: c1, d1, b1
(12 rows)

select c1, d1, length(string_agg(distinct b1, 'x')) from t_collection group by cube(c1), d1 order by c1, d1;
 c1 | d1 | length 
----+----+--------
  0 |  0 |      5
  0 |  1 |      7
  0 |  2 |      5
  0 |  3 |      5
  0 |  4 |      5
  1 |  0 |      5
  1 |  1 |      7
  1 |  2 |      7
  1 |  3 |      5
  1 |  4 |      5
  2 |  0 |      5
  2 |  1 |      5
  2 |  2 |      7
  2 |  3 |      7
  2 |  4 |      5
  3 |  0 |      5
  3 |  1 |      5
  3 |  2 |      5
  3 |  3 |      7
  3 |  4 |      7
  4 |  0 |      7
  4 |  1 |      5
  4 |  2 |      5
  4 |  3 |      5
  4 |  4 |      7
  5 |  0 |      7
  5 |  1 |      5
  5 |  2 |      5
  5 |  3 |      5
  5 |  4 |      5
    |  0 |     13
    |  1 |     13
    |  2 |     13
    |  3 |     13
    |  4 |     13
(35 rows)

drop table t_collection;
explain (verbose, costs off)
select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Function Scan on pg_catalog.generate_series x
   Output: (SubPlan 1)
   Function Call: generate_series(1, 3)
   SubPlan 1
     ->  Sort
           Output: (sum(($0 + y.y))), y.y
           Sort Key: (sum(($0 + y.y)))
           ->  HashAggregate
                 Output: sum((x.x + y.y)), y.y
                 Group By Key: y.y
                 ->  Function Scan on pg_catalog.generate_series y
                       Output: y.y
                       Function Call: generate_series(1, 3)
(13 rows)

select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
  array  
---------
 {2,3,4}
 {3,4,5}
 {4,5,6}
(3 rows)

create table t_fqs_abs (a int, b int, c int, d int);
insert into t_fqs_abs values (1,1,1,1);
insert into t_fqs_abs values (2,2,2,2);
insert into t_fqs_abs values (3,3,3,3);
explain (costs off, verbose on)
SELECT abs(a)
    , abs(a) + sum(b)
FROM t_fqs_abs
GROUP BY 1;
               QUERY PLAN                
-----------------------------------------
 HashAggregate
   Output: (abs(a)), ((abs(a)) + sum(b))
   Group By Key: abs(t_fqs_abs.a)
   ->  Seq Scan on public.t_fqs_abs
         Output: abs(a), a, b
(5 rows)

SELECT abs(a)
    , abs(a) + sum(b)
FROM t_fqs_abs
GROUP BY 1
order by 1,2;
 abs | ?column? 
-----+----------
   1 |        2
   2 |        4
   3 |        6
(3 rows)

drop table t_fqs_abs;
-- subplan in agg qual
create table agg_qual(a int, b varchar(10));
set enable_sort=off;
explain (costs off) select b in (select 'g' from agg_qual group by 1) from agg_qual group by 1 having b in (select 'g' from agg_qual group by 1);
                QUERY PLAN                
------------------------------------------
 HashAggregate
   Group By Key: (hashed SubPlan 1)
   Filter: (hashed SubPlan 2)
   ->  Seq Scan on agg_qual
         SubPlan 1
           ->  HashAggregate
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
   SubPlan 2
     ->  HashAggregate
           Group By Key: 'g'::text
           ->  Seq Scan on agg_qual
(12 rows)

explain (costs off) select 1,b in (select 'g' from agg_qual group by 1) from agg_qual group by 1, 2 having b in (select 'g' from agg_qual group by 1);
                QUERY PLAN                
------------------------------------------
 HashAggregate
   Group By Key: 1, (hashed SubPlan 1)
   Filter: (hashed SubPlan 2)
   ->  Seq Scan on agg_qual
         SubPlan 1
           ->  HashAggregate
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
   SubPlan 2
     ->  HashAggregate
           Group By Key: 'g'::text
           ->  Seq Scan on agg_qual
(12 rows)

explain (costs off) select 1,b in (select 'g' from agg_qual group by 1),count(distinct(a)) from agg_qual group by 1, 2 having b in (select 'g' from agg_qual group by 1);
                   QUERY PLAN                   
------------------------------------------------
 GroupAggregate
   Group By Key: (1), ((hashed SubPlan 1))
   Filter: (hashed SubPlan 2)
   ->  Sort
         Sort Key: (1), ((hashed SubPlan 1))
         ->  Seq Scan on agg_qual
               SubPlan 1
                 ->  HashAggregate
                       Group By Key: 'g'::text
                       ->  Seq Scan on agg_qual
   SubPlan 2
     ->  HashAggregate
           Group By Key: 'g'::text
           ->  Seq Scan on agg_qual
(14 rows)

explain (costs off) select 1,b in (select 'g' from agg_qual group by 1),count(distinct(b)) from agg_qual group by 1, 2 having b in (select 'g' from agg_qual group by 1);
                   QUERY PLAN                   
------------------------------------------------
 GroupAggregate
   Group By Key: (1), ((hashed SubPlan 1))
   Filter: (hashed SubPlan 2)
   ->  Sort
         Sort Key: (1), ((hashed SubPlan 1))
         ->  Seq Scan on agg_qual
               SubPlan 1
                 ->  HashAggregate
                       Group By Key: 'g'::text
                       ->  Seq Scan on agg_qual
   SubPlan 2
     ->  HashAggregate
           Group By Key: 'g'::text
           ->  Seq Scan on agg_qual
(14 rows)

explain (costs off) select 1,a+5,count(distinct(b)) from agg_qual group by 1, 2 having max(b) in (select 'g' from agg_qual group by 1);
                    QUERY PLAN                    
--------------------------------------------------
 GroupAggregate
   Group By Key: (1), ((public.agg_qual.a + 5))
   Filter: (hashed SubPlan 1)
   ->  Sort
         Sort Key: (1), ((public.agg_qual.a + 5))
         ->  Seq Scan on agg_qual
   SubPlan 1
     ->  HashAggregate
           Group By Key: 'g'::text
           ->  Seq Scan on agg_qual
(10 rows)

explain (costs off)
select 1
from (
 select b c1, case when b in (
   select 'g' from agg_qual 
   group by 1) then 'e' else a::text end c2, max(5)
 from agg_qual 
 group by 1,2) temp1
where temp1.c2=temp1.c1;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on temp1
   ->  HashAggregate
         Group By Key: public.agg_qual.b, CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE (public.agg_qual.a)::text END
         Filter: (CASE WHEN (hashed SubPlan 2) THEN 'e'::text ELSE (public.agg_qual.a)::text END = (public.agg_qual.b)::text)
         ->  Seq Scan on agg_qual
               SubPlan 1
                 ->  HashAggregate
                       Group By Key: 'g'::text
                       ->  Seq Scan on agg_qual
         SubPlan 2
           ->  HashAggregate
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
(13 rows)

set enable_hashagg=off;
set enable_sort=on;
explain (costs off)
select 1
from (
 select 1 c1, case when b in (
   select 'g' from agg_qual 
   group by 1) then 'e' end c2, count(distinct(a)), max(5)
 from agg_qual 
 group by 1,2) temp1
where temp1.c2=temp1.c1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on temp1
   ->  GroupAggregate
         Group By Key: (1), (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
         Filter: ((CASE WHEN (hashed SubPlan 2) THEN 'e'::text ELSE NULL::text END)::bigint = 1)
         ->  Sort
               Sort Key: (1), (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
               ->  Seq Scan on agg_qual
                     SubPlan 1
                       ->  Group
                             Group By Key: 'g'::text
                             ->  Seq Scan on agg_qual
         SubPlan 2
           ->  Group
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
(15 rows)

explain (costs off)
select 1
from (
 select 1 c1, case when b in (
   select 'g' from agg_qual 
   group by 1) then 'e' end c2, max(5)
 from agg_qual 
 group by 1,2) temp1
where temp1.c2=temp1.c1;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on temp1
   ->  GroupAggregate
         Group By Key: (1), (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
         Filter: ((CASE WHEN (hashed SubPlan 2) THEN 'e'::text ELSE NULL::text END)::bigint = 1)
         ->  Sort
               Sort Key: (1), (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
               ->  Seq Scan on agg_qual
                     SubPlan 1
                       ->  Group
                             Group By Key: 'g'::text
                             ->  Seq Scan on agg_qual
         SubPlan 2
           ->  Group
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
(15 rows)

explain (costs off)
select 1
from (
 select b c1, case when b in (
   select 'g' from agg_qual 
   group by 1) then 'e' end c2, max(5)
 from agg_qual 
 group by 1,2) temp1
where temp1.c2=temp1.c1;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Subquery Scan on temp1
   ->  GroupAggregate
         Group By Key: public.agg_qual.b, (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
         Filter: (CASE WHEN (hashed SubPlan 2) THEN 'e'::text ELSE NULL::text END = (public.agg_qual.b)::text)
         ->  Sort
               Sort Key: public.agg_qual.b, (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE NULL::text END)
               ->  Seq Scan on agg_qual
                     SubPlan 1
                       ->  Group
                             Group By Key: 'g'::text
                             ->  Seq Scan on agg_qual
         SubPlan 2
           ->  Group
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
(15 rows)

explain (costs off)
select 1
from (
 select b c1, case when b in (
   select 'g' from agg_qual 
   group by 1) then 'e' else a::text end c2, max(5)
 from agg_qual 
 group by 1,2) temp1
where temp1.c2=temp1.c1;
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Subquery Scan on temp1
   ->  GroupAggregate
         Group By Key: public.agg_qual.b, (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE (public.agg_qual.a)::text END)
         Filter: (CASE WHEN (hashed SubPlan 2) THEN 'e'::text ELSE (public.agg_qual.a)::text END = (public.agg_qual.b)::text)
         ->  Sort
               Sort Key: public.agg_qual.b, (CASE WHEN (hashed SubPlan 1) THEN 'e'::text ELSE (public.agg_qual.a)::text END)
               ->  Seq Scan on agg_qual
                     SubPlan 1
                       ->  Group
                             Group By Key: 'g'::text
                             ->  Seq Scan on agg_qual
         SubPlan 2
           ->  Group
                 Group By Key: 'g'::text
                 ->  Seq Scan on agg_qual
(15 rows)

drop table agg_qual;
-- test group by on primary key
CREATE TABLE t (pk int, b int, c int, d int);
insert into t select v,v%5,v%3,v%7 from generate_series(1,15) as v;
ALTER TABLE t ADD PRIMARY KEY (pk);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "t_pkey" for table "t"
set enable_sort=off;
-- original
explain (verbose on, costs off)
SELECT pk, b, (c * sum(d))
FROM t
GROUP BY pk
order by 1,2;
             QUERY PLAN              
-------------------------------------
 Sort
   Output: pk, b, ((c * sum(d)))
   Sort Key: t.pk, t.b
   ->  HashAggregate
         Output: pk, b, (c * sum(d))
         Group By Key: t.pk
         ->  Seq Scan on public.t
               Output: pk, b, c, d
(8 rows)

SELECT pk, b, (c * count(d))
FROM t
GROUP BY pk
order by 1,2;
 pk | b | ?column? 
----+---+----------
  1 | 1 |        1
  2 | 2 |        2
  3 | 3 |        0
  4 | 4 |        1
  5 | 0 |        2
  6 | 1 |        0
  7 | 2 |        1
  8 | 3 |        2
  9 | 4 |        0
 10 | 0 |        1
 11 | 1 |        2
 12 | 2 |        0
 13 | 3 |        1
 14 | 4 |        2
 15 | 0 |        0
(15 rows)

explain (verbose on, costs off)
SELECT pk, b, (c * count(distinct d))
FROM t
GROUP BY pk
order by 1,2;
                   QUERY PLAN                    
-------------------------------------------------
 Sort
   Output: pk, b, ((c * count(DISTINCT d)))
   Sort Key: t.pk, t.b
   ->  GroupAggregate
         Output: pk, b, (c * count(DISTINCT d))
         Group By Key: t.pk
         ->  Index Scan using t_pkey on public.t
               Output: pk, b, c, d
(8 rows)

SELECT pk, b, (c * count(distinct d))
FROM t
GROUP BY pk
order by 1,2;
 pk | b | ?column? 
----+---+----------
  1 | 1 |        1
  2 | 2 |        2
  3 | 3 |        0
  4 | 4 |        1
  5 | 0 |        2
  6 | 1 |        0
  7 | 2 |        1
  8 | 3 |        2
  9 | 4 |        0
 10 | 0 |        1
 11 | 1 |        2
 12 | 2 |        0
 13 | 3 |        1
 14 | 4 |        2
 15 | 0 |        0
(15 rows)

explain (verbose on, costs off)
SELECT pk, b, (c * count(distinct d)), count(distinct c)
FROM t
GROUP BY pk
order by 1,2;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Sort
   Output: pk, b, ((c * count(DISTINCT d))), (count(DISTINCT c))
   Sort Key: t.pk, t.b
   ->  GroupAggregate
         Output: pk, b, (c * count(DISTINCT d)), count(DISTINCT c)
         Group By Key: t.pk
         ->  Index Scan using t_pkey on public.t
               Output: pk, b, c, d
(8 rows)

SELECT pk, b, (c * count(distinct d)), count(distinct c)
FROM t
GROUP BY pk
order by 1,2;
 pk | b | ?column? | count 
----+---+----------+-------
  1 | 1 |        1 |     1
  2 | 2 |        2 |     1
  3 | 3 |        0 |     1
  4 | 4 |        1 |     1
  5 | 0 |        2 |     1
  6 | 1 |        0 |     1
  7 | 2 |        1 |     1
  8 | 3 |        2 |     1
  9 | 4 |        0 |     1
 10 | 0 |        1 |     1
 11 | 1 |        2 |     1
 12 | 2 |        0 |     1
 13 | 3 |        1 |     1
 14 | 4 |        2 |     1
 15 | 0 |        0 |     1
(15 rows)

explain (verbose on, costs off)
SELECT t1.pk, t1.b, (t2.b * count(distinct t1.d)),
count(distinct t1.c), t1.d+sum(t2.c)+t1.c
FROM t t1 join t t2 on t1.b=t2.c
GROUP BY t1.pk, t2.b
order by 1,2,3,4,5;
                                                     QUERY PLAN                                                      
---------------------------------------------------------------------------------------------------------------------
 Sort
   Output: t1.pk, t1.b, ((t2.b * count(DISTINCT t1.d))), (count(DISTINCT t1.c)), (((t1.d + sum(t2.c)) + t1.c)), t2.b
   Sort Key: t1.pk, t1.b, ((t2.b * count(DISTINCT t1.d))), (count(DISTINCT t1.c)), (((t1.d + sum(t2.c)) + t1.c))
   ->  GroupAggregate
         Output: t1.pk, t1.b, (t2.b * count(DISTINCT t1.d)), count(DISTINCT t1.c), ((t1.d + sum(t2.c)) + t1.c), t2.b
         Group By Key: t1.pk, t2.b
         ->  Sort
               Output: t1.pk, t2.b, t1.b, t1.d, t1.c, t2.c
               Sort Key: t1.pk, t2.b
               ->  Hash Join
                     Output: t1.pk, t2.b, t1.b, t1.d, t1.c, t2.c
                     Hash Cond: (t1.b = t2.c)
                     ->  Seq Scan on public.t t1
                           Output: t1.pk, t1.b, t1.c, t1.d
                     ->  Hash
                           Output: t2.b, t2.c
                           ->  Seq Scan on public.t t2
                                 Output: t2.b, t2.c
(18 rows)

SELECT t1.pk, t1.b, (t2.b * count(distinct t1.d)),
count(distinct t1.c), t1.d+sum(t2.c)+t1.c
FROM t t1 join t t2 on t1.b=t2.c
GROUP BY t1.pk, t2.b
order by 1,2,3,4,5;
 pk | b | ?column? | count | ?column? 
----+---+----------+-------+----------
  1 | 1 |        0 |     1 |        3
  1 | 1 |        1 |     1 |        3
  1 | 1 |        2 |     1 |        3
  1 | 1 |        3 |     1 |        3
  1 | 1 |        4 |     1 |        3
  2 | 2 |        0 |     1 |        6
  2 | 2 |        1 |     1 |        6
  2 | 2 |        2 |     1 |        6
  2 | 2 |        3 |     1 |        6
  2 | 2 |        4 |     1 |        6
  5 | 0 |        0 |     1 |        7
  5 | 0 |        1 |     1 |        7
  5 | 0 |        2 |     1 |        7
  5 | 0 |        3 |     1 |        7
  5 | 0 |        4 |     1 |        7
  6 | 1 |        0 |     1 |        7
  6 | 1 |        1 |     1 |        7
  6 | 1 |        2 |     1 |        7
  6 | 1 |        3 |     1 |        7
  6 | 1 |        4 |     1 |        7
  7 | 2 |        0 |     1 |        3
  7 | 2 |        1 |     1 |        3
  7 | 2 |        2 |     1 |        3
  7 | 2 |        3 |     1 |        3
  7 | 2 |        4 |     1 |        3
 10 | 0 |        0 |     1 |        4
 10 | 0 |        1 |     1 |        4
 10 | 0 |        2 |     1 |        4
 10 | 0 |        3 |     1 |        4
 10 | 0 |        4 |     1 |        4
 11 | 1 |        0 |     1 |        7
 11 | 1 |        1 |     1 |        7
 11 | 1 |        2 |     1 |        7
 11 | 1 |        3 |     1 |        7
 11 | 1 |        4 |     1 |        7
 12 | 2 |        0 |     1 |        7
 12 | 2 |        1 |     1 |        7
 12 | 2 |        2 |     1 |        7
 12 | 2 |        3 |     1 |        7
 12 | 2 |        4 |     1 |        7
 15 | 0 |        0 |     1 |        1
 15 | 0 |        1 |     1 |        1
 15 | 0 |        2 |     1 |        1
 15 | 0 |        3 |     1 |        1
 15 | 0 |        4 |     1 |        1
(45 rows)

drop table t;
-- test listagg (compatible with A db 11g2)
CREATE SCHEMA listagg_test;
SET current_schema = listagg_test;
CREATE TABLE emp
(
   empno INTEGER CONSTRAINT pk_emp PRIMARY KEY,
   ename VARCHAR(20),
   job CHAR(10),
   address TEXT,
   email TEXT,
   mgrno INT4,
   workhour INT2,
   hiredate DATE,
   termdate DATE,
   offtime TIMESTAMP,
   overtime TIMESTAMPTZ,
   vacationTime INTERVAL,
   salPerHour FLOAT4,
   bonus NUMERIC(8,2),
   deptno NUMERIC(2)
);
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "pk_emp" for table "emp"
INSERT INTO emp VALUES (7369,'SMITH','CLERK','ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§','smithWu@163.com',7902,8,to_date('17-12-1999', 'dd-mm-yyyy'),NULL, '2018/12/1','2019-2-20 pst', INTERVAL '5' DAY, 60.35, 2000.80,20);
INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN','ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§','66allen_mm@qq.com',7698,5,to_date('20-2-2015', 'dd-mm-yyyy'),'2018-1-1','2013-12-24 12:30:00','2017-12-12 UTC', '4 DAY 6 HOUR', 9.89,899.00,30);
INSERT INTO emp VALUES (7521,'WARD','SALESMAN','Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702','hello702@163.com',7698,10,to_date('22-2-2010','dd-mm-yyyy'),'2016/12/30', '2016-06-12 8:12:00','2012-7-10 pst',INTERVAL '30 DAY', 52.98, 1000.01,30);
INSERT INTO emp VALUES (7566,'JONES','MANAGER','Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§','jonesishere@gmal.com',7839,3,to_date('2-4-2001','dd-mm-yyyy'),'2013-1-30','2010-10-13 24:00:00','2009-10-12 CST',NULL,200.00,999.10,20);
INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN','ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ','mm213n@qq.com',7698,12,to_date('28-9-1997','dd-mm-yyyy'),NULL,'2018/9/25 23:00:00','1999-1-18 CST', '24 HOUR', 1.28,99.99,30);
INSERT INTO emp VALUES (7698,'BLAKE','MANAGER','Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§','blake-life@fox.mail',7839,1,to_date('1-5-1981','dd-mm-yyyy'),'2012-10-13','2009-4-29 05:35:00','2010-12-1 pst','1 YEAR 1 MONTH', 38.25,2399.50,30);
INSERT INTO emp VALUES (7782,'CLARK','MANAGER','Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑','flower21@gmail.com',7839,5,to_date('9-6-1981','dd-mm-yyyy'),NULL,'1999-8-18 24:00:00','1999-5-12 pst','10 DAY',100.30,10000.01,10);
INSERT INTO emp VALUES (7788,'SCOTT','ANALYST','Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º','bigbigbang@sina.com',7566,9,to_date('13-7-1987','dd-mm-yyyy')-85,'2000-10-1','1998-1-19 00:29:00','2000-2-29 UTC','1 WEEK 2 DAY',99.25,1001.01,20);
INSERT INTO emp VALUES (7839,'KING','PRESIDENT','Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã','houseme123@yahoo.com',NULL,2,to_date('17-11-1981','dd-mm-yyyy'),NULL,NULL,NULL,'1 YEAR 30 DAY',19999.99,23011.88,10);
INSERT INTO emp VALUES (7844,'TURNER','SALESMAN','ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑','tur789@qq.com',7698,15,to_date('8-9-1981','dd-mm-yyyy'),'2011-07-15','1998-1-18 23:12:00','1999-1-16 pst','2 MONTH 10 DAY',99.12,9,30);
INSERT INTO emp VALUES (7876,'ADAMS','CLERK','Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑','aking_clerk@sina.com',7788,8,to_date('13-7-1987', 'dd-mm-yyyy')-51,'2018-10-23','1999-1-18 23:12:00','2017-12-30 pst','36 DAY',2600.12,1100.0,20);
INSERT INTO emp VALUES (7900,'JAMES','CLERK','Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º','whoMe@gmail.com',7698,10,to_date('3-12-1981','dd-mm-yyyy'),'2006/12/2','2005-9-10 5:00:00','2004-11-8 pst','12 DAY 12 HOUR',95,1000.22,30);
INSERT INTO emp VALUES (7902,'FORD','ANALYST','ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑','analyse666@163.com',7566,8,to_date('3-12-1981','dd-mm-yyyy'),'2012-12-23','2012-05-12 23:00:00','2011-03-21 CST','10 WEEK',199.23,2002.12,20);
INSERT INTO emp VALUES (7934,'MILLER','CLERK','ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑','Miller*mail@sina.com',7782,'10',to_date('23-1-1982','dd-mm-yyyy'),'2016-12-30','2015-10-12 24:00:00','2015-09-12 pst','40 DAY',112.23,10234.21,10);
analyze emp;
-- test for different input type: varchar, char, text, int2, int4, int8,float4, float8, numeric, date, timestamp, interval, etc. 
SELECT deptno, listagg(ename, ',') WITHIN GROUP(ORDER BY ename) AS employees_order_by_ename_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno |   employees_order_by_ename_varchar   
--------+--------------------------------------
     10 | CLARK,KING,MILLER
     20 | ADAMS,FORD,JONES,SCOTT,SMITH
     30 | ALLEN,BLAKE,JAMES,MARTIN,TURNER,WARD
(3 rows)

SELECT mgrno, listagg(empno, ';') WITHIN GROUP(ORDER BY empno) AS empno_order_by_empno_group_by_mgr_integer FROM emp GROUP BY mgrno ORDER BY 1;
 mgrno | empno_order_by_empno_group_by_mgr_integer 
-------+-------------------------------------------
  7566 | 7788;7902
  7698 | 7499;7521;7654;7844;7900
  7782 | 7934
  7788 | 7876
  7839 | 7566;7698;7782
  7902 | 7369
       | 7839
(7 rows)

SELECT deptno, listagg(job, '-') WITHIN GROUP(ORDER BY job) AS job_order_by_job_char FROM emp GROUP BY deptno ORDER BY 1;
 deptno |               job_order_by_job_char               
--------+---------------------------------------------------
     10 | CLERK-MANAGER-PRESIDENT
     20 | ANALYST-ANALYST-CLERK-CLERK-MANAGER
     30 | CLERK-MANAGER-SALESMAN-SALESMAN-SALESMAN-SALESMAN
(3 rows)

SELECT deptno, listagg(address, '//') WITHIN GROUP(ORDER BY address) AS address_order_by_address_text_zh FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                          address_order_by_address_text_zh                                                          
--------+----------------------------------------------------------------------------------------------------------------------------------------------------
     10 | ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑//Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã//Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑
     20 | Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑//ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§//ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑//Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º//Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§
     30 | Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702//ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑//Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§//ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ//ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§//Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º
(3 rows)

SELECT deptno, listagg(email, '##') WITHIN GROUP(ORDER BY email) AS email_order_by_email_text_en FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                      email_order_by_email_text_en                                       
--------+---------------------------------------------------------------------------------------------------------
     10 | flower21@gmail.com##houseme123@yahoo.com##Miller*mail@sina.com
     20 | aking_clerk@sina.com##analyse666@163.com##bigbigbang@sina.com##jonesishere@gmal.com##smithWu@163.com
     30 | 66allen_mm@qq.com##blake-life@fox.mail##hello702@163.com##mm213n@qq.com##tur789@qq.com##whoMe@gmail.com
(3 rows)

SELECT deptno, listagg(mgrno, ',') WITHIN GROUP(ORDER BY mgrno) AS mgrno_order_by_mgrno_int4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |   mgrno_order_by_mgrno_int4   
--------+-------------------------------
     10 | 7782,7839
     20 | 7566,7566,7788,7839,7902
     30 | 7698,7698,7698,7698,7698,7839
(3 rows)

SELECT deptno, listagg(workhour, '; ') WITHIN GROUP(ORDER BY workhour) AS workhour_order_by_workhour_int2 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | workhour_order_by_workhour_int2 
--------+---------------------------------
     10 | 2; 5; 10
     20 | 3; 8; 8; 8; 9
     30 | 1; 5; 10; 10; 12; 15
(3 rows)

SELECT deptno, listagg(hiredate, ', ') WITHIN GROUP(ORDER BY hiredate) AS hiredate_order_by_hiredate_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                              hiredate_order_by_hiredate_date                                                               
--------+------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Tue Jun 09 00:00:00 1981, Tue Nov 17 00:00:00 1981, Sat Jan 23 00:00:00 1982
     20 | Thu Dec 03 00:00:00 1981, Sun Apr 19 00:00:00 1987, Sat May 23 00:00:00 1987, Fri Dec 17 00:00:00 1999, Mon Apr 02 00:00:00 2001
     30 | Fri May 01 00:00:00 1981, Tue Sep 08 00:00:00 1981, Thu Dec 03 00:00:00 1981, Sun Sep 28 00:00:00 1997, Mon Feb 22 00:00:00 2010, Fri Feb 20 00:00:00 2015
(3 rows)

SELECT deptno, listagg(offtime, '; ') WITHIN GROUP(ORDER BY offtime) AS offtime_order_by_offtime_timestamp FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                             offtime_order_by_offtime_timestamp                                                             
--------+------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Thu Aug 19 00:00:00 1999; Tue Oct 13 00:00:00 2015
     20 | Mon Jan 19 00:29:00 1998; Mon Jan 18 23:12:00 1999; Thu Oct 14 00:00:00 2010; Sat May 12 23:00:00 2012; Sat Dec 01 00:00:00 2018
     30 | Sun Jan 18 23:12:00 1998; Sat Sep 10 05:00:00 2005; Wed Apr 29 05:35:00 2009; Tue Dec 24 12:30:00 2013; Sun Jun 12 08:12:00 2016; Tue Sep 25 23:00:00 2018
(3 rows)

SELECT deptno, listagg(overtime, ', ') WITHIN GROUP(ORDER BY overtime) AS overtime_order_by_overtime_timestamptz FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                                       overtime_order_by_overtime_timestamptz                                                                       
--------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Wed May 12 01:00:00 1999 PDT, Sat Sep 12 01:00:00 2015 PDT
     20 | Mon Feb 28 16:00:00 2000 PST, Sun Oct 11 23:00:00 2009 PDT, Sun Mar 20 23:00:00 2011 PDT, Sat Dec 30 00:00:00 2017 PST, Wed Feb 20 00:00:00 2019 PST
     30 | Sat Jan 16 00:00:00 1999 PST, Sun Jan 17 22:00:00 1999 PST, Mon Nov 08 00:00:00 2004 PST, Wed Dec 01 00:00:00 2010 PST, Tue Jul 10 01:00:00 2012 PDT, Mon Dec 11 16:00:00 2017 PST
(3 rows)

SELECT deptno, listagg(vacationTime, '; ') WITHIN GROUP(ORDER BY vacationTime ASC) AS vacationTime_order_by_vtime_ASC_interval FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                           vacationtime_order_by_vtime_asc_interval                            
--------+-----------------------------------------------------------------------------------------------
     10 | @ 10 days; @ 40 days; @ 1 year 30 days
     20 | @ 5 days; @ 9 days; @ 36 days; @ 70 days
     30 | @ 24 hours; @ 4 days 6 hours; @ 12 days 12 hours; @ 30 days; @ 2 mons 10 days; @ 1 year 1 mon
(3 rows)

SELECT deptno, listagg(termdate-hiredate, '; ') WITHIN GROUP(ORDER BY termdate-hiredate DESC) AS onwork_order_by_time_desc_interval FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                onwork_order_by_time_desc_interval                 
--------+-------------------------------------------------------------------
     10 | @ 12760 days
     20 | @ 11476 days; @ 11343 days; @ 4914 days; @ 4321 days
     30 | @ 11488 days; @ 10902 days; @ 9130 days; @ 2503 days; @ 1046 days
(3 rows)

SELECT deptno, listagg(salPerHour, ', ') WITHIN GROUP(ORDER BY salPerHour DESC) AS salPH_order_by_salPH_desc_float4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                salph_order_by_salph_desc_float4                
--------+----------------------------------------------------------------
     10 | 19999.990234, 112.230003, 100.300003
     20 | 2600.120117, 200.000000, 199.229996, 99.250000, 60.349998
     30 | 99.120003, 95.000000, 52.980000, 38.250000, 9.890000, 1.280000
(3 rows)

SELECT deptno, listagg(CAST(salPerHour*workhour AS FLOAT8), '; ') WITHIN GROUP(ORDER BY CAST(salPerHour*workhour AS FLOAT8) ASC) AS totalincome_order_by_tin_float8 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                   totalincome_order_by_tin_float8                    
--------+----------------------------------------------------------------------
     10 | 501.500015; 1122.300034; 39999.980469
     20 | 482.799988; 600.000000; 893.250000; 1593.839966; 20800.960938
     30 | 15.360000; 38.250000; 49.450002; 529.799995; 950.000000; 1486.800041
(3 rows)

SELECT deptno, listagg(CAST(workhour*7*30 AS INT8), '(Hours); ') WITHIN GROUP(ORDER BY CAST(workhour*7*30 AS INT8) DESC) AS hoursPerYear_order_by_hpy_DESC_int8 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                 hoursperyear_order_by_hpy_desc_int8                  
--------+----------------------------------------------------------------------
     10 | 2100(Hours); 1050(Hours); 420
     20 | 1890(Hours); 1680(Hours); 1680(Hours); 1680(Hours); 630
     30 | 3150(Hours); 2520(Hours); 2100(Hours); 2100(Hours); 1050(Hours); 210
(3 rows)

SELECT deptno, listagg(bonus, '($); ') WITHIN GROUP(ORDER BY bonus) AS bonus_order_by_bonus_numeric FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                 bonus_order_by_bonus_numeric                  
--------+---------------------------------------------------------------
     10 | 10000.01($); 10234.21($); 23011.88
     20 | 999.10($); 1001.01($); 1100.00($); 2000.80($); 2002.12
     30 | 9.00($); 99.99($); 899.00($); 1000.01($); 1000.22($); 2399.50
(3 rows)

SELECT deptno, listagg(termdate, '; ') WITHIN GROUP(ORDER BY termdate ASC NULLS FIRST) AS termdate_order_by_termdate_null_first_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                            termdate_order_by_termdate_null_first_date                                            
--------+----------------------------------------------------------------------------------------------------------------------------------
     10 | Fri Dec 30 00:00:00 2016
     20 | Sun Oct 01 00:00:00 2000; Sun Dec 23 00:00:00 2012; Wed Jan 30 00:00:00 2013; Tue Oct 23 00:00:00 2018
     30 | Sat Dec 02 00:00:00 2006; Fri Jul 15 00:00:00 2011; Sat Oct 13 00:00:00 2012; Fri Dec 30 00:00:00 2016; Mon Jan 01 00:00:00 2018
(3 rows)

SELECT deptno, listagg(termdate, '; ') WITHIN GROUP(ORDER BY termdate ASC NULLS LAST) AS termdate_order_by_termdate_null_last_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                            termdate_order_by_termdate_null_last_date                                             
--------+----------------------------------------------------------------------------------------------------------------------------------
     10 | Fri Dec 30 00:00:00 2016
     20 | Sun Oct 01 00:00:00 2000; Sun Dec 23 00:00:00 2012; Wed Jan 30 00:00:00 2013; Tue Oct 23 00:00:00 2018
     30 | Sat Dec 02 00:00:00 2006; Fri Jul 15 00:00:00 2011; Sat Oct 13 00:00:00 2012; Fri Dec 30 00:00:00 2016; Mon Jan 01 00:00:00 2018
(3 rows)

SELECT deptno, listagg(mgrno, ', ') WITHIN GROUP(ORDER BY mgrno NULLS FIRST) AS mgrno_order_by_mgrno_nulls_first_in4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | mgrno_order_by_mgrno_nulls_first_in4 
--------+--------------------------------------
     10 | 7782, 7839
     20 | 7566, 7566, 7788, 7839, 7902
     30 | 7698, 7698, 7698, 7698, 7698, 7839
(3 rows)

SELECT deptno, listagg(mgrno, '. ') WITHIN GROUP(ORDER BY mgrno NULLS LAST) AS mgrno_order_by_mgrno_nulls_last_int4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | mgrno_order_by_mgrno_nulls_last_int4 
--------+--------------------------------------
     10 | 7782. 7839
     20 | 7566. 7566. 7788. 7839. 7902
     30 | 7698. 7698. 7698. 7698. 7698. 7839
(3 rows)

SELECT mgrno, listagg(address, ' || ') WITHIN GROUP(ORDER BY NLSSORT(address, 'NLS_SORT=SCHINESE_PINYIN_M')) AS address_order_by_pinyin_text FROM emp GROUP BY mgrno ORDER BY 1;
 mgrno |                                                    address_order_by_pinyin_text                                                     
-------+-------------------------------------------------------------------------------------------------------------------------------------
  7566 | ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑ || Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º
  7698 | ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑ || Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702 || ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§ || Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º || ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ
  7782 | ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑
  7788 | Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑
  7839 | Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑ || Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§ || Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§
  7902 | ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§
       | Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã
(7 rows)

SELECT deptno, listagg(address, ' || ') WITHIN GROUP(ORDER BY NLSSORT(address, 'NLS_SORT=SCHINESE_PINYIN_M')) AS address_order_by_pinyin_text FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                                 address_order_by_pinyin_text                                                                 
--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑ || ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑ || Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã
     20 | ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§ || ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑ || Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§ || Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑ || Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º
     30 | ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑ || Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702 || ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§ || Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§ || Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º || ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ
(3 rows)

-- test for plan changes, dfx
SET explain_perf_mode=pretty;
EXPLAIN verbose SELECT deptno, listagg(ename, ',') WITHIN GROUP(ORDER BY ename) AS employees_order_by_ename_varchar FROM emp GROUP BY deptno;
                                         QUERY PLAN                                          
---------------------------------------------------------------------------------------------
 GroupAggregate  (cost=10000000001.41..1000000000144.26 rows=3 width=8203)
   Output: deptno, listagg((ename)::text, ','::text ) WITHIN GROUP ( ORDER BY (ename)::text)
   Group By Key: emp.deptno
   ->  Sort  (cost=10000000001.41..1000000000144.15 rows=14 width=11)
         Output: deptno, ename
         Sort Key: emp.deptno
         ->  Seq Scan on listagg_test.emp  (cost=0.00..1.14 rows=14 width=11)
               Output: deptno, ename
(8 rows)

EXPLAIN verbose SELECT deptno, listagg(email, '##') WITHIN GROUP(ORDER BY email) AS email_order_by_email_text_en FROM emp GROUP BY deptno;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 GroupAggregate  (cost=10000000001.41..1000000000144.26 rows=3 width=8215)
   Output: deptno, listagg(email, '##'::text ) WITHIN GROUP ( ORDER BY email)
   Group By Key: emp.deptno
   ->  Sort  (cost=10000000001.41..1000000000144.15 rows=14 width=23)
         Output: deptno, email
         Sort Key: emp.deptno
         ->  Seq Scan on listagg_test.emp  (cost=0.00..1.14 rows=14 width=23)
               Output: deptno, email
(8 rows)

EXPLAIN verbose SELECT deptno, listagg(bonus, '($); ') WITHIN GROUP(ORDER BY bonus) AS bonus_order_by_bonus_numeric FROM emp GROUP BY deptno;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 GroupAggregate  (cost=10000000001.41..1000000000144.26 rows=3 width=8204)
   Output: deptno, listagg(bonus, '($); '::text ) WITHIN GROUP ( ORDER BY bonus)
   Group By Key: emp.deptno
   ->  Sort  (cost=10000000001.41..1000000000144.15 rows=14 width=12)
         Output: deptno, bonus
         Sort Key: emp.deptno
         ->  Seq Scan on listagg_test.emp  (cost=0.00..1.14 rows=14 width=12)
               Output: deptno, bonus
(8 rows)

-- test for parameter without delimiter, special static delimiter expression, other order or group conditions
SELECT deptno, listagg(ename) WITHIN GROUP(ORDER BY ename) AS employees_noarg2_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno |    employees_noarg2_varchar     
--------+---------------------------------
     10 | CLARKKINGMILLER
     20 | ADAMSFORDJONESSCOTTSMITH
     30 | ALLENBLAKEJAMESMARTINTURNERWARD
(3 rows)

SELECT mgrno, listagg(empno) WITHIN GROUP(ORDER BY empno) AS empno_order_by_empno_group_by_mgr_noarg2_integer FROM emp GROUP BY mgrno ORDER BY 1;
 mgrno | empno_order_by_empno_group_by_mgr_noarg2_integer 
-------+--------------------------------------------------
  7566 | 77887902
  7698 | 74997521765478447900
  7782 | 7934
  7788 | 7876
  7839 | 756676987782
  7902 | 7369
       | 7839
(7 rows)

SELECT deptno, listagg(job) WITHIN GROUP(ORDER BY job) AS job_order_by_job_noargs_char FROM emp GROUP BY deptno ORDER BY 1;
 deptno |         job_order_by_job_noargs_char         
--------+----------------------------------------------
     10 | CLERKMANAGERPRESIDENT
     20 | ANALYSTANALYSTCLERKCLERKMANAGER
     30 | CLERKMANAGERSALESMANSALESMANSALESMANSALESMAN
(3 rows)

SELECT deptno, listagg(address) WITHIN GROUP(ORDER BY address) AS address_order_by_address_noarg2_text_zh FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                 address_order_by_address_noarg2_text_zh                                                  
--------+------------------------------------------------------------------------------------------------------------------------------------------
     10 | ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ãËä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑
     20 | Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•ºËé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§
     30 | Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º
(3 rows)

SELECT deptno, listagg(email) WITHIN GROUP(ORDER BY email) AS email_order_by_email_noarg2_text_en FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                              email_order_by_email_noarg2_text_en                              
--------+-----------------------------------------------------------------------------------------------
     10 | flower21@gmail.comhouseme123@yahoo.comMiller*mail@sina.com
     20 | aking_clerk@sina.comanalyse666@163.combigbigbang@sina.comjonesishere@gmal.comsmithWu@163.com
     30 | 66allen_mm@qq.comblake-life@fox.mailhello702@163.commm213n@qq.comtur789@qq.comwhoMe@gmail.com
(3 rows)

SELECT deptno, listagg(mgrno) WITHIN GROUP(ORDER BY mgrno) AS mgrno_order_by_mgrno_noarg2_int4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | mgrno_order_by_mgrno_noarg2_int4 
--------+----------------------------------
     10 | 77827839
     20 | 75667566778878397902
     30 | 769876987698769876987839
(3 rows)

SELECT deptno, listagg(workhour) WITHIN GROUP(ORDER BY workhour) AS workhour_order_by_workhour_noarg2_int2 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | workhour_order_by_workhour_noarg2_int2 
--------+----------------------------------------
     10 | 2510
     20 | 38889
     30 | 1510101215
(3 rows)

SELECT deptno, listagg(hiredate) WITHIN GROUP(ORDER BY hiredate) AS hiredate_order_by_hiredate_noarg2_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                      hiredate_order_by_hiredate_noarg2_date                                                      
--------+--------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Tue Jun 09 00:00:00 1981Tue Nov 17 00:00:00 1981Sat Jan 23 00:00:00 1982
     20 | Thu Dec 03 00:00:00 1981Sun Apr 19 00:00:00 1987Sat May 23 00:00:00 1987Fri Dec 17 00:00:00 1999Mon Apr 02 00:00:00 2001
     30 | Fri May 01 00:00:00 1981Tue Sep 08 00:00:00 1981Thu Dec 03 00:00:00 1981Sun Sep 28 00:00:00 1997Mon Feb 22 00:00:00 2010Fri Feb 20 00:00:00 2015
(3 rows)

SELECT deptno, listagg(offtime) WITHIN GROUP(ORDER BY offtime) AS offtime_order_by_offtime_noarg2_timestamp FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                    offtime_order_by_offtime_noarg2_timestamp                                                     
--------+--------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Thu Aug 19 00:00:00 1999Tue Oct 13 00:00:00 2015
     20 | Mon Jan 19 00:29:00 1998Mon Jan 18 23:12:00 1999Thu Oct 14 00:00:00 2010Sat May 12 23:00:00 2012Sat Dec 01 00:00:00 2018
     30 | Sun Jan 18 23:12:00 1998Sat Sep 10 05:00:00 2005Wed Apr 29 05:35:00 2009Tue Dec 24 12:30:00 2013Sun Jun 12 08:12:00 2016Tue Sep 25 23:00:00 2018
(3 rows)

SELECT deptno, listagg(overtime) WITHIN GROUP(ORDER BY overtime) AS overtime_order_by_overtime_noarg2_timestamptz FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                              overtime_order_by_overtime_noarg2_timestamptz                                                               
--------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Wed May 12 01:00:00 1999 PDTSat Sep 12 01:00:00 2015 PDT
     20 | Mon Feb 28 16:00:00 2000 PSTSun Oct 11 23:00:00 2009 PDTSun Mar 20 23:00:00 2011 PDTSat Dec 30 00:00:00 2017 PSTWed Feb 20 00:00:00 2019 PST
     30 | Sat Jan 16 00:00:00 1999 PSTSun Jan 17 22:00:00 1999 PSTMon Nov 08 00:00:00 2004 PSTWed Dec 01 00:00:00 2010 PSTTue Jul 10 01:00:00 2012 PDTMon Dec 11 16:00:00 2017 PST
(3 rows)

SELECT deptno, listagg(vacationTime) WITHIN GROUP(ORDER BY vacationTime DESC) AS vacationTime_order_by_vtime_desc_noarg2_interval FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                  vacationtime_order_by_vtime_desc_noarg2_interval                   
--------+-------------------------------------------------------------------------------------
     10 | @ 1 year 30 days@ 40 days@ 10 days
     20 | @ 70 days@ 36 days@ 9 days@ 5 days
     30 | @ 1 year 1 mon@ 2 mons 10 days@ 30 days@ 12 days 12 hours@ 4 days 6 hours@ 24 hours
(3 rows)

SELECT deptno, listagg(CAST(salPerHour*workhour AS FLOAT8)) WITHIN GROUP(ORDER BY CAST(salPerHour*workhour AS FLOAT8) ASC) AS totalincome_order_by_tin_noarg2_float8 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |           totalincome_order_by_tin_noarg2_float8           
--------+------------------------------------------------------------
     10 | 501.5000151122.30003439999.980469
     20 | 482.799988600.000000893.2500001593.83996620800.960938
     30 | 15.36000038.25000049.450002529.799995950.0000001486.800041
(3 rows)

SELECT deptno, listagg(CAST(workhour*7*30 AS INT8)) WITHIN GROUP(ORDER BY CAST(workhour*7*30 AS INT8) DESC) AS hoursPerYear_order_by_hpy_DESC_noarg2_int8 FROM emp GROUP BY deptno ORDER BY 1;
 deptno | hoursperyear_order_by_hpy_desc_noarg2_int8 
--------+--------------------------------------------
     10 | 21001050420
     20 | 1890168016801680630
     30 | 31502520210021001050210
(3 rows)

SELECT deptno, listagg(bonus) WITHIN GROUP(ORDER BY bonus) AS bonus_order_by_bonus_noarg2_numeric FROM emp GROUP BY deptno ORDER BY 1;
 deptno | bonus_order_by_bonus_noarg2_numeric  
--------+--------------------------------------
     10 | 10000.0110234.2123011.88
     20 | 999.101001.011100.002000.802002.12
     30 | 9.0099.99899.001000.011000.222399.50
(3 rows)

SELECT deptno, listagg(',') WITHIN GROUP(ORDER BY ename) AS employees_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno | employees_varchar 
--------+-------------------
     10 | ,,,
     20 | ,,,,,
     30 | ,,,,,,
(3 rows)

SELECT deptno, listagg(email) WITHIN GROUP(ORDER BY email) AS email_order_by_email_text_en FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                 email_order_by_email_text_en                                  
--------+-----------------------------------------------------------------------------------------------
     10 | flower21@gmail.comhouseme123@yahoo.comMiller*mail@sina.com
     20 | aking_clerk@sina.comanalyse666@163.combigbigbang@sina.comjonesishere@gmal.comsmithWu@163.com
     30 | 66allen_mm@qq.comblake-life@fox.mailhello702@163.commm213n@qq.comtur789@qq.comwhoMe@gmail.com
(3 rows)

SELECT deptno, listagg(vacationTime) WITHIN GROUP(ORDER BY vacationTime DESC) AS vacationTime_order_by_vtime_desc_interval FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                      vacationtime_order_by_vtime_desc_interval                      
--------+-------------------------------------------------------------------------------------
     10 | @ 1 year 30 days@ 40 days@ 10 days
     20 | @ 70 days@ 36 days@ 9 days@ 5 days
     30 | @ 1 year 1 mon@ 2 mons 10 days@ 30 days@ 12 days 12 hours@ 4 days 6 hours@ 24 hours
(3 rows)

SELECT deptno, listagg(ename, '(' || CHR(deptno+55)|| ')') WITHIN GROUP(ORDER BY ename) AS employees_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno |               employees_varchar                
--------+------------------------------------------------
     10 | CLARK(A)KING(A)MILLER
     20 | ADAMS(K)FORD(K)JONES(K)SCOTT(K)SMITH
     30 | ALLEN(U)BLAKE(U)JAMES(U)MARTIN(U)TURNER(U)WARD
(3 rows)

SELECT deptno, listagg(ename, ', ') WITHIN GROUP(ORDER BY NULL) AS employees_no_order_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno |        employees_no_order_varchar         
--------+-------------------------------------------
     10 | MILLER, CLARK, KING
     20 | SCOTT, JONES, SMITH, ADAMS, FORD
     30 | WARD, TURNER, ALLEN, BLAKE, MARTIN, JAMES
(3 rows)

SELECT deptno, listagg(salPerHour, '; ') WITHIN GROUP(ORDER BY NULL) AS salPH_no_order_float4 FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                     salph_no_order_float4                      
--------+----------------------------------------------------------------
     10 | 112.230003; 100.300003; 19999.990234
     20 | 99.250000; 200.000000; 60.349998; 2600.120117; 199.229996
     30 | 52.980000; 99.120003; 9.890000; 38.250000; 1.280000; 95.000000
(3 rows)

SELECT deptno, listagg(ename, ',') WITHIN GROUP(ORDER BY hiredate) AS employees_varchar FROM emp GROUP BY deptno ORDER BY 1;
 deptno |          employees_varchar           
--------+--------------------------------------
     10 | CLARK,KING,MILLER
     20 | FORD,SCOTT,ADAMS,SMITH,JONES
     30 | BLAKE,TURNER,JAMES,MARTIN,WARD,ALLEN
(3 rows)

SELECT deptno, listagg(address, '//') WITHIN GROUP(ORDER BY empno) AS address_order_by_empno_TEXT FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                            address_order_by_empno_text                                                             
--------+----------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑//Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã//ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑
     20 | ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§//Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§//Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º//Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑//ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑
     30 | ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§//Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702//ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ//Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§//ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑//Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º
(3 rows)

SELECT job, listagg(ename, '+') WITHIN GROUP(ORDER BY ename) AS ename_order_by_ename_group_by_job FROM emp GROUP BY job ORDER BY 1;
    job     | ename_order_by_ename_group_by_job 
------------+-----------------------------------
 ANALYST    | FORD+SCOTT
 CLERK      | ADAMS+JAMES+MILLER+SMITH
 MANAGER    | BLAKE+CLARK+JONES
 PRESIDENT  | KING
 SALESMAN   | ALLEN+MARTIN+TURNER+WARD
(5 rows)

SELECT job, listagg(ename, '+') WITHIN GROUP(ORDER BY hiredate) AS ename_order_by_hiredate_group_by_job FROM emp GROUP BY job ORDER BY 1;
    job     | ename_order_by_hiredate_group_by_job 
------------+--------------------------------------
 ANALYST    | FORD+SCOTT
 CLERK      | JAMES+MILLER+ADAMS+SMITH
 MANAGER    | BLAKE+CLARK+JONES
 PRESIDENT  | KING
 SALESMAN   | TURNER+MARTIN+WARD+ALLEN
(5 rows)

SELECT job, listagg(ename, '; ') WITHIN GROUP(ORDER BY bonus DESC) AS ename_order_by_bonus_group_by_job FROM emp GROUP BY job ORDER BY 1;
    job     | ename_order_by_bonus_group_by_job 
------------+-----------------------------------
 ANALYST    | FORD; SCOTT
 CLERK      | MILLER; SMITH; ADAMS; JAMES
 MANAGER    | CLARK; BLAKE; JONES
 PRESIDENT  | KING
 SALESMAN   | WARD; ALLEN; MARTIN; TURNER
(5 rows)

SELECT job, listagg(bonus, '($); ') WITHIN GROUP(ORDER BY bonus DESC) AS bonus_order_by_bonus_group_by_job FROM emp GROUP BY job ORDER BY 1;
    job     |      bonus_order_by_bonus_group_by_job       
------------+----------------------------------------------
 ANALYST    | 2002.12($); 1001.01
 CLERK      | 10234.21($); 2000.80($); 1100.00($); 1000.22
 MANAGER    | 10000.01($); 2399.50($); 999.10
 PRESIDENT  | 23011.88
 SALESMAN   | 1000.01($); 899.00($); 99.99($); 9.00
(5 rows)

SELECT mgrno, listagg(job, '; ') WITHIN GROUP(ORDER BY job) AS ename_order_by_job_group_by_mgrno FROM emp GROUP BY mgrno ORDER BY 1;
 mgrno |       ename_order_by_job_group_by_mgrno       
-------+-----------------------------------------------
  7566 | ANALYST; ANALYST
  7698 | CLERK; SALESMAN; SALESMAN; SALESMAN; SALESMAN
  7782 | CLERK
  7788 | CLERK
  7839 | MANAGER; MANAGER; MANAGER
  7902 | CLERK
       | PRESIDENT
(7 rows)

SET datestyle = 'SQL,DMY';
SELECT deptno, listagg(hiredate, ', ') WITHIN GROUP(ORDER BY hiredate) AS hiredate_dmy_order_by_hiredate_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                             hiredate_dmy_order_by_hiredate_date                                              
--------+------------------------------------------------------------------------------------------------------------------------------
     10 | 09/06/1981 00:00:00, 17/11/1981 00:00:00, 23/01/1982 00:00:00
     20 | 03/12/1981 00:00:00, 19/04/1987 00:00:00, 23/05/1987 00:00:00, 17/12/1999 00:00:00, 02/04/2001 00:00:00
     30 | 01/05/1981 00:00:00, 08/09/1981 00:00:00, 03/12/1981 00:00:00, 28/09/1997 00:00:00, 22/02/2010 00:00:00, 20/02/2015 00:00:00
(3 rows)

SET datestyle = 'SQL,MDY';
SELECT deptno, listagg(hiredate, ', ') WITHIN GROUP(ORDER BY hiredate) AS hiredate_dmy_order_by_hiredate_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                             hiredate_dmy_order_by_hiredate_date                                              
--------+------------------------------------------------------------------------------------------------------------------------------
     10 | 06/09/1981 00:00:00, 11/17/1981 00:00:00, 01/23/1982 00:00:00
     20 | 12/03/1981 00:00:00, 04/19/1987 00:00:00, 05/23/1987 00:00:00, 12/17/1999 00:00:00, 04/02/2001 00:00:00
     30 | 05/01/1981 00:00:00, 09/08/1981 00:00:00, 12/03/1981 00:00:00, 09/28/1997 00:00:00, 02/22/2010 00:00:00, 02/20/2015 00:00:00
(3 rows)

SET datestyle = 'Postgres,DMY';
SELECT deptno, listagg(hiredate, ', ') WITHIN GROUP(ORDER BY hiredate) AS hiredate_dmy_order_by_hiredate_date FROM emp GROUP BY deptno ORDER BY 1;
 deptno |                                                            hiredate_dmy_order_by_hiredate_date                                                             
--------+------------------------------------------------------------------------------------------------------------------------------------------------------------
     10 | Tue 09 Jun 00:00:00 1981, Tue 17 Nov 00:00:00 1981, Sat 23 Jan 00:00:00 1982
     20 | Thu 03 Dec 00:00:00 1981, Sun 19 Apr 00:00:00 1987, Sat 23 May 00:00:00 1987, Fri 17 Dec 00:00:00 1999, Mon 02 Apr 00:00:00 2001
     30 | Fri 01 May 00:00:00 1981, Tue 08 Sep 00:00:00 1981, Thu 03 Dec 00:00:00 1981, Sun 28 Sep 00:00:00 1997, Mon 22 Feb 00:00:00 2010, Fri 20 Feb 00:00:00 2015
(3 rows)

SELECT deptno, listagg(job, ',') WITHIN GROUP(ORDER BY job), listagg(ename,'; ') WITHIN GROUP(order by hiredate) AS employees FROM emp group by deptno ORDER BY 1;
 deptno |                      listagg                      |                 employees                 
--------+---------------------------------------------------+-------------------------------------------
     10 | CLERK,MANAGER,PRESIDENT                           | CLARK; KING; MILLER
     20 | ANALYST,ANALYST,CLERK,CLERK,MANAGER               | FORD; SCOTT; ADAMS; SMITH; JONES
     30 | CLERK,MANAGER,SALESMAN,SALESMAN,SALESMAN,SALESMAN | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
(3 rows)

-- test for abnormal cases: no WITHIN keyword, invalid parameter, other orders, etc. errors.
SELECT deptno, listagg(ename, ',') AS employees_without_within_varchar FROM emp GROUP BY deptno;
ERROR:  missing WITHIN keyword.
LINE 1: SELECT deptno, listagg(ename, ',') AS employees_without_with...
                       ^
SELECT deptno, listagg() WITHIN GROUP(ORDER BY ename) AS employees_varchar FROM emp GROUP BY deptno;
ERROR:  function listagg() does not exist
LINE 1: SELECT deptno, listagg() WITHIN GROUP(ORDER BY ename) AS emp...
                       ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CONTEXT:  referenced column: employees_varchar
SELECT deptno, listagg(ename, ',' ORDER BY ename) WITHIN GROUP(ORDER BY hiredate) AS employees_3_args_varchar FROM emp GROUP BY deptno;
ERROR:  cannot use multiple ORDER BY clauses with WITHIN GROUP.
LINE 1: SELECT deptno, listagg(ename, ',' ORDER BY ename) WITHIN GRO...
                                                          ^
SELECT deptno, listagg(DISTINCT ename, ',') WITHIN GROUP(ORDER BY ename) AS employees_distinct_varchar FROM emp GROUP BY deptno;
ERROR:  cannot use DISTINCT with WITHIN GROUP.
LINE 1: SELECT deptno, listagg(DISTINCT ename, ',') WITHIN GROUP(ORD...
                                                    ^
SELECT deptno, listagg(ename, '(' || MAX(deptno)|| ')') WITHIN GROUP(ORDER BY NULL) AS employees_varchar FROM emp GROUP BY deptno;
ERROR:  aggregate function calls cannot be nested
LINE 1: SELECT deptno, listagg(ename, '(' || MAX(deptno)|| ')') WITH...
                                             ^
CONTEXT:  referenced column: employees_varchar
-- test for window function
SET datestyle = 'ISO,YMD';
SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROUP(ORDER BY hiredate) OVER(PARTITION BY deptno) AS employees FROM emp ORDER BY 1,2,3;
 deptno |        email         | mgrno |                 employees                 
--------+----------------------+-------+-------------------------------------------
     10 | flower21@gmail.com   |  7839 | CLARK; KING; MILLER
     10 | houseme123@yahoo.com |       | CLARK; KING; MILLER
     10 | Miller*mail@sina.com |  7782 | CLARK; KING; MILLER
     20 | aking_clerk@sina.com |  7788 | FORD; SCOTT; ADAMS; SMITH; JONES
     20 | analyse666@163.com   |  7566 | FORD; SCOTT; ADAMS; SMITH; JONES
     20 | bigbigbang@sina.com  |  7566 | FORD; SCOTT; ADAMS; SMITH; JONES
     20 | jonesishere@gmal.com |  7839 | FORD; SCOTT; ADAMS; SMITH; JONES
     20 | smithWu@163.com      |  7902 | FORD; SCOTT; ADAMS; SMITH; JONES
     30 | 66allen_mm@qq.com    |  7698 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
     30 | blake-life@fox.mail  |  7839 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
     30 | hello702@163.com     |  7698 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
     30 | mm213n@qq.com        |  7698 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
     30 | tur789@qq.com        |  7698 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
     30 | whoMe@gmail.com      |  7698 | BLAKE; TURNER; JAMES; MARTIN; WARD; ALLEN
(14 rows)

SELECT job, address, ename, listagg(bonus, '(Ôø•); ') WITHIN GROUP(ORDER BY bonus) OVER(PARTITION BY job) AS bonus FROM emp ORDER BY 1,2,3;
    job     |              address               | ename  |                      bonus                      
------------+------------------------------------+--------+-------------------------------------------------
 ANALYST    | ÊñπË•øÂå∫Ê≠£Ë°ó3Âè∑Â∑∑66Âè∑                | FORD   | 1001.01(Ôø•); 2002.12
 ANALYST    | Ê∏©Ê≥âË∑ØÂõõÊµ∑Ëä±Âõ≠1Âè∑Ê•º                | SCOTT  | 1001.01(Ôø•); 2002.12
 CLERK      | ÂõõÊñπÂå∫Ê¥õÈò≥Ë∑Ø34Âè∑3Âè∑Ê•º4ÂçïÂÖÉ402Êà∑    | MILLER | 1000.22(Ôø•); 1100.00(Ôø•); 2000.80(Ôø•); 10234.21
 CLERK      | Â¶ÇÂåóË°óÊ±üÂøÉÁæéÂØìÂ∞èÂå∫1Âè∑              | ADAMS  | 1000.22(Ôø•); 1100.00(Ôø•); 2000.80(Ôø•); 10234.21
 CLERK      | ÂÆùÂ±±Âå∫Á§∫ËåÉÊñ∞Êùë37Âè∑403ÂÆ§            | SMITH  | 1000.22(Ôø•); 1100.00(Ôø•); 2000.80(Ôø•); 10234.21
 CLERK      | Èî¶Â∞öË∑ØMOCOÂÖ¨ÂØì10Ê•º                 | JAMES  | 1000.22(Ôø•); 1100.00(Ôø•); 2000.80(Ôø•); 10234.21
 MANAGER    | Âª∫ÂõΩÈó®Â§ßË°ó23Âè∑Ê•º302ÂÆ§              | BLAKE  | 999.10(Ôø•); 2399.50(Ôø•); 10000.01
 MANAGER    | Ëä±ÈÉΩÂ§ßÈÅì100Âè∑‰∏ñÁ∫™ÂÖâËä±Â∞èÂå∫3023Âè∑    | CLARK  | 999.10(Ôø•); 2399.50(Ôø•); 10000.01
 MANAGER    | Ëé≤Ëä±‰∫îÊùëÈæôÊòåÈáå34Âè∑601ÂÆ§            | JONES  | 999.10(Ôø•); 2399.50(Ôø•); 10000.01
 PRESIDENT  | Ê∏©Ê±üÂå∫OneHouseÈ´òÁ∫ßÂà´Â¢Ö1Ê†ã          | KING   | 23011.88
 SALESMAN   | Âüé‰∏úÂå∫‰∫®ËææËä±Âõ≠7Ê†ã702               | WARD   | 9.00(Ôø•); 99.99(Ôø•); 899.00(Ôø•); 1000.01
 SALESMAN   | ÂüéÂåóÊ¢ÅÂÆ∂Â∑∑132Âè∑                    | TURNER | 9.00(Ôø•); 99.99(Ôø•); 899.00(Ôø•); 1000.01
 SALESMAN   | ÂºÄÂπ≥Ë∑Ø53Âè∑ÂõΩÊ£âÂõõÂéÇ‰∫åÂÆøËàç1Âè∑Ê•º2ÂçïÂÖÉ | MARTIN | 9.00(Ôø•); 99.99(Ôø•); 899.00(Ôø•); 1000.01
 SALESMAN   | ËôπÂè£Âå∫Ë•øÂ∫∑ÂçóË∑Ø125ÂºÑ34Âè∑201ÂÆ§       | ALLEN  | 9.00(Ôø•); 99.99(Ôø•); 899.00(Ôø•); 1000.01
(14 rows)

SELECT mgrno, ename, job, hiredate,listagg(ename, ',') WITHIN GROUP(ORDER BY ename) OVER(PARTITION BY mgrno) AS employees_in_manager FROM emp ORDER BY 1,2,3,4;
 mgrno | ename  |    job     |      hiredate       |      employees_in_manager      
-------+--------+------------+---------------------+--------------------------------
  7566 | FORD   | ANALYST    | 1981-12-03 00:00:00 | FORD,SCOTT
  7566 | SCOTT  | ANALYST    | 1987-04-19 00:00:00 | FORD,SCOTT
  7698 | ALLEN  | SALESMAN   | 2015-02-20 00:00:00 | ALLEN,JAMES,MARTIN,TURNER,WARD
  7698 | JAMES  | CLERK      | 1981-12-03 00:00:00 | ALLEN,JAMES,MARTIN,TURNER,WARD
  7698 | MARTIN | SALESMAN   | 1997-09-28 00:00:00 | ALLEN,JAMES,MARTIN,TURNER,WARD
  7698 | TURNER | SALESMAN   | 1981-09-08 00:00:00 | ALLEN,JAMES,MARTIN,TURNER,WARD
  7698 | WARD   | SALESMAN   | 2010-02-22 00:00:00 | ALLEN,JAMES,MARTIN,TURNER,WARD
  7782 | MILLER | CLERK      | 1982-01-23 00:00:00 | MILLER
  7788 | ADAMS  | CLERK      | 1987-05-23 00:00:00 | ADAMS
  7839 | BLAKE  | MANAGER    | 1981-05-01 00:00:00 | BLAKE,CLARK,JONES
  7839 | CLARK  | MANAGER    | 1981-06-09 00:00:00 | BLAKE,CLARK,JONES
  7839 | JONES  | MANAGER    | 2001-04-02 00:00:00 | BLAKE,CLARK,JONES
  7902 | SMITH  | CLERK      | 1999-12-17 00:00:00 | SMITH
       | KING   | PRESIDENT  | 1981-11-17 00:00:00 | KING
(14 rows)

SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROUP(ORDER BY ename) OVER(PARTITION BY deptno ORDER BY ename) AS employees FROM emp ORDER BY 1,2,3;
 deptno |        email         | mgrno |                 employees                 
--------+----------------------+-------+-------------------------------------------
     10 | flower21@gmail.com   |  7839 | CLARK; KING; MILLER
     10 | houseme123@yahoo.com |       | CLARK; KING; MILLER
     10 | Miller*mail@sina.com |  7782 | CLARK; KING; MILLER
     20 | aking_clerk@sina.com |  7788 | ADAMS; FORD; JONES; SCOTT; SMITH
     20 | analyse666@163.com   |  7566 | ADAMS; FORD; JONES; SCOTT; SMITH
     20 | bigbigbang@sina.com  |  7566 | ADAMS; FORD; JONES; SCOTT; SMITH
     20 | jonesishere@gmal.com |  7839 | ADAMS; FORD; JONES; SCOTT; SMITH
     20 | smithWu@163.com      |  7902 | ADAMS; FORD; JONES; SCOTT; SMITH
     30 | 66allen_mm@qq.com    |  7698 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
     30 | blake-life@fox.mail  |  7839 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
     30 | hello702@163.com     |  7698 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
     30 | mm213n@qq.com        |  7698 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
     30 | tur789@qq.com        |  7698 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
     30 | whoMe@gmail.com      |  7698 | ALLEN; BLAKE; JAMES; MARTIN; TURNER; WARD
(14 rows)

SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROUP(ORDER BY NULL) OVER(PARTITION BY deptno ORDER BY NULL) AS employees FROM emp ORDER BY 1,2,3;
 deptno |        email         | mgrno |                 employees                 
--------+----------------------+-------+-------------------------------------------
     10 | flower21@gmail.com   |  7839 | MILLER; CLARK; KING
     10 | houseme123@yahoo.com |       | MILLER; CLARK; KING
     10 | Miller*mail@sina.com |  7782 | MILLER; CLARK; KING
     20 | aking_clerk@sina.com |  7788 | SCOTT; JONES; SMITH; ADAMS; FORD
     20 | analyse666@163.com   |  7566 | SCOTT; JONES; SMITH; ADAMS; FORD
     20 | bigbigbang@sina.com  |  7566 | SCOTT; JONES; SMITH; ADAMS; FORD
     20 | jonesishere@gmal.com |  7839 | SCOTT; JONES; SMITH; ADAMS; FORD
     20 | smithWu@163.com      |  7902 | SCOTT; JONES; SMITH; ADAMS; FORD
     30 | 66allen_mm@qq.com    |  7698 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
     30 | blake-life@fox.mail  |  7839 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
     30 | hello702@163.com     |  7698 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
     30 | mm213n@qq.com        |  7698 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
     30 | tur789@qq.com        |  7698 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
     30 | whoMe@gmail.com      |  7698 | WARD; TURNER; ALLEN; BLAKE; MARTIN; JAMES
(14 rows)

SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROUP(ORDER BY ename) OVER(PARTITION BY deptno ORDER BY hiredate) AS employees FROM emp ORDER BY 1,2,3;
ERROR:  window functions cannot allow multiple different order info
LINE 1: SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROU...
                                     ^
CONTEXT:  referenced column: employees
explain verbose SELECT deptno, email, mgrno, listagg(ename,'; ') WITHIN GROUP(ORDER BY ename) OVER(PARTITION BY deptno) AS employees FROM emp ORDER BY 1,2,3;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1010000000144.66..101000000014469.80 rows=14 width=33)
   Output: deptno, email, mgrno, (listagg((ename)::text, '; '::text) WITHIN GROUP (ORDER BY ename USING = NULLS LAST) OVER ( PARTITION BY deptno)), ename
   Sort Key: emp.deptno, emp.email, emp.mgrno
   ->  WindowAgg  (cost=10000000001.41..1000000000144.40 rows=14 width=33)
         Output: deptno, email, mgrno, listagg((ename)::text, '; '::text) WITHIN GROUP (ORDER BY ename USING = NULLS LAST) OVER ( PARTITION BY deptno), ename
         ->  Sort  (cost=10000000001.41..1000000000144.15 rows=14 width=33)
               Output: deptno, ename, email, mgrno
               Sort Key: emp.deptno, emp.ename
               ->  Seq Scan on listagg_test.emp  (cost=0.00..1.14 rows=14 width=33)
                     Output: deptno, ename, email, mgrno
(10 rows)

explain verbose SELECT job, address, ename, listagg(bonus, '(Ôø•); ') WITHIN GROUP(ORDER BY bonus) OVER(PARTITION BY job) AS bonus FROM emp ORDER BY 1,2,3;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=1010000000144.66..101000000014469.80 rows=14 width=57)
   Output: job, address, ename, (listagg(bonus, '(Ôø•); '::text) WITHIN GROUP (ORDER BY bonus USING = NULLS LAST) OVER ( PARTITION BY job)), bonus
   Sort Key: emp.job, emp.address, emp.ename
   ->  WindowAgg  (cost=10000000001.41..1000000000144.40 rows=14 width=57)
         Output: job, address, ename, listagg(bonus, '(Ôø•); '::text) WITHIN GROUP (ORDER BY bonus USING = NULLS LAST) OVER ( PARTITION BY job), bonus
         ->  Sort  (cost=10000000001.41..1000000000144.15 rows=14 width=57)
               Output: job, bonus, address, ename
               Sort Key: emp.job, emp.bonus
               ->  Seq Scan on listagg_test.emp  (cost=0.00..1.14 rows=14 width=57)
                     Output: job, bonus, address, ename
(10 rows)

-- test agg on anyarray
CREATE TABLE arraggtest (a int default 10, f1 INT[], f2 TEXT[][], f3 FLOAT[]);
INSERT INTO arraggtest (f1, f2, f3) VALUES ('{1,2,3,4}','{{grey,red},{blue,blue}}','{1.6, 0.0}');
INSERT INTO arraggtest (f1, f2, f3) VALUES ('{1,2,3}','{{grey,red},{grey,blue}}','{1.6}');
SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest order by 1, 2, 3, 4;
    max    |   min   |           max            |           min            |   max   |  min  
-----------+---------+--------------------------+--------------------------+---------+-------
 {1,2,3,4} | {1,2,3} | {{grey,red},{grey,blue}} | {{grey,red},{blue,blue}} | {1.6,0} | {1.6}
(1 row)

explain (verbose on, costs off)SELECT max(f1), min(f1), max(f2), min(f2), max(f3), min(f3) FROM arraggtest order by 1, 2, 3, 4;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Sort
   Output: (max(f1)), (min(f1)), (max(f2)), (min(f2)), (max(f3)), (min(f3))
   Sort Key: (max(arraggtest.f1)), (min(arraggtest.f1)), (max(arraggtest.f2)), (min(arraggtest.f2))
   ->  Aggregate
         Output: max(f1), min(f1), max(f2), min(f2), max(f3), min(f3)
         ->  Seq Scan on listagg_test.arraggtest
               Output: a, f1, f2, f3
(7 rows)

drop TABLE arraggtest;
DROP SCHEMA listagg_test CASCADE;
NOTICE:  drop cascades to table emp
