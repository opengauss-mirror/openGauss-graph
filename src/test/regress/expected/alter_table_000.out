--
--- ALTER TABLE related tickets or bugs fixed
--
-- ATLER TABLE SYNTAX
\h alter table
Command:     ALTER TABLE
Description: change the definition of a table
Syntax:
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    action [, ... ];
ALTER TABLE [ IF EXISTS ] table_name
    ADD ( { column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]} [, ...] );
ALTER TABLE [ IF EXISTS ] table_name
    MODIFY ( { column_name data_type | column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ] | column_name [ CONSTRAINT constraint_name ] NULL } [, ...] );
ALTER TABLE [ IF EXISTS ] table_name
    RENAME TO new_table_name;
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    RENAME [ COLUMN ] column_name TO new_column_name;
ALTER TABLE [ IF EXISTS ] { table_name  [*] | ONLY table_name | ONLY ( table_name  )}
    RENAME CONSTRAINT constraint_name TO new_constraint_name;
ALTER TABLE [ IF EXISTS ] table_name
    SET SCHEMA new_schema;

where action can be:
column_clause 
    | ADD table_constraint [ NOT VALID ]
    | ADD table_constraint_using_index
    | VALIDATE CONSTRAINT constraint_name
    | DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]
    | CLUSTER ON index_name
    | SET WITHOUT CLUSTER
    | SET ( {storage_parameter = value} [, ... ] )
    | RESET ( storage_parameter [, ... ] )
    | OWNER TO new_owner
    | SET TABLESPACE new_tablespace
    | SET {COMPRESS|NOCOMPRESS}
    | TO { GROUP groupname | NODE ( nodename [, ... ] ) }
    | ADD NODE ( nodename [, ... ] )
    | DELETE NODE ( nodename [, ... ] )
    | UPDATE SLICE LIKE table_name
    | DISABLE TRIGGER [ trigger_name | ALL | USER ]
    | ENABLE TRIGGER [ trigger_name | ALL | USER ]
    | ENABLE REPLICA TRIGGER trigger_name
    | ENABLE ALWAYS TRIGGER trigger_name
    | ENABLE ROW LEVEL SECURITY
    | DISABLE ROW LEVEL SECURITY
    | FORCE ROW LEVEL SECURITY
    | NO FORCE ROW LEVEL SECURITY
    | ENCRYPTION KEY ROTATION
where column_clause can be:
ADD [ COLUMN ] column_name data_type [ compress_mode ] [ COLLATE collation ] [ column_constraint [ ... ] ]
    | MODIFY column_name data_type
    | MODIFY column_name [ CONSTRAINT constraint_name ] NOT NULL [ ENABLE ]
    | MODIFY column_name [ CONSTRAINT constraint_name ] NULL
    | DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
    | ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
    | ALTER [ COLUMN ] column_name { SET DEFAULT expression | DROP DEFAULT }
    | ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
    | ALTER [ COLUMN ] column_name SET STATISTICS [PERCENT] integer
    | ADD STATISTICS (( column_1_name, column_2_name [, ...] ))
    | DELETE STATISTICS (( column_1_name, column_2_name [, ...] ))
    | ALTER [ COLUMN ] column_name SET ( {attribute_option = value} [, ... ] )
    | ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )
    | ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
where column_constraint can be:
[ CONSTRAINT constraint_name ]
    { NOT NULL |
      NULL |
      CHECK ( expression ) |
      DEFAULT default_expr |
      GENERATED ALWAYS AS ( generation_expr ) STORED |
      UNIQUE index_parameters |
      PRIMARY KEY index_parameters |
      ENCRYPTED WITH ( COLUMN_ENCRYPTION_KEY = column_encryption_key, ENCRYPTION_TYPE = encryption_type_value ) |
      REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
        [ ON DELETE action ] [ ON UPDATE action ] }
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
where compress_mode can be:
{ DELTA | PREFIX | DICTIONARY | NUMSTR | NOCOMPRESS }
where table_constraint can be:
[ CONSTRAINT constraint_name ]
    { CHECK ( expression ) |
      UNIQUE ( column_name [, ... ] ) index_parameters |
      PRIMARY KEY ( column_name [, ... ] ) index_parameters |
      PARTIAL CLUSTER KEY ( column_name [, ... ] ) |
      FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]
        [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE action ] [ ON UPDATE action ] }
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
where index_parameters can be:
[ WITH ( {storage_parameter = value} [, ... ] ) ]
    [ USING INDEX TABLESPACE tablespace_name ]
where table_constraint_using_index can be:
[ CONSTRAINT constraint_name ]
    { UNIQUE | PRIMARY KEY } USING INDEX index_name
    [ DEFERRABLE | NOT DEFERRABLE | INITIALLY DEFERRED | INITIALLY IMMEDIATE ]

--custom script
--create table
CREATE TABLE TBL_DOMAIN
(
  IDOMAINID   NUMBER(10) NOT NULL,
  SDOMAINNAME VARCHAR2(30) NOT NULL
);
--create/recreate primary, unique and foreign key constraints 
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT PK_TBL_DOMAIN PRIMARY KEY (IDOMAINID)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "pk_tbl_domain" for table "tbl_domain"
  
ALTER TABLE TBL_DOMAIN
  ADD CONSTRAINT IX_TBL_DOMAIN UNIQUE (SDOMAINNAME)
  USING INDEX ;
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "ix_tbl_domain" for table "tbl_domain"
\d+ TBL_DOMAIN
                                Table "public.tbl_domain"
   Column    |         Type          | Modifiers | Storage  | Stats target | Description 
-------------+-----------------------+-----------+----------+--------------+-------------
 idomainid   | numeric(10,0)         | not null  | main     |              | 
 sdomainname | character varying(30) | not null  | extended |              | 
Indexes:
    "pk_tbl_domain" PRIMARY KEY, btree (idomainid) TABLESPACE pg_default
    "ix_tbl_domain" UNIQUE CONSTRAINT, btree (sdomainname) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE TBL_DOMAIN;
--create table
CREATE TABLE TBL_CM_MAXTSENDTOHOST
(
  I_MODULETYPE  NUMBER(38) NOT NULL,
  I_MODULENO    NUMBER(38) NOT NULL,
  I_PLAMODULENO NUMBER(38) NOT NULL,
  I_TABLEID     NUMBER(38) NOT NULL,
  I_OLDMAXTUPLE NUMBER(38) NOT NULL,
  I_NEWMAXTUPLE NUMBER(38) NOT NULL,
  I_RESERVED1   NUMBER(38) DEFAULT 0,
  I_RESERVED2   NUMBER(38) DEFAULT 0,
  I_RESERVED3   NUMBER(38) DEFAULT 0,
  I_RESERVED4   NUMBER(38) DEFAULT 0,
  I_RESERVED5   NUMBER(38) DEFAULT 0,
  I_RESERVED6   NUMBER(38) DEFAULT 0,
  I_RESERVED7   NUMBER(38) DEFAULT 0,
  SV_RESERVED8  VARCHAR2(32) DEFAULT '',
  SV_RESERVED9  VARCHAR2(32) DEFAULT '',
  SV_RESERVED10 VARCHAR2(32) DEFAULT ''
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
--add primary key
ALTER TABLE TBL_CM_MAXTSENDTOHOST
  ADD PRIMARY KEY (I_PLAMODULENO, I_TABLEID)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_cm_maxtsendtohost_pkey" for table "tbl_cm_maxtsendtohost"
 \d+ TBL_CM_MAXTSENDTOHOST
                                      Table "public.tbl_cm_maxtsendtohost"
    Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
---------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_moduletype  | numeric(38,0)         | not null                        | main     |              | 
 i_moduleno    | numeric(38,0)         | not null                        | main     |              | 
 i_plamoduleno | numeric(38,0)         | not null                        | main     |              | 
 i_tableid     | numeric(38,0)         | not null                        | main     |              | 
 i_oldmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_newmaxtuple | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6   | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7   | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9  | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10 | character varying(32) | default NULL::character varying | extended |              | 
Indexes:
    "tbl_cm_maxtsendtohost_pkey" PRIMARY KEY, btree (i_plamoduleno, i_tableid) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

 DROP TABLE TBL_CM_MAXTSENDTOHOST;
--create table
CREATE TABLE TBL_LICCTRLDESC_DEFAULT
(
  I_INDEX        NUMBER(38) NOT NULL,
  SV_FEATURENAME VARCHAR2(64) NOT NULL,
  SV_ITEMNAME    VARCHAR2(64) NOT NULL,
  I_ITEMTYPE     NUMBER(38) NOT NULL,
  I_ITEMVALUEMIN NUMBER(38) NOT NULL,
  I_ITEMVALUEMAX NUMBER(38) NOT NULL,
  I_RESERVED1    NUMBER(38) DEFAULT 0,
  I_RESERVED2    NUMBER(38) DEFAULT 0,
  I_RESERVED3    NUMBER(38) DEFAULT 0,
  I_RESERVED4    NUMBER(38) DEFAULT 0,
  I_RESERVED5    NUMBER(38) DEFAULT 0,
  I_RESERVED6    NUMBER(38) DEFAULT 0,
  I_RESERVED7    NUMBER(38) DEFAULT 0,
  SV_RESERVED8   VARCHAR2(32) DEFAULT '',
  SV_RESERVED9   VARCHAR2(32) DEFAULT '',
  SV_RESERVED10  VARCHAR2(32) DEFAULT '',
  I_STATUS       NUMBER(38) NOT NULL
)
  PCTFREE 10
  INITRANS 1
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
--add primary key
ALTER TABLE TBL_LICCTRLDESC_DEFAULT
  ADD PRIMARY KEY (I_INDEX)
  USING INDEX 
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "tbl_licctrldesc_default_pkey" for table "tbl_licctrldesc_default"
--add unique index
CREATE UNIQUE INDEX IDX_TBL_LICCTRL_DEF ON TBL_LICCTRLDESC_DEFAULT (I_INDEX DESC, I_STATUS)
  PCTFREE 10
  INITRANS 2
  MAXTRANS 255
  STORAGE
  (
    INITIAL 64K
    MINEXTENTS 1
    MAXEXTENTS UNLIMITED
  );
\d+ TBL_LICCTRLDESC_DEFAULT
                                      Table "public.tbl_licctrldesc_default"
     Column     |         Type          |            Modifiers            | Storage  | Stats target | Description 
----------------+-----------------------+---------------------------------+----------+--------------+-------------
 i_index        | numeric(38,0)         | not null                        | main     |              | 
 sv_featurename | character varying(64) | not null                        | extended |              | 
 sv_itemname    | character varying(64) | not null                        | extended |              | 
 i_itemtype     | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemin | numeric(38,0)         | not null                        | main     |              | 
 i_itemvaluemax | numeric(38,0)         | not null                        | main     |              | 
 i_reserved1    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved2    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved3    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved4    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved5    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved6    | numeric(38,0)         | default 0                       | main     |              | 
 i_reserved7    | numeric(38,0)         | default 0                       | main     |              | 
 sv_reserved8   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved9   | character varying(32) | default NULL::character varying | extended |              | 
 sv_reserved10  | character varying(32) | default NULL::character varying | extended |              | 
 i_status       | numeric(38,0)         | not null                        | main     |              | 
Indexes:
    "tbl_licctrldesc_default_pkey" PRIMARY KEY, btree (i_index) TABLESPACE pg_default
    "idx_tbl_licctrl_def" UNIQUE, btree (i_index DESC, i_status) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

 DROP TABLE TBL_LICCTRLDESC_DEFAULT;
--using index clause
CREATE TABLE STUDENTS
(
	ID INT,
	NAME VARCHAR2(20),
	AGE INT,
	ADDRESS VARCHAR(30)
);
 --alter table to add unique index or primary key 
ALTER TABLE STUDENTS ADD UNIQUE (ID)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "students_id_key" for table "students"
ALTER TABLE STUDENTS ADD CONSTRAINT ZHANGYG UNIQUE (AGE, ADDRESS)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD UNIQUE will create implicit index "zhangyg" for table "students"
ALTER TABLE STUDENTS ADD PRIMARY KEY (AGE)
USING INDEX
PCTFREE 10
INITRANS 2
MAXTRANS 255
STORAGE
(
  INITIAL 64K
  MINEXTENTS 1
  MAXEXTENTS UNLIMITED
);
NOTICE:  ALTER TABLE / ADD PRIMARY KEY will create implicit index "students_pkey" for table "students"
\d+ STUDENTS
                               Table "public.students"
 Column  |         Type          | Modifiers | Storage  | Stats target | Description 
---------+-----------------------+-----------+----------+--------------+-------------
 id      | integer               |           | plain    |              | 
 name    | character varying(20) |           | extended |              | 
 age     | integer               | not null  | plain    |              | 
 address | character varying(30) |           | extended |              | 
Indexes:
    "students_pkey" PRIMARY KEY, btree (age) TABLESPACE pg_default
    "students_id_key" UNIQUE CONSTRAINT, btree (id) TABLESPACE pg_default
    "zhangyg" UNIQUE CONSTRAINT, btree (age, address) TABLESPACE pg_default
Has OIDs: no
Options: orientation=row, compression=no

DROP TABLE STUDENTS;
--simulate A db's ALTER TABLE gram
CREATE TABLE MODIFY_TABLE_A(I INTEGER);
ALTER TABLE MODIFY_TABLE_A ADD (mychar CHAR); 
ALTER TABLE MODIFY_TABLE_A ADD (myint1 INT, mychar1 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD (myint2 INT, mychar2 CHAR, mychar3 CHAR);
ALTER TABLE MODIFY_TABLE_A ADD a CHAR, ADD b CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 

ALTER TABLE MODIFY_TABLE_A ADD mychar4 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | integer      | 
 mychar  | character(1) | 
 myint1  | integer      | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY I VARCHAR2(64);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character varying(64) | 
 mychar  | character(1)          | 
 myint1  | integer               | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY I CHAR, MODIFY myint1 CHAR;
\d MODIFY_TABLE_A
   Table "public.modify_table_a"
 Column  |     Type     | Modifiers 
---------+--------------+-----------
 i       | character(1) | 
 mychar  | character(1) | 
 myint1  | character(1) | 
 mychar1 | character(1) | 
 myint2  | integer      | 
 mychar2 | character(1) | 
 mychar3 | character(1) | 
 a       | character(1) | 
 b       | character(1) | 
 mychar4 | character(1) | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(12));
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(12) | 
 mychar1 | character(1)          | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

ALTER TABLE MODIFY_TABLE_A MODIFY (myint1 VARCHAR(13), mychar1 INT);
\d MODIFY_TABLE_A
        Table "public.modify_table_a"
 Column  |         Type          | Modifiers 
---------+-----------------------+-----------
 i       | character(1)          | 
 mychar  | character(1)          | 
 myint1  | character varying(13) | 
 mychar1 | integer               | 
 myint2  | integer               | 
 mychar2 | character(1)          | 
 mychar3 | character(1)          | 
 a       | character(1)          | 
 b       | character(1)          | 
 mychar4 | character(1)          | 

DROP TABLE MODIFY_TABLE_A;
create table test_alter_type(a int,b text);
alter table test_alter_type alter column a type regclass;
DROP TABLE test_alter_type;
create table test_mod(a int,b text);
alter table test_mod alter column a type regclass;
alter table test_mod alter column a set default "d";
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
alter table test_mod alter column a set default "d"::int + 1;
ERROR:  default value cannot reference to a column
HINT:  Perhaps the default value is enclosed in double quotes
drop table test_mod;
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name ADD( { element_list_clause } [, ...] )
--simulate A db and postgresql, ALTER TABLE IF EXISTS table_name MODIFY( { element_list_clause } [, ...] )
create schema  columnar_storage;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 modify (c_int varchar(20));
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 modify (c_int varchar(20), c_double  varchar(20));
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
create table columnar_storage.create_columnar_add_common_008 (c_tinyint  tinyint,c_smallint smallint,c_int integer,c_bigint   bigint,c_money    money,c_numeric   numeric,c_real      real,c_double    double precision,c_decimal   decimal,c_varchar   varchar,c_char   char(30),c_nvarchar2  nvarchar2,c_text text,c_timestamp   timestamp with time zone,c_timestamptz timestamp without time zone,c_date     date,c_time     time without time zone,c_timetz   time with time zone,c_interval  interval,c_tinterval   tinterval,c_smalldatetime   smalldatetime,c_bytea   bytea,c_boolean  boolean,c_inet inet,c_cidr cidr,c_bit bit(10),c_varbit varbit(10),c_oid oid) with (orientation=column);
alter table if exists columnar_storage.create_columnar_add_common_007 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
NOTICE:  relation "create_columnar_add_common_007" does not exist, skipping
alter table if exists columnar_storage.create_columnar_add_common_008 add (c_time_008 time without time zone,c_timetz_008  time with time zone);
select * from columnar_storage.create_columnar_add_common_008;
 c_tinyint | c_smallint | c_int | c_bigint | c_money | c_numeric | c_real | c_double | c_decimal | c_varchar | c_char | c_nvarchar2 | c_text | c_timestamp | c_timestamptz | c_date | c_time | c_timetz | c_interval | c_tinterval | c_smalldatetime | c_bytea | c_boolean | c_inet | c_cidr | c_bit | c_varbit | c_oid | c_time_008 | c_timetz_008 
-----------+------------+-------+----------+---------+-----------+--------+----------+-----------+-----------+--------+-------------+--------+-------------+---------------+--------+--------+----------+------------+-------------+-----------------+---------+-----------+--------+--------+-------+----------+-------+------------+--------------
(0 rows)

drop table columnar_storage.create_columnar_add_common_008;
drop schema columnar_storage;
create table test_drop_column_1 (a int, b int, c int);
create table test_drop_column_2 (a int, b int);
create table test_drop_column_3 (a int, b int);
alter table test_drop_column_1 drop column c;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Seq Scan on public.test_drop_column_2
         Output: test_drop_column_2.a, test_drop_column_2.b, NULL::integer
(3 rows)

insert into test_drop_column_1 select * from test_drop_column_2;
explain (verbose true, costs false) insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Subquery Scan on "*SELECT*"
         Output: "*SELECT*".a, "*SELECT*".b, NULL::integer
         ->  Sort
               Output: test_drop_column_2.a, test_drop_column_2.b
               Sort Key: test_drop_column_2.b
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.b
(8 rows)

insert into test_drop_column_1 select * from test_drop_column_2 order by 2;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
         Hash Cond: (test_drop_column_2.a = test_drop_column_3.a)
         ->  Seq Scan on public.test_drop_column_2
               Output: test_drop_column_2.a, test_drop_column_2.b
         ->  Hash
               Output: test_drop_column_3.a
               ->  Seq Scan on public.test_drop_column_3
                     Output: test_drop_column_3.a
(10 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.a;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_2.a, test_drop_column_3.a, NULL::integer
         Hash Cond: (test_drop_column_2.a = test_drop_column_3.b)
         ->  Seq Scan on public.test_drop_column_2
               Output: test_drop_column_2.a, test_drop_column_2.b
         ->  Hash
               Output: test_drop_column_3.a, test_drop_column_3.b
               ->  Seq Scan on public.test_drop_column_3
                     Output: test_drop_column_3.a, test_drop_column_3.b
(10 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b;
explain (verbose true, costs false) insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Insert on public.test_drop_column_1
   ->  Subquery Scan on "*SELECT*"
         Output: "*SELECT*".a, "*SELECT*".a, NULL::integer
         ->  Sort
               Output: test_drop_column_2.a, test_drop_column_3.a
               Sort Key: test_drop_column_2.a, test_drop_column_3.a
               ->  Hash Join
                     Output: test_drop_column_2.a, test_drop_column_3.a
                     Hash Cond: (test_drop_column_2.a = test_drop_column_3.b)
                     ->  Seq Scan on public.test_drop_column_2
                           Output: test_drop_column_2.a, test_drop_column_2.b
                     ->  Hash
                           Output: test_drop_column_3.a, test_drop_column_3.b
                           ->  Seq Scan on public.test_drop_column_3
                                 Output: test_drop_column_3.a, test_drop_column_3.b
(15 rows)

insert into test_drop_column_1 select test_drop_column_2.a, test_drop_column_3.a from test_drop_column_2, test_drop_column_3 where test_drop_column_2.a = test_drop_column_3.b order by 1, 2;
explain (verbose true, costs false) update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Update on public.test_drop_column_1
   ->  Nested Loop
         Output: test_drop_column_2.a, test_drop_column_1.b, NULL::integer, test_drop_column_1.ctid, test_drop_column_2.ctid
         ->  Seq Scan on public.test_drop_column_1
               Output: test_drop_column_1.b, test_drop_column_1.ctid
         ->  Materialize
               Output: test_drop_column_2.a, test_drop_column_2.ctid
               ->  Seq Scan on public.test_drop_column_2
                     Output: test_drop_column_2.a, test_drop_column_2.ctid
(9 rows)

update test_drop_column_1 set a=test_drop_column_2.a from test_drop_column_2;
explain (verbose true, costs false) delete from test_drop_column_1 where a in (select a from test_drop_column_2);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Delete on public.test_drop_column_1
   ->  Hash Join
         Output: test_drop_column_1.ctid, test_drop_column_2.ctid
         Hash Cond: (test_drop_column_1.a = test_drop_column_2.a)
         ->  Seq Scan on public.test_drop_column_1
               Output: test_drop_column_1.ctid, test_drop_column_1.a
         ->  Hash
               Output: test_drop_column_2.ctid, test_drop_column_2.a
               ->  HashAggregate
                     Output: test_drop_column_2.ctid, test_drop_column_2.a
                     Group By Key: test_drop_column_2.a
                     ->  Seq Scan on public.test_drop_column_2
                           Output: test_drop_column_2.ctid, test_drop_column_2.a
(13 rows)

delete from test_drop_column_1 where a in (select a from test_drop_column_2);
create table test_drop_column_cstore_1 (a int, b int, c int) with (orientation = column);
create table test_drop_column_cstore_2 (a int, b int) with (orientation = column);
create table test_drop_column_cstore_3 (a int) with (orientation = column);
alter table test_drop_column_cstore_1 drop column c;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2;
insert into test_drop_column_cstore_1 select * from test_drop_column_cstore_2 order by 2;
insert into test_drop_column_cstore_1 select test_drop_column_cstore_2.a, test_drop_column_cstore_3.a from test_drop_column_cstore_2, test_drop_column_cstore_3 where test_drop_column_cstore_2.a = test_drop_column_cstore_3.a;
drop table test_drop_column_1;
drop table test_drop_column_2;
drop table test_drop_column_3;
drop table test_drop_column_cstore_1;
drop table test_drop_column_cstore_2;
drop table test_drop_column_cstore_3;
create table test_hash (a int, b int);
create sequence test_seq1;
alter table test_hash alter column a type serial; --fail 
ERROR:  cannot alter column type to "serial"
alter table test_hash alter column a set default nextval('test_seq1'); 
insert into test_hash(b) values(generate_series(1,10));
alter table test_hash add column c serial; --not supported
ERROR:  It's not supported to alter table add serial column
alter table test_hash add column d int default nextval('test_seq1'); --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
alter table test_hash add column e int default nextval('test_seq1')*10; --not supported
ERROR:  It's not supported to alter table add column default with nextval expression.
drop table test_hash;
drop sequence test_seq1;
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text);
insert into at_base_table values (23, 'skidoo');
create view at_view_1 as select * from at_base_table bt;
create view at_view_2 as select *, v1 as j from at_view_1 v1;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
View definition:
 SELECT  *
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT  *, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                   QUERY PLAN                    
-------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff)
(2 rows)

select * from at_view_2;
 id | stuff  |      j      
----+--------+-------------
 23 | skidoo | (23,skidoo)
(1 row)

create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt;
\d+ at_view_1
                View "public.at_view_1"
 Column |  Type   | Modifiers | Storage  | Description 
--------+---------+-----------+----------+-------------
 id     | integer |           | plain    | 
 stuff  | text    |           | extended | 
 more   | integer |           | plain    | 
View definition:
 SELECT  *, 2 + 2 AS more
   FROM at_base_table bt;

\d+ at_view_2
                 View "public.at_view_2"
 Column |   Type    | Modifiers | Storage  | Description 
--------+-----------+-----------+----------+-------------
 id     | integer   |           | plain    | 
 stuff  | text      |           | extended | 
 j      | at_view_1 |           | extended | 
View definition:
 SELECT  *, v1.*::at_view_1 AS j
   FROM at_view_1 v1;

explain (verbose, costs off) select * from at_view_2;
                      QUERY PLAN                       
-------------------------------------------------------
 Seq Scan on public.at_base_table bt
   Output: bt.id, bt.stuff, ROW(bt.id, bt.stuff, NULL)
(2 rows)

select * from at_view_2;
 id | stuff  |      j       
----+--------+--------------
 23 | skidoo | (23,skidoo,)
(1 row)

drop view at_view_2;
drop view at_view_1;
drop table at_base_table;
create table tt_row_rep_1(a int);
alter table tt_row_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_row_rep_2(a int, b int);
alter table tt_row_rep_2 drop column b;
alter table tt_row_rep_2 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_1(a int) with(orientation=column);
alter table tt_col_rep_1 drop column a;
ERROR:  must have at least one column
create table tt_col_rep_2(a int, b int) with(orientation=column);
alter table tt_col_rep_2 drop column b;
alter table tt_col_rep_2 drop column a;
ERROR:  must have at least one column
drop table tt_row_rep_1;
drop table tt_row_rep_2;
drop table tt_col_rep_1;
drop table tt_col_rep_2;
select pg_catalog.ledger_hist_repair('0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000', 65536);
ERROR:  The schema name exceeds the maximum length.
CONTEXT:  referenced column: ledger_hist_repair
