---
-- test range partition with START/END syntax. 2018/5/11
--
-- Part-1: test syntax logic and integer (smallint, int, bigint)
-- Part-2: test float(float4, double) and numeric
-- Part-3: test date and timestamp(6) without time zone
-- Part-4: test timestamp(6) with time zone
-- Part-5: test add partition with start/end
-- Part-6: test split partition with start/end
-- Part-7: start/end vs less/than
-- Part-8: test other cases(col-table, tablespace, etc.)
-- 
drop schema if exists schema_start_end_s cascade;
NOTICE:  schema "schema_start_end_s" does not exist, skipping
create schema schema_start_end_s;
set current_schema=schema_start_end_s;
set datestyle='ISO,MDY';
set time zone 'PRC';
---
-- Part-1: test syntax logic and integer (smallint, int, bigint)
---
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (''));
ERROR:  Partition key value can not be null
DETAIL:  partition bound element must be one of: string, datetime or interval literal, number, or MAXVALUE, and not null
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (0), partition p2 start(''));
ERROR:  Partition key value can not be null
DETAIL:  partition bound element must be one of: string, datetime or interval literal, number, or MAXVALUE, and not null
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 end (1), partition p2 end (''));
ERROR:  Partition key value can not be null
DETAIL:  partition bound element must be one of: string, datetime or interval literal, number, or MAXVALUE, and not null
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start(0) end (10) every(''));
ERROR:  Partition key value can not be null
DETAIL:  partition bound element must be one of: string, datetime or interval literal, number, or MAXVALUE, and not null
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start(0) end ('') every(1));
ERROR:  Partition key value can not be null
DETAIL:  partition bound element must be one of: string, datetime or interval literal, number, or MAXVALUE, and not null
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 varchar(20)) partition by range(c2) (partition p1 start('a') end ('b'));
ERROR:  datatype of column "c2" is unsupported for partition key in start/end clause.
HINT:  Valid datatypes are: smallint, int, bigint, float4/real, float8/double, numeric, date and timestamp [with time zone].
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (MINVALUE) end (MAXVALUE));
ERROR:  column "minvalue" does not exist
LINE 1: ... int) partition by range(c1) (partition p1 start (MINVALUE) ...
                                                             ^
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (-100) every (30));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (-30));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (101));
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p1 end (MAXVALUE));
ERROR:  duplicate partition name: "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p1_1 end (500));
ERROR:  duplicate partition name: "p1_1".
HINT:  partitions defined by (START, END, EVERY) are named as "partitionName_x" where x is an integer and starts from 0 or 1.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (-100));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (100), partition p2 start(20));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 end (100), partition p2 end(20));
ERROR:  end value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 int) partition by range (c1, c2) (partition p1 start(1));
ERROR:  partitioned table has too many partition keys.
HINT:  start/end syntax requires a partitioned table with only one partition key.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 int) partition by range (c1) (partition p1 start(1, 2));
ERROR:  too many partition keys for partition "p1".
HINT:  only one partition key is allowed in start/end clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range (c1) (partition p1 start(1));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {NULL}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range (c1) (partition p1 end(1));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {1}
 t1      | r        | r            | 
(2 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range (c1) (partition p1 end(MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {NULL}
 t1      | r        | r            | 
(2 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {31}
 p1_2    | p        | r            | {61}
 p1_3    | p        | r            | {91}
 p1_4    | p        | r            | {100}
 t1      | r        | r            | 
(6 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (40));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (200));
ERROR:  start value of partition "p2" is too high.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (100));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {31}
 p1_2    | p        | r            | {61}
 p1_3    | p        | r            | {91}
 p1_4    | p        | r            | {100}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 end (20));
ERROR:  end value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 end (200));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {31}
 p1_2    | p        | r            | {61}
 p1_3    | p        | r            | {91}
 p1_4    | p        | r            | {100}
 p2      | p        | r            | {200}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (40) end (200));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (200) end (400));
ERROR:  start value of partition "p2" is too high.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100) every (30), partition p2 start (100) end (200));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {31}
 p1_2    | p        | r            | {61}
 p1_3    | p        | r            | {91}
 p1_4    | p        | r            | {100}
 p2      | p        | r            | {200}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (100), partition p2 start (40));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1), partition p2 start (200), partition p3 start(100));
ERROR:  start value of partition "p3" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (MAXVALUE), partition p2 start (100));
ERROR:  start value can not be MAXVALUE for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1), partition p2 start (100), partition p3 start(200));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {100}
 p2      | p        | r            | {200}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (100), partition p2 start (100), partition p3 end (200));
ERROR:  partition "p3" is an invalid definition clause.
HINT:  Do not use a single END after a single START.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (200), partition p2 end(100));
ERROR:  end value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (MAXVALUE) end (200), partition p2 end(300));
ERROR:  start value can not be MAXVALUE for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (200), partition p2 end(300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {200}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(4 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 end (1), partition p2 end (MAXVALUE), partition p3 end(200));
ERROR:  partition "p3" is not allowed behind MAXVALUE.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 end (1), partition p2 end (100), partition p3 end(200));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {1}
 p2      | p        | r            | {100}
 p3      | p        | r            | {200}
 t1      | r        | r            | 
(4 rows)

drop table t1;
create table t1 (c1 int) partition by range(c1) (
	partition p1 end (1), 
	partition p2 start(1), 
	partition p3 start(100) end (200) every (50),
	partition p4 start(200) end (1000) every (500),
	partition p5 start (1000) end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {1}
 p2      | p        | r            | {100}
 p3_1    | p        | r            | {150}
 p3_2    | p        | r            | {200}
 p4_1    | p        | r            | {700}
 p4_2    | p        | r            | {1000}
 p5      | p        | r            | {NULL}
 t1      | r        | r            | 
(8 rows)

drop table t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start(1) end (200) every (50), partition p2 start(100) end (1000), partition p3 start(1000) end (2000));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start(1) end (200) every (50), partition p2 start(400) end (1000), partition p3 start(1000) end (2000));
ERROR:  start value of partition "p2" is too high.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start(1) end (200) every (50), partition p2 start(200) end (1000), partition p3 start(1000) end (2000));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {51}
 p1_2    | p        | r            | {101}
 p1_3    | p        | r            | {151}
 p1_4    | p        | r            | {200}
 p2      | p        | r            | {1000}
 p3      | p        | r            | {2000}
 t1      | r        | r            | 
(8 rows)

drop table t1;
-- smallint: [-32768, 32767]
-- start, end, every value must be a smallint; every value must be positive; partition number must be no more than 32767
-- smallint-failure
create table t1 (c1 smallint) partition by range(c1) (partition p1 end (-32769), partition p2 end (MAXVALUE));
ERROR:  smallint out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (0) end (32767) every (-1), partition p2 end (MAXVALUE));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (1) end (-1) every (1), partition p2 end (MAXVALUE));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (-32768) end (32767) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (-32768) end (32767) every (65535), partition p2 end (MAXVALUE));
ERROR:  smallint out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (0) end (32766) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (0) end (32765) every (1), partition p2 start(32765), partition p3 start(32766));
ERROR:  too many partitions after split partition "p3".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (-32768) end (32767) every (32767), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (32761) end (32767) every (4), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (0.5) end (10) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (1) end (10.1) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (-1) end (10) every(5.01));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- smallint-success
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (-1.0) end (10) every(5.0));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {-1}
 p1_1    | p        | r            | {4}
 p1_2    | p        | r            | {9}
 p1_3    | p        | r            | {10}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 smallint) partition by range(c1) (partition p1 start (32761) end (32767) every (3), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {32761}
 p1_1    | p        | r            | {32764}
 p1_2    | p        | r            | {32767}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 smallint) partition by range(c1) (
	partition p1 end (-32768), 
	partition p2 end (0), 
	partition p3 end (100),
	partition p4 start (100),
	partition p5 start (200),
	partition p6 start(400) end (1000) every (499),
	partition p7 start(1000) end (10000) every (5001),
	partition p8 start(10000) end (32767),
	partition p9 end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {-32768}
 p2      | p        | r            | {0}
 p3      | p        | r            | {100}
 p4      | p        | r            | {200}
 p5      | p        | r            | {400}
 p6_1    | p        | r            | {899}
 p6_2    | p        | r            | {1000}
 p7_1    | p        | r            | {6001}
 p7_2    | p        | r            | {10000}
 p8      | p        | r            | {32767}
 p9      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- int: [-2147483648, 2147483647]
-- start, end, every value must be a int; every value must be positive; partition number must be no more than 32767
-- int-failure
create table t1 (c1 int) partition by range(c1) (partition p1 end (-2147483649), partition p2 end (MAXVALUE));
ERROR:  integer out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (0) end (2147483647) every (-1), partition p2 end (MAXVALUE));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (-1) every (1), partition p2 end (MAXVALUE));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (-2147483648) end (2147483647) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (-2147483648) end (2147483647) every (4294967295), partition p2 end (MAXVALUE));
ERROR:  integer out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (2147450881) end (2147483647) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (-2147483648) end (2147483647) every (2147483647), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (2147483641) end (2147483647) every (4), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (0.5) end (10) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (1) end (10.1) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int) partition by range(c1) (partition p1 start (-1) end (10) every(5.01));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- int-success
create table t1 (c1 int) partition by range(c1) (partition p1 start (-1.0) end (10) every(5.0));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {-1}
 p1_1    | p        | r            | {4}
 p1_2    | p        | r            | {9}
 p1_3    | p        | r            | {10}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 start (2147483641) end (2147483647) every (3), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |  boundaries  
---------+----------+--------------+--------------
 p1_0    | p        | r            | {2147483641}
 p1_1    | p        | r            | {2147483644}
 p1_2    | p        | r            | {2147483647}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (
	partition p1 end (-2147483648), 
	partition p2 end (0), 
	partition p3 end (100),
	partition p4 start (100),
	partition p5 start (200),
	partition p6 start(400) end (1000) every (499),
	partition p7 start(1000) end (10000) every (5001),
	partition p8 start(10000) end (2147483647),
	partition p9 end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |  boundaries   
---------+----------+--------------+---------------
 p1      | p        | r            | {-2147483648}
 p2      | p        | r            | {0}
 p3      | p        | r            | {100}
 p4      | p        | r            | {200}
 p5      | p        | r            | {400}
 p6_1    | p        | r            | {899}
 p6_2    | p        | r            | {1000}
 p7_1    | p        | r            | {6001}
 p7_2    | p        | r            | {10000}
 p8      | p        | r            | {2147483647}
 p9      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- bigint: [-9223372036854775808, 9223372036854775807]
-- start, end, every value must be a bigint; every value must be positive; partition number must be no more than 32767
-- bigint-failure
create table t1 (c1 bigint) partition by range(c1) (partition p1 end (-9223372036854775809), partition p2 end (MAXVALUE));
ERROR:  bigint out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (0) end (9223372036854775807) every (-1), partition p2 end (MAXVALUE));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (1) end (-1) every (1), partition p2 end (MAXVALUE));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (-9223372036854775808) end (9223372036854775807) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (-9223372036854775808) end (9223372036854775807) every (18446744073709551615), partition p2 end (MAXVALUE));
ERROR:  bigint out of range
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (9223372036854743041) end (9223372036854775807) every (1), partition p2 end (MAXVALUE));
ERROR:  too many partitions after split partition "p1".
HINT:  number of partitions can not be more than 32767, MINVALUE will be auto-included if not assigned.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (-9223372036854775808) end (9223372036854775807) every (9223372036854775807), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (9223372036854775801) end (9223372036854775807) every (4), partition p2 end (MAXVALUE));
drop table if exists t1;
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (0.5) end (10) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (1) end (10.1) every(5));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (-1) end (10) every(5.01));
ERROR:  start/end/every value must be an const-integer for partition "p1"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- bigint-success
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (-1.0) end (10) every(5.0));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {-1}
 p1_1    | p        | r            | {4}
 p1_2    | p        | r            | {9}
 p1_3    | p        | r            | {10}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 bigint) partition by range(c1) (partition p1 start (9223372036854775801) end (9223372036854775807) every (3), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |      boundaries       
---------+----------+--------------+-----------------------
 p1_0    | p        | r            | {9223372036854775801}
 p1_1    | p        | r            | {9223372036854775804}
 p1_2    | p        | r            | {9223372036854775807}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 bigint) partition by range(c1) (
	partition p1 end (-9223372036854775808), 
	partition p2 end (0), 
	partition p3 end (100),
	partition p4 start (100),
	partition p5 start (200),
	partition p6 start(400) end (1000) every (499),
	partition p7 start(1000) end (10000) every (5001),
	partition p8 start(10000) end (9223372036854775807),
	partition p9 end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries       
---------+----------+--------------+------------------------
 p1      | p        | r            | {-9223372036854775808}
 p2      | p        | r            | {0}
 p3      | p        | r            | {100}
 p4      | p        | r            | {200}
 p5      | p        | r            | {400}
 p6_1    | p        | r            | {899}
 p6_2    | p        | r            | {1000}
 p7_1    | p        | r            | {6001}
 p7_2    | p        | r            | {10000}
 p8      | p        | r            | {9223372036854775807}
 p9      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
---
-- Part-2: test float(float4, float8) and numeric
---
-- float4-failure
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(1e39));
ERROR:  value out of range: overflow
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 end(1e39));
ERROR:  value out of range: overflow
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end (1) every(1e39));
ERROR:  value out of range: overflow
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end (10.001) every(-1));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end (2e38) every(1e38));
ERROR:  ambiguous partition rule is raised by EVERY parameter in partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end ('infinity') every(1));  -- not allowed
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end (3.14) every('infinity'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start('infinity'), partition p2 start (0) end (3.14) every(1));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(-1), partition p2 start (0) end (3.14) every(1), partition p3 end ('infinity'), partition p4 end (20.01));
ERROR:  end value of partition "p4" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(1) end (1.00007) every(0.00001));  -- cast(0.00001 as float4) inaccurate, report ambiguous
ERROR:  ambiguous partition rule is raised by EVERY parameter in partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- float4-success
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start('infinity'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {Infinity}
 p1_1    | p        | r            | {NULL}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 end ('infinity'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {Infinity}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(0) end (3.14) every(1), partition p2 end ('infinity')); -- it's ok
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 p1_1    | p        | r            | {1}
 p1_2    | p        | r            | {2}
 p1_3    | p        | r            | {3}
 p1_4    | p        | r            | {3.14}
 p2      | p        | r            | {Infinity}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float4) partition by range(c2) (partition p1 start(1.00001) end (10.00001) every(1)); -- cast(10.00001 as float4) == 10
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.00001}
 p1_1    | p        | r            | {2.00001}
 p1_2    | p        | r            | {3.00001}
 p1_3    | p        | r            | {4.00001}
 p1_4    | p        | r            | {5.00001}
 p1_5    | p        | r            | {6.00001}
 p1_6    | p        | r            | {7.00001}
 p1_7    | p        | r            | {8.00001}
 p1_8    | p        | r            | {9.00001}
 p1_9    | p        | r            | {10}
 t1      | r        | r            | 
(11 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float4) partition by range(c2) (
	partition p1 start(1.00001) end (5.00007) every(1),
	partition p2 end (8.1),
	partition p3 start(8.1) end (20.03) every(4),
	partition p4 start(20.03)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.00001}
 p1_1    | p        | r            | {2.00001}
 p1_2    | p        | r            | {3.00001}
 p1_3    | p        | r            | {4.00001}
 p1_4    | p        | r            | {5.00001}
 p1_5    | p        | r            | {5.00007}
 p2      | p        | r            | {8.1}
 p3_1    | p        | r            | {12.1}
 p3_2    | p        | r            | {16.1}
 p3_3    | p        | r            | {20.03}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- float8-failure
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(1e309));
ERROR:  "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" is out of range for type double precision
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 end(1e309));
ERROR:  "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" is out of range for type double precision
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (1) every(1e309));
ERROR:  "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" is out of range for type double precision
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (1) every(1e39));
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (1) every(0));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (1e308) every(9e307));
drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end ('infinity') every(1));  -- not allowed
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (3.14) every('infinity'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start('infinity'), partition p2 start (0) end (3.14) every(1));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(-1), partition p2 start (0) end (3.14) every(1), partition p3 end ('infinity'), partition p4 end (20.01));
ERROR:  end value of partition "p4" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(1) end (1.000000000000007) every(0.000000000000001));  -- report ambiguous
ERROR:  ambiguous partition rule is raised by EVERY parameter in partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- float8-success
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start('infinity'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {Infinity}
 p1_1    | p        | r            | {NULL}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 end ('infinity'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {Infinity}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (3.14) every(1), partition p2 end ('infinity')); -- it's ok
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 p1_1    | p        | r            | {1}
 p1_2    | p        | r            | {2}
 p1_3    | p        | r            | {3}
 p1_4    | p        | r            | {3.14}
 p2      | p        | r            | {Infinity}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(1) end (1.00000000000007) every(0.00000000000001));  -- ok, just do it
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |     boundaries     
---------+----------+--------------+--------------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {1.00000000000001}
 p1_2    | p        | r            | {1.00000000000002}
 p1_3    | p        | r            | {1.00000000000003}
 p1_4    | p        | r            | {1.00000000000004}
 p1_5    | p        | r            | {1.00000000000005}
 p1_6    | p        | r            | {1.00000000000006}
 p1_7    | p        | r            | {1.00000000000007}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(1) end (1.00007) every(0.00001));  -- cast(0.00001 as float8) == 0.000010000000000
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {1.00001}
 p1_2    | p        | r            | {1.00002}
 p1_3    | p        | r            | {1.00003}
 p1_4    | p        | r            | {1.00004}
 p1_5    | p        | r            | {1.00005}
 p1_6    | p        | r            | {1.00006}
 p1_7    | p        | r            | {1.00007}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(1.00001) end (10.00001) every(1)); -- cast(10.00001 as float8) == 10.000010000000000
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.00001}
 p1_1    | p        | r            | {2.00001}
 p1_2    | p        | r            | {3.00001}
 p1_3    | p        | r            | {4.00001}
 p1_4    | p        | r            | {5.00001}
 p1_5    | p        | r            | {6.00001}
 p1_6    | p        | r            | {7.00001}
 p1_7    | p        | r            | {8.00001}
 p1_8    | p        | r            | {9.00001}
 p1_9    | p        | r            | {10.00001}
 t1      | r        | r            | 
(11 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (partition p1 start(0) end (1e308) every(6e307));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 p1_1    | p        | r            | {6e+307}
 p1_2    | p        | r            | {1e+308}
 t1      | r        | r            | 
(4 rows)

drop table if exists t1;
create table t1 (c1 int, c2 float8) partition by range(c2) (
	partition p1 start(1.00001) end (5.00007) every(1),
	partition p2 end (8.1),
	partition p3 start(8.1) end (20.03) every(4.009),
	partition p4 start(20.03)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.00001}
 p1_1    | p        | r            | {2.00001}
 p1_2    | p        | r            | {3.00001}
 p1_3    | p        | r            | {4.00001}
 p1_4    | p        | r            | {5.00001}
 p1_5    | p        | r            | {5.00007}
 p2      | p        | r            | {8.1}
 p3_1    | p        | r            | {12.109}
 p3_2    | p        | r            | {16.118}
 p3_3    | p        | r            | {20.03}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- numeric-failure
create table t1 (c1 int, c2 numeric) partition by range(c2) (partition p1 start('nan') end (123.456) every (2.11));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric) partition by range(c2) (partition p1 start(123.456) end ('nan') every (2.11));
ERROR:  partition "p1" is invalid.
HINT:  NaN can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric) partition by range(c2) (partition p1 start(123.456) end (345.1) every ('nan'));
ERROR:  partition "p1" is invalid.
HINT:  NaN can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range(c2) (partition p1 start('nan') end (123.456) every (2.11));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range(c2) (partition p1 start(123.456) end ('nan') every (2.11));
ERROR:  partition "p1" is invalid.
HINT:  NaN can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range(c2) (partition p1 start(123.456) end (345.1) every ('nan'));
ERROR:  partition "p1" is invalid.
HINT:  NaN can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric) partition by range(c2) (partition p1 start(1.00000000000000000000000000000000000000001) end (1.00000000000000000000000000000000000000007) every (0.00000000000000000000000000000000000000007));
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (10000000000.00001) end (10000000000.00003)); -- 10000000000.00003::numeric(15,4) == 10000000000.0000
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (10000000000.00001) end (10000000000.00007) every (0.00001)); -- ambiguous partition rule
ERROR:  ambiguous partition rule is raised by EVERY parameter in partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (10000000000.0001) end (10000000000.0007) every (0.00001)); 
ERROR:  ambiguous partition rule is raised by EVERY parameter in partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (100000000000.0001) end (10000000000.0006) every (0.0002));
ERROR:  numeric field overflow
DETAIL:  A field with precision 15, scale 4 must round to an absolute value less than 10^11.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (10000000000.0001) end (10000000000.0006) every (100000000000.0001));
ERROR:  numeric field overflow
DETAIL:  A field with precision 15, scale 4 must round to an absolute value less than 10^11.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
-- numeric-success
create table t1 (c1 int, c2 numeric) partition by range(c2) (partition p1 start(1.00000000000000000000000000000000000000001) end (1.00000000000000000000000000000000000000007) every (0.00000000000000000000000000000000000000001));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |                  boundaries                   
---------+----------+--------------+-----------------------------------------------
 p1_0    | p        | r            | {1.00000000000000000000000000000000000000001}
 p1_1    | p        | r            | {1.00000000000000000000000000000000000000002}
 p1_2    | p        | r            | {1.00000000000000000000000000000000000000003}
 p1_3    | p        | r            | {1.00000000000000000000000000000000000000004}
 p1_4    | p        | r            | {1.00000000000000000000000000000000000000005}
 p1_5    | p        | r            | {1.00000000000000000000000000000000000000006}
 p1_6    | p        | r            | {1.00000000000000000000000000000000000000007}
 t1      | r        | r            | 
(8 rows)

drop table if exists t1;
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (10000000000.0001) end (10000000000.0007) every (0.0001));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |     boundaries     
---------+----------+--------------+--------------------
 p1_0    | p        | r            | {10000000000.0001}
 p1_1    | p        | r            | {10000000000.0002}
 p1_2    | p        | r            | {10000000000.0003}
 p1_3    | p        | r            | {10000000000.0004}
 p1_4    | p        | r            | {10000000000.0005}
 p1_5    | p        | r            | {10000000000.0006}
 p1_6    | p        | r            | {10000000000.0007}
 t1      | r        | r            | 
(8 rows)

drop table if exists t1;
create table t1 (c1 int, c2 numeric(15,4)) partition by range (c2) (partition p1 start (99999999993.0001) end (99999999999.0006) every (3.0002));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |     boundaries     
---------+----------+--------------+--------------------
 p1_0    | p        | r            | {99999999993.0001}
 p1_1    | p        | r            | {99999999996.0003}
 p1_2    | p        | r            | {99999999999.0005}
 p1_3    | p        | r            | {99999999999.0006}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int, c2 numeric) partition by range(c2) (
	partition p1 start(1.00001) end (5.00007) every(1),
	partition p2 end (8.1),
	partition p3 start(8.1) end (20.03) every(4.009),
	partition p4 start(20.03)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.00001}
 p1_1    | p        | r            | {2.00001}
 p1_2    | p        | r            | {3.00001}
 p1_3    | p        | r            | {4.00001}
 p1_4    | p        | r            | {5.00001}
 p1_5    | p        | r            | {5.00007}
 p2      | p        | r            | {8.1}
 p3_1    | p        | r            | {12.109}
 p3_2    | p        | r            | {16.118}
 p3_3    | p        | r            | {20.03}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
create table t1 (c1 int, c2 numeric(15,4)) partition by range(c2) (
	partition p1 start(1.00001) end (5.00007) every(1),
	partition p2 end (8.1),
	partition p3 start(8.1) end (20.03) every(4.009),
	partition p4 start(20.03)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1.0000}
 p1_1    | p        | r            | {2.0000}
 p1_2    | p        | r            | {3.0000}
 p1_3    | p        | r            | {4.0000}
 p1_4    | p        | r            | {5.0000}
 p1_5    | p        | r            | {5.0001}
 p2      | p        | r            | {8.1000}
 p3_1    | p        | r            | {12.1090}
 p3_2    | p        | r            | {16.1180}
 p3_3    | p        | r            | {20.0300}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
---
-- Part-3: test date and timestamp(6) without time zone, NOTE: date == timestamp(0) without time zone 
---
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-01-2014') every ('3 year'));
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2015') end ('12-01-2014') every ('1 year'));
ERROR:  start value must be less than end value for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-01-2014') every ('0 year'));
ERROR:  partition step is too small for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-01-2014') every ('1 year'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 00:00:00"}
 p1_1    | p        | r            | {"2013-12-01 00:00:00"}
 p1_2    | p        | r            | {"2014-12-01 00:00:00"}
 t1      | r        | r            | 
(4 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2019'), partition p2 start('12-01-2012') end ('12-01-2014') every ('1 year'), partition p3 end (MAXVALUE));
ERROR:  start value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2009'), partition p2 start('12-01-2012') end ('12-01-2014') every ('1 year'), partition p3 end ('12-01-2013'));
ERROR:  end value of partition "p3" is too low.
HINT:  partition gap or overlapping is not allowed.
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-01-2014') every ('1 year'), partition p3 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 00:00:00"}
 p1_1    | p        | r            | {"2013-12-01 00:00:00"}
 p1_2    | p        | r            | {"2014-12-01 00:00:00"}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-01-2013') every ('1 month'), partition p3 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 00:00:00"}
 p1_1    | p        | r            | {"2013-01-01 00:00:00"}
 p1_10   | p        | r            | {"2013-10-01 00:00:00"}
 p1_11   | p        | r            | {"2013-11-01 00:00:00"}
 p1_12   | p        | r            | {"2013-12-01 00:00:00"}
 p1_2    | p        | r            | {"2013-02-01 00:00:00"}
 p1_3    | p        | r            | {"2013-03-01 00:00:00"}
 p1_4    | p        | r            | {"2013-04-01 00:00:00"}
 p1_5    | p        | r            | {"2013-05-01 00:00:00"}
 p1_6    | p        | r            | {"2013-06-01 00:00:00"}
 p1_7    | p        | r            | {"2013-07-01 00:00:00"}
 p1_8    | p        | r            | {"2013-08-01 00:00:00"}
 p1_9    | p        | r            | {"2013-09-01 00:00:00"}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(15 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('12-01-2012') end ('12-05-2012') every ('1 day'), partition p3 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 00:00:00"}
 p1_1    | p        | r            | {"2012-12-02 00:00:00"}
 p1_2    | p        | r            | {"2012-12-03 00:00:00"}
 p1_3    | p        | r            | {"2012-12-04 00:00:00"}
 p1_4    | p        | r            | {"2012-12-05 00:00:00"}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 16:13:14') every ('1 hour'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 13:13:14"}
 p1_2    | p        | r            | {"2012-12-01 14:13:14"}
 p1_3    | p        | r            | {"2012-12-01 15:13:14"}
 p1_4    | p        | r            | {"2012-12-01 16:13:14"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 12:15:15') every ('1 minute'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 12:14:14"}
 p1_2    | p        | r            | {"2012-12-01 12:15:14"}
 p1_3    | p        | r            | {"2012-12-01 12:15:15"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(6 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 12:13:18') every ('1 second'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 12:13:15"}
 p1_2    | p        | r            | {"2012-12-01 12:13:16"}
 p1_3    | p        | r            | {"2012-12-01 12:13:17"}
 p1_4    | p        | r            | {"2012-12-01 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 12:13:18') every ('1.599999 second'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 12:13:16"}
 p1_2    | p        | r            | {"2012-12-01 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
-- interval day to hour
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every (interval '1 12' day to hour), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:13:14"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every ('1 12:'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:13:14"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
-- interval day to minute
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every (interval '1 12:12' day to minute), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:25:14"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every ('1 12:12'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:25:14"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
-- interval day to second
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every (interval '1 12:12' day to second), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:25:14"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-03-2012 12:13:18') every ('1 12:12:12'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-03 00:25:26"}
 p1_2    | p        | r            | {"2012-12-03 12:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
-- interval hour to minute
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 18:13:18') every (interval '1:12' hour to minute), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 13:25:14"}
 p1_2    | p        | r            | {"2012-12-01 14:37:14"}
 p1_3    | p        | r            | {"2012-12-01 15:49:14"}
 p1_4    | p        | r            | {"2012-12-01 17:01:14"}
 p1_5    | p        | r            | {"2012-12-01 18:13:14"}
 p1_6    | p        | r            | {"2012-12-01 18:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 18:13:18') every ('1:12'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 13:25:14"}
 p1_2    | p        | r            | {"2012-12-01 14:37:14"}
 p1_3    | p        | r            | {"2012-12-01 15:49:14"}
 p1_4    | p        | r            | {"2012-12-01 17:01:14"}
 p1_5    | p        | r            | {"2012-12-01 18:13:14"}
 p1_6    | p        | r            | {"2012-12-01 18:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
-- interval hour to minute
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 18:13:18') every (interval '1:12:12' hour to second), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 13:25:26"}
 p1_2    | p        | r            | {"2012-12-01 14:37:38"}
 p1_3    | p        | r            | {"2012-12-01 15:49:50"}
 p1_4    | p        | r            | {"2012-12-01 17:02:02"}
 p1_5    | p        | r            | {"2012-12-01 18:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(8 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 18:13:18') every ('1:12:12'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 13:25:26"}
 p1_2    | p        | r            | {"2012-12-01 14:37:38"}
 p1_3    | p        | r            | {"2012-12-01 15:49:50"}
 p1_4    | p        | r            | {"2012-12-01 17:02:02"}
 p1_5    | p        | r            | {"2012-12-01 18:13:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(8 rows)

drop table if exists t1;
-- interval minute to second
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 12:23:18') every (interval '1:12' minute to second), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 12:14:26"}
 p1_2    | p        | r            | {"2012-12-01 12:15:38"}
 p1_3    | p        | r            | {"2012-12-01 12:16:50"}
 p1_4    | p        | r            | {"2012-12-01 12:18:02"}
 p1_5    | p        | r            | {"2012-12-01 12:19:14"}
 p1_6    | p        | r            | {"2012-12-01 12:20:26"}
 p1_7    | p        | r            | {"2012-12-01 12:21:38"}
 p1_8    | p        | r            | {"2012-12-01 12:22:50"}
 p1_9    | p        | r            | {"2012-12-01 12:23:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14') end ('12-01-2012 12:23:18') every ('0:1:12'), partition p2 end (MAXVALUE));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |       boundaries        
---------+----------+--------------+-------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14"}
 p1_1    | p        | r            | {"2012-12-01 12:14:26"}
 p1_2    | p        | r            | {"2012-12-01 12:15:38"}
 p1_3    | p        | r            | {"2012-12-01 12:16:50"}
 p1_4    | p        | r            | {"2012-12-01 12:18:02"}
 p1_5    | p        | r            | {"2012-12-01 12:19:14"}
 p1_6    | p        | r            | {"2012-12-01 12:20:26"}
 p1_7    | p        | r            | {"2012-12-01 12:21:38"}
 p1_8    | p        | r            | {"2012-12-01 12:22:50"}
 p1_9    | p        | r            | {"2012-12-01 12:23:18"}
 p2      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- general
create table t1 (c1 int, c2 timestamp(6)) 
partition by range (c2) (
	partition p1 start ('12-01-2012 12:13:14.999999') end ('12-01-2012 12:23:15.888888') every ('0:01:14.333333'), 
	partition p2 end ('12-03-2018'), 
	partition p3 start ('12-03-2018') end ('12-04-2019') every ('1 month'), 
	partition p4 start ('12-04-2019') end ('12-05-2022 12:13:14') every (interval '1 year'), 
	partition p5 start ('12-05-2022 12:13:14.000001'), 
	partition p6 start ('12-04-2032 12:11:10.333333') end ('12-05-2033 12:13:14.999999') every (interval '3 11:12:13.222222' day to second), 
	partition p7 end (MAXVALUE)
);
ERROR:  start value of partition "p5" is too high.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) 
partition by range (c2) (
	partition p1 start ('12-01-2012 12:13:14.999999') end ('12-01-2012 12:23:15.888888') every ('0:01:14.333333'), 
	partition p2 end ('12-03-2018'), 
	partition p3 start ('12-03-2018') end ('12-04-2019') every ('1 month'), 
	partition p4 start ('12-04-2019') end ('12-05-2022 12:13:14') every (interval '1 year'), 
	partition p5 start ('12-05-2022 12:13:14'), 
	partition p6 start ('11-04-2032 12:11:10.333333') end ('12-01-2032 12:13:14.999999') every (interval '3 11:12:13.222222' day to second), 
	partition p7 end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |           boundaries           
---------+----------+--------------+--------------------------------
 p1_0    | p        | r            | {"2012-12-01 12:13:14.999999"}
 p1_1    | p        | r            | {"2012-12-01 12:14:29.333332"}
 p1_2    | p        | r            | {"2012-12-01 12:15:43.666665"}
 p1_3    | p        | r            | {"2012-12-01 12:16:57.999998"}
 p1_4    | p        | r            | {"2012-12-01 12:18:12.333331"}
 p1_5    | p        | r            | {"2012-12-01 12:19:26.666664"}
 p1_6    | p        | r            | {"2012-12-01 12:20:40.999997"}
 p1_7    | p        | r            | {"2012-12-01 12:21:55.33333"}
 p1_8    | p        | r            | {"2012-12-01 12:23:09.666663"}
 p1_9    | p        | r            | {"2012-12-01 12:23:15.888888"}
 p2      | p        | r            | {"2018-12-03 00:00:00"}
 p3_1    | p        | r            | {"2019-01-03 00:00:00"}
 p3_10   | p        | r            | {"2019-10-03 00:00:00"}
 p3_11   | p        | r            | {"2019-11-03 00:00:00"}
 p3_12   | p        | r            | {"2019-12-03 00:00:00"}
 p3_13   | p        | r            | {"2019-12-04 00:00:00"}
 p3_2    | p        | r            | {"2019-02-03 00:00:00"}
 p3_3    | p        | r            | {"2019-03-03 00:00:00"}
 p3_4    | p        | r            | {"2019-04-03 00:00:00"}
 p3_5    | p        | r            | {"2019-05-03 00:00:00"}
 p3_6    | p        | r            | {"2019-06-03 00:00:00"}
 p3_7    | p        | r            | {"2019-07-03 00:00:00"}
 p3_8    | p        | r            | {"2019-08-03 00:00:00"}
 p3_9    | p        | r            | {"2019-09-03 00:00:00"}
 p4_1    | p        | r            | {"2020-12-04 00:00:00"}
 p4_2    | p        | r            | {"2021-12-04 00:00:00"}
 p4_3    | p        | r            | {"2022-12-04 00:00:00"}
 p4_4    | p        | r            | {"2022-12-05 12:13:14"}
 p5      | p        | r            | {"2032-11-04 12:11:10.333333"}
 p6_1    | p        | r            | {"2032-11-07 23:23:23.555555"}
 p6_2    | p        | r            | {"2032-11-11 10:35:36.777777"}
 p6_3    | p        | r            | {"2032-11-14 21:47:49.999999"}
 p6_4    | p        | r            | {"2032-11-18 09:00:03.222221"}
 p6_5    | p        | r            | {"2032-11-21 20:12:16.444443"}
 p6_6    | p        | r            | {"2032-11-25 07:24:29.666665"}
 p6_7    | p        | r            | {"2032-11-28 18:36:42.888887"}
 p6_8    | p        | r            | {"2032-12-01 12:13:14.999999"}
 p7      | p        | r            | {NULL}
 t1      | r        | r            | 
(39 rows)

drop table if exists t1;
---
-- Part-4: test timestamp(6) with time zone, NOTE: BJ-Time=GMT+8, PST=UTC-8, GMT=UTC (roughly), so input: xx PST <==> in-gaussdb: xx + 16 GMT+8
---
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-02-2018 12:13:15.888888 pst') every ('1 year'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2013-12-02 04:13:14.999999+08"}
 p1_2    | p        | r            | {"2014-12-02 04:13:14.999999+08"}
 p1_3    | p        | r            | {"2015-12-02 04:13:14.999999+08"}
 p1_4    | p        | r            | {"2016-12-02 04:13:14.999999+08"}
 p1_5    | p        | r            | {"2017-12-02 04:13:14.999999+08"}
 p1_6    | p        | r            | {"2018-12-02 04:13:14.999999+08"}
 p1_7    | p        | r            | {"2018-12-03 04:13:15.888888+08"}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-02-2013 12:13:15.888888 pst') every ('1 month'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2013-01-02 04:13:14.999999+08"}
 p1_10   | p        | r            | {"2013-10-02 04:13:14.999999+08"}
 p1_11   | p        | r            | {"2013-11-02 04:13:14.999999+08"}
 p1_12   | p        | r            | {"2013-12-02 04:13:14.999999+08"}
 p1_13   | p        | r            | {"2013-12-03 04:13:15.888888+08"}
 p1_2    | p        | r            | {"2013-02-02 04:13:14.999999+08"}
 p1_3    | p        | r            | {"2013-03-02 04:13:14.999999+08"}
 p1_4    | p        | r            | {"2013-04-02 04:13:14.999999+08"}
 p1_5    | p        | r            | {"2013-05-02 04:13:14.999999+08"}
 p1_6    | p        | r            | {"2013-06-02 04:13:14.999999+08"}
 p1_7    | p        | r            | {"2013-07-02 04:13:14.999999+08"}
 p1_8    | p        | r            | {"2013-08-02 04:13:14.999999+08"}
 p1_9    | p        | r            | {"2013-09-02 04:13:14.999999+08"}
 t1      | r        | r            | 
(15 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('1 day'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 04:13:14.999999+08"}
 p1_2    | p        | r            | {"2012-12-04 04:13:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-05 04:13:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-06 04:13:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-07 04:13:14.999999+08"}
 p1_6    | p        | r            | {"2012-12-08 04:13:14.999999+08"}
 p1_7    | p        | r            | {"2012-12-09 04:13:14.999999+08"}
 p1_8    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(10 rows)

drop table if exists t1;
-- interval day to hour
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every (interval '1 12' day to hour));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:13:14.999999+08"}
 p1_2    | p        | r            | {"2012-12-05 04:13:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-06 16:13:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-08 04:13:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('1 12:'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:13:14.999999+08"}
 p1_2    | p        | r            | {"2012-12-05 04:13:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-06 16:13:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-08 04:13:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
-- interval day to minute
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every (interval '1 12:13' day to minute));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:26:14.999999+08"}
 p1_2    | p        | r            | {"2012-12-05 04:39:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-06 16:52:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-08 05:05:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('1 12:13'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:26:14.999999+08"}
 p1_2    | p        | r            | {"2012-12-05 04:39:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-06 16:52:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-08 05:05:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
-- interval day to second
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every (interval '1 12:13:14.333333' day to second));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:26:29.333332+08"}
 p1_2    | p        | r            | {"2012-12-05 04:39:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-06 16:52:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-08 05:06:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('1 12:13:14.333333'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-03 16:26:29.333332+08"}
 p1_2    | p        | r            | {"2012-12-05 04:39:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-06 16:52:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-08 05:06:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
-- interval hour to minute
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every (interval '12:13' hour to minute));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 16:26:14.999999+08"}
 p1_10   | p        | r            | {"2012-12-07 06:23:14.999999+08"}
 p1_11   | p        | r            | {"2012-12-07 18:36:14.999999+08"}
 p1_12   | p        | r            | {"2012-12-08 06:49:14.999999+08"}
 p1_13   | p        | r            | {"2012-12-08 19:02:14.999999+08"}
 p1_14   | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 p1_2    | p        | r            | {"2012-12-03 04:39:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-03 16:52:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-04 05:05:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-04 17:18:14.999999+08"}
 p1_6    | p        | r            | {"2012-12-05 05:31:14.999999+08"}
 p1_7    | p        | r            | {"2012-12-05 17:44:14.999999+08"}
 p1_8    | p        | r            | {"2012-12-06 05:57:14.999999+08"}
 p1_9    | p        | r            | {"2012-12-06 18:10:14.999999+08"}
 t1      | r        | r            | 
(16 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('12:13'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 16:26:14.999999+08"}
 p1_10   | p        | r            | {"2012-12-07 06:23:14.999999+08"}
 p1_11   | p        | r            | {"2012-12-07 18:36:14.999999+08"}
 p1_12   | p        | r            | {"2012-12-08 06:49:14.999999+08"}
 p1_13   | p        | r            | {"2012-12-08 19:02:14.999999+08"}
 p1_14   | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 p1_2    | p        | r            | {"2012-12-03 04:39:14.999999+08"}
 p1_3    | p        | r            | {"2012-12-03 16:52:14.999999+08"}
 p1_4    | p        | r            | {"2012-12-04 05:05:14.999999+08"}
 p1_5    | p        | r            | {"2012-12-04 17:18:14.999999+08"}
 p1_6    | p        | r            | {"2012-12-05 05:31:14.999999+08"}
 p1_7    | p        | r            | {"2012-12-05 17:44:14.999999+08"}
 p1_8    | p        | r            | {"2012-12-06 05:57:14.999999+08"}
 p1_9    | p        | r            | {"2012-12-06 18:10:14.999999+08"}
 t1      | r        | r            | 
(16 rows)

drop table if exists t1;
-- interval hour to second
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every (interval '12:13:14.333333' hour to second));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 16:26:29.333332+08"}
 p1_10   | p        | r            | {"2012-12-07 06:25:38.333329+08"}
 p1_11   | p        | r            | {"2012-12-07 18:38:52.666662+08"}
 p1_12   | p        | r            | {"2012-12-08 06:52:06.999995+08"}
 p1_13   | p        | r            | {"2012-12-08 19:05:21.333328+08"}
 p1_14   | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 p1_2    | p        | r            | {"2012-12-03 04:39:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-03 16:52:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-04 05:06:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-04 17:19:26.666664+08"}
 p1_6    | p        | r            | {"2012-12-05 05:32:40.999997+08"}
 p1_7    | p        | r            | {"2012-12-05 17:45:55.33333+08"}
 p1_8    | p        | r            | {"2012-12-06 05:59:09.666663+08"}
 p1_9    | p        | r            | {"2012-12-06 18:12:23.999996+08"}
 t1      | r        | r            | 
(16 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-08-2012 12:13:15.888888 pst') every ('12:13:14.333333'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 16:26:29.333332+08"}
 p1_10   | p        | r            | {"2012-12-07 06:25:38.333329+08"}
 p1_11   | p        | r            | {"2012-12-07 18:38:52.666662+08"}
 p1_12   | p        | r            | {"2012-12-08 06:52:06.999995+08"}
 p1_13   | p        | r            | {"2012-12-08 19:05:21.333328+08"}
 p1_14   | p        | r            | {"2012-12-09 04:13:15.888888+08"}
 p1_2    | p        | r            | {"2012-12-03 04:39:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-03 16:52:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-04 05:06:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-04 17:19:26.666664+08"}
 p1_6    | p        | r            | {"2012-12-05 05:32:40.999997+08"}
 p1_7    | p        | r            | {"2012-12-05 17:45:55.33333+08"}
 p1_8    | p        | r            | {"2012-12-06 05:59:09.666663+08"}
 p1_9    | p        | r            | {"2012-12-06 18:12:23.999996+08"}
 t1      | r        | r            | 
(16 rows)

drop table if exists t1;
-- interval minute to second 
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-01-2012 12:23:15.888888 pst') every (interval '1:14.333333' minute to second));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 04:14:29.333332+08"}
 p1_2    | p        | r            | {"2012-12-02 04:15:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-02 04:16:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-02 04:18:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-02 04:19:26.666664+08"}
 p1_6    | p        | r            | {"2012-12-02 04:20:40.999997+08"}
 p1_7    | p        | r            | {"2012-12-02 04:21:55.33333+08"}
 p1_8    | p        | r            | {"2012-12-02 04:23:09.666663+08"}
 p1_9    | p        | r            | {"2012-12-02 04:23:15.888888+08"}
 t1      | r        | r            | 
(11 rows)

drop table if exists t1;
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-01-2012 12:23:15.888888 pst') every ('0:01:14.333333'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 04:14:29.333332+08"}
 p1_2    | p        | r            | {"2012-12-02 04:15:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-02 04:16:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-02 04:18:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-02 04:19:26.666664+08"}
 p1_6    | p        | r            | {"2012-12-02 04:20:40.999997+08"}
 p1_7    | p        | r            | {"2012-12-02 04:21:55.33333+08"}
 p1_8    | p        | r            | {"2012-12-02 04:23:09.666663+08"}
 p1_9    | p        | r            | {"2012-12-02 04:23:15.888888+08"}
 t1      | r        | r            | 
(11 rows)

drop table if exists t1;
-- general
create table t1 (c1 int, c2 timestamp(6) with time zone) 
partition by range (c2) (
	partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-01-2012 12:23:15.888888 pst') every ('0:01:14.333333'), 
	partition p2 end ('12-03-2011'), 
	partition p3 start ('12-03-2018') end ('12-04-2019') every ('1 month'), 
	partition p4 end (MAXVALUE)
);
ERROR:  end value of partition "p2" is too low.
HINT:  partition gap or overlapping is not allowed.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6) with time zone) 
partition by range (c2) (
	partition p1 start ('12-01-2012 12:13:14.999999 pst') end ('12-01-2012 12:23:15.888888 pst') every ('0:01:14.333333'), 
	partition p2 end ('12-03-2018'), 
	partition p3 start ('12-03-2018') end ('12-04-2019') every ('1 month'), 
	partition p4 end (MAXVALUE)
);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |            boundaries             
---------+----------+--------------+-----------------------------------
 p1_0    | p        | r            | {"2012-12-02 04:13:14.999999+08"}
 p1_1    | p        | r            | {"2012-12-02 04:14:29.333332+08"}
 p1_2    | p        | r            | {"2012-12-02 04:15:43.666665+08"}
 p1_3    | p        | r            | {"2012-12-02 04:16:57.999998+08"}
 p1_4    | p        | r            | {"2012-12-02 04:18:12.333331+08"}
 p1_5    | p        | r            | {"2012-12-02 04:19:26.666664+08"}
 p1_6    | p        | r            | {"2012-12-02 04:20:40.999997+08"}
 p1_7    | p        | r            | {"2012-12-02 04:21:55.33333+08"}
 p1_8    | p        | r            | {"2012-12-02 04:23:09.666663+08"}
 p1_9    | p        | r            | {"2012-12-02 04:23:15.888888+08"}
 p2      | p        | r            | {"2018-12-03 00:00:00+08"}
 p3_1    | p        | r            | {"2019-01-03 00:00:00+08"}
 p3_10   | p        | r            | {"2019-10-03 00:00:00+08"}
 p3_11   | p        | r            | {"2019-11-03 00:00:00+08"}
 p3_12   | p        | r            | {"2019-12-03 00:00:00+08"}
 p3_13   | p        | r            | {"2019-12-04 00:00:00+08"}
 p3_2    | p        | r            | {"2019-02-03 00:00:00+08"}
 p3_3    | p        | r            | {"2019-03-03 00:00:00+08"}
 p3_4    | p        | r            | {"2019-04-03 00:00:00+08"}
 p3_5    | p        | r            | {"2019-05-03 00:00:00+08"}
 p3_6    | p        | r            | {"2019-06-03 00:00:00+08"}
 p3_7    | p        | r            | {"2019-07-03 00:00:00+08"}
 p3_8    | p        | r            | {"2019-08-03 00:00:00+08"}
 p3_9    | p        | r            | {"2019-09-03 00:00:00+08"}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(26 rows)

drop table if exists t1;
-- out of range
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('now') end ('infinity') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('-infinity') end ('now') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 date) partition by range (c2) (partition p1 start('now') end ('tomorrow') every ('infinity'));
ERROR:  invalid input syntax for type interval: "infinity"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('now') end ('infinity') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('-infinity') end ('now') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('now') end ('tomorrow') every ('infinity'));
ERROR:  invalid input syntax for type interval: "infinity"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start('now') end ('infinity') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start('-infinity') end ('now') every ('1 year'));
ERROR:  partition "p1" is invalid.
HINT:  INF can not appear in a (START, END, EVERY) clause.
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6) with time zone) partition by range (c2) (partition p1 start('now') end ('tomorrow') every ('infinity'));
ERROR:  invalid input syntax for type interval: "infinity"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('293400-12-01 12:13:14') end ('294000-12-01 12:13:14') every ('700 year')); 
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('293400-12-01 12:13:14') end ('294400-12-01 12:13:14') every ('1000 year'));
ERROR:  timestamp out of range: "294400-12-01 12:13:14"
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('293400-12-01 12:13:14') end ('294000-12-01 12:13:14') every ('1000 year'));
ERROR:  partition step is too big for partition "p1".
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 int, c2 timestamp(6)) partition by range (c2) (partition p1 start('293400-12-01 12:13:14') end ('294000-12-01 12:13:14') every ('600 year'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |        boundaries         
---------+----------+--------------+---------------------------
 p1_0    | p        | r            | {"293400-12-01 12:13:14"}
 p1_1    | p        | r            | {"294000-12-01 12:13:14"}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
---
-- Part-5: test add partition with start/end
---
-- test logic
create table t1 (c1 int) partition by range(c1) (partition p1 start(1) end(1000) every(300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {301}
 p1_2    | p        | r            | {601}
 p1_3    | p        | r            | {901}
 p1_4    | p        | r            | {1000}
 t1      | r        | r            | 
(6 rows)

alter table t1 add partition p1_2 start(1000);
ERROR:  adding partition name conflict with existing partitions: "p1_2".
alter table t1 add partition p2 start(999);
ERROR:  start value of partition "p2" NOT EQUAL up-boundary of last partition.
alter table t1 add partition p2 start(1000), partition p3 start(2000);
ERROR:  syntax error at or near "partition p3"
LINE 1: alter table t1 add partition p2 start(1000), partition p3 st...
                                                     ^
alter table t1 add partition p2 start(1000) end (maxvalue) every(1000);
ERROR:  partition "p2" is invalid.
HINT:  MAXVALUE can not appear in a (START, END, EVERY) clause.
alter table t1 add partition p2 start(1000) end (2000) every(maxvalue);
ERROR:  partition "p2" is invalid.
HINT:  MAXVALUE can not appear in a (START, END, EVERY) clause.
alter table t1 add partition p3 end (1500);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {301}
 p1_2    | p        | r            | {601}
 p1_3    | p        | r            | {901}
 p1_4    | p        | r            | {1000}
 p3      | p        | r            | {1500}
 t1      | r        | r            | 
(7 rows)

alter table t1 add partition p3 end (maxvalue);
ERROR:  adding partition name conflict with existing partitions: "p3".
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {301}
 p1_2    | p        | r            | {601}
 p1_3    | p        | r            | {901}
 p1_4    | p        | r            | {1000}
 p3      | p        | r            | {1500}
 t1      | r        | r            | 
(7 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(4 rows)

alter table t1 drop partition p3;
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(350) end (500) every (50);
ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition.
alter table t1 add partition p3 start(300) end (500) every (50); 
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {350}
 p3_2    | p        | r            | {400}
 p3_3    | p        | r            | {450}
 p3_4    | p        | r            | {500}
 t1      | r        | r            | 
(7 rows)

alter table t1 add partition p4 values less than (500);
ERROR:  upper boundary of adding partition MUST overtop last existing partition
alter table t1 add partition p4 values less than (800);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {350}
 p3_2    | p        | r            | {400}
 p3_3    | p        | r            | {450}
 p3_4    | p        | r            | {500}
 p4      | p        | r            | {800}
 t1      | r        | r            | 
(8 rows)

alter table t1 add partition p5 end (maxvalue);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {350}
 p3_2    | p        | r            | {400}
 p3_3    | p        | r            | {450}
 p3_4    | p        | r            | {500}
 p4      | p        | r            | {800}
 p5      | p        | r            | {NULL}
 t1      | r        | r            | 
(9 rows)

drop table if exists t1;
-- too many partition keys
create table t1 (c1 int, c2 timestamp) partition by range(c1, c2) (partition p1 values less than (1, '2012-12-01 12:13:14.11111'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |           boundaries            
---------+----------+--------------+---------------------------------
 p1      | p        | r            | {1,"2012-12-01 12:13:14.11111"}
 t1      | r        | r            | 
(2 rows)

alter table t1 add partition p2 start(1) end (100);
ERROR:  partitioned table has too many partition keys.
HINT:  start/end syntax requires a partitioned table with only one partition key.
alter table t1 add partition p2 start(1, '2012-12-01 12:13:14.11111') end (100, maxvalue);
ERROR:  partitioned table has too many partition keys.
HINT:  start/end syntax requires a partitioned table with only one partition key.
drop table if exists t1;
-- other datatype
create table t1 (c1 int, c2 timestamp) partition by range(c2) (partition p1 values less than ('2012-12-01 12:13:14.11111'));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |          boundaries           
---------+----------+--------------+-------------------------------
 p1      | p        | r            | {"2012-12-01 12:13:14.11111"}
 t1      | r        | r            | 
(2 rows)

alter table t1 add partition p2 end ('2014-12-01 12:13:15.11111');
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |          boundaries           
---------+----------+--------------+-------------------------------
 p1      | p        | r            | {"2012-12-01 12:13:14.11111"}
 p2      | p        | r            | {"2014-12-01 12:13:15.11111"}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start ('2014-12-01 12:13:15.11110');
ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition.
alter table t1 add partition p3 start ('2014-12-01 12:13:15.11111') end ('2014-12-08 11:12:13') every ('2 day');
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |          boundaries           
---------+----------+--------------+-------------------------------
 p1      | p        | r            | {"2012-12-01 12:13:14.11111"}
 p2      | p        | r            | {"2014-12-01 12:13:15.11111"}
 p3_1    | p        | r            | {"2014-12-03 12:13:15.11111"}
 p3_2    | p        | r            | {"2014-12-05 12:13:15.11111"}
 p3_3    | p        | r            | {"2014-12-07 12:13:15.11111"}
 p3_4    | p        | r            | {"2014-12-08 11:12:13"}
 t1      | r        | r            | 
(7 rows)

alter table t1 add partition p4 start ('2014-12-08 11:12:13.000000') end ('2015-02-08 11:14:13') every (interval '20 3:4:5.00010' day to second);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |          boundaries           
---------+----------+--------------+-------------------------------
 p1      | p        | r            | {"2012-12-01 12:13:14.11111"}
 p2      | p        | r            | {"2014-12-01 12:13:15.11111"}
 p3_1    | p        | r            | {"2014-12-03 12:13:15.11111"}
 p3_2    | p        | r            | {"2014-12-05 12:13:15.11111"}
 p3_3    | p        | r            | {"2014-12-07 12:13:15.11111"}
 p3_4    | p        | r            | {"2014-12-08 11:12:13"}
 p4_1    | p        | r            | {"2014-12-28 14:16:18.0001"}
 p4_2    | p        | r            | {"2015-01-17 17:20:23.0002"}
 p4_3    | p        | r            | {"2015-02-06 20:24:28.0003"}
 p4_4    | p        | r            | {"2015-02-08 11:14:13"}
 t1      | r        | r            | 
(11 rows)

alter table t1 add partition p5 end (maxvalue);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy |          boundaries           
---------+----------+--------------+-------------------------------
 p1      | p        | r            | {"2012-12-01 12:13:14.11111"}
 p2      | p        | r            | {"2014-12-01 12:13:15.11111"}
 p3_1    | p        | r            | {"2014-12-03 12:13:15.11111"}
 p3_2    | p        | r            | {"2014-12-05 12:13:15.11111"}
 p3_3    | p        | r            | {"2014-12-07 12:13:15.11111"}
 p3_4    | p        | r            | {"2014-12-08 11:12:13"}
 p4_1    | p        | r            | {"2014-12-28 14:16:18.0001"}
 p4_2    | p        | r            | {"2015-01-17 17:20:23.0002"}
 p4_3    | p        | r            | {"2015-02-06 20:24:28.0003"}
 p4_4    | p        | r            | {"2015-02-08 11:14:13"}
 p5      | p        | r            | {NULL}
 t1      | r        | r            | 
(12 rows)

drop table if exists t1;
-- many times partition operation-success
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300)end(400)every(10),add partition p4 start(400)end(500)every(10);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {310}
 p3_10   | p        | r            | {400}
 p3_2    | p        | r            | {320}
 p3_3    | p        | r            | {330}
 p3_4    | p        | r            | {340}
 p3_5    | p        | r            | {350}
 p3_6    | p        | r            | {360}
 p3_7    | p        | r            | {370}
 p3_8    | p        | r            | {380}
 p3_9    | p        | r            | {390}
 p4_1    | p        | r            | {410}
 p4_10   | p        | r            | {500}
 p4_2    | p        | r            | {420}
 p4_3    | p        | r            | {430}
 p4_4    | p        | r            | {440}
 p4_5    | p        | r            | {450}
 p4_6    | p        | r            | {460}
 p4_7    | p        | r            | {470}
 p4_8    | p        | r            | {480}
 p4_9    | p        | r            | {490}
 t1      | r        | r            | 
(23 rows)

alter table t1 add partition p5 start(500)end(600),add partition p6 start(600)end(700);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {310}
 p3_10   | p        | r            | {400}
 p3_2    | p        | r            | {320}
 p3_3    | p        | r            | {330}
 p3_4    | p        | r            | {340}
 p3_5    | p        | r            | {350}
 p3_6    | p        | r            | {360}
 p3_7    | p        | r            | {370}
 p3_8    | p        | r            | {380}
 p3_9    | p        | r            | {390}
 p4_1    | p        | r            | {410}
 p4_10   | p        | r            | {500}
 p4_2    | p        | r            | {420}
 p4_3    | p        | r            | {430}
 p4_4    | p        | r            | {440}
 p4_5    | p        | r            | {450}
 p4_6    | p        | r            | {460}
 p4_7    | p        | r            | {470}
 p4_8    | p        | r            | {480}
 p4_9    | p        | r            | {490}
 p5      | p        | r            | {600}
 p6      | p        | r            | {700}
 t1      | r        | r            | 
(25 rows)

alter table t1 drop partition p6,add partition p7 start(600)end(800);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 p3_1    | p        | r            | {310}
 p3_10   | p        | r            | {400}
 p3_2    | p        | r            | {320}
 p3_3    | p        | r            | {330}
 p3_4    | p        | r            | {340}
 p3_5    | p        | r            | {350}
 p3_6    | p        | r            | {360}
 p3_7    | p        | r            | {370}
 p3_8    | p        | r            | {380}
 p3_9    | p        | r            | {390}
 p4_1    | p        | r            | {410}
 p4_10   | p        | r            | {500}
 p4_2    | p        | r            | {420}
 p4_3    | p        | r            | {430}
 p4_4    | p        | r            | {440}
 p4_5    | p        | r            | {450}
 p4_6    | p        | r            | {460}
 p4_7    | p        | r            | {470}
 p4_8    | p        | r            | {480}
 p4_9    | p        | r            | {490}
 p5      | p        | r            | {600}
 p7      | p        | r            | {800}
 t1      | r        | r            | 
(25 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 drop partition p2,add partition p3 start(100)end(500);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p3      | p        | r            | {500}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(100)end(200),drop partition p2;
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p3      | p        | r            | {200}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
-- many times partition operation-failure
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300)end(400)every(10),add partition p4 start(450)end(500)every(10);
ERROR:  start value of partition "p4" NOT EQUAL up-boundary of last partition.
drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300)end(600),add partition p4 start(700)end(800);
ERROR:  start value of partition "p4" NOT EQUAL up-boundary of last partition.
drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 drop partition p2,add partition p3 start(300)end(500);
ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition.
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300)end(500),drop partition p2;
ERROR:  start value of partition "p3" NOT EQUAL up-boundary of last partition.
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p1 values less than (100), partition p2 values less than (300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

alter table t1 add partition p3 start(300),add partition p4 start(500);
ERROR:  upper boundary of adding partition MUST overtop last existing partition
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1      | p        | r            | {100}
 p2      | p        | r            | {300}
 t1      | r        | r            | 
(3 rows)

drop table if exists t1;
---
-- Part-6: test split partition with start/end
---
create table t1 (c1 int) partition by range(c1) (partition p1 start(0) end(3000));
alter table t1 split partition p1_1 at (1500) into (partition q1, partition q2);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 q1      | p        | r            | {1500}
 q2      | p        | r            | {3000}
 t1      | r        | r            | 
(4 rows)

-- split left-most partition
alter table t1 split partition for (-1) into (partition s3 start(-1000), partition s4 start(-500) end (0) every(30), partition s5 start(0));
ERROR:  start value of partition "s5" MUST be less than up-boundary of the partition to be splitted.
alter table t1 split partition for (-1) into (partition s3 start(-1000), partition s4 start(-500) end (-10) every(300), partition s5 start(-10));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q1      | p        | r            | {1500}
 q2      | p        | r            | {3000}
 s3_0    | p        | r            | {-1000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s4_2    | p        | r            | {-10}
 s5      | p        | r            | {0}
 t1      | r        | r            | 
(8 rows)

insert into t1 values (-11);
select c1 from t1;
 c1  
-----
 -11
(1 row)

alter table t1 drop partition s4_2;
select c1 from t1;
 c1 
----
(0 rows)

select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q1      | p        | r            | {1500}
 q2      | p        | r            | {3000}
 s3_0    | p        | r            | {-1000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 t1      | r        | r            | 
(7 rows)

alter table t1 split partition s3_0 into (partition s6 end(-1000));
ERROR:  the number of resulting partitions must be more than one
alter table t1 split partition s3_0 into (partition s6 end(-2000), partition s7 end(-1000));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q1      | p        | r            | {1500}
 q2      | p        | r            | {3000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s6      | p        | r            | {-2000}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
(8 rows)

alter table t1 drop partition s6;
insert into t1 values (-5000);
select c1 from t1;
  c1   
-------
 -5000
(1 row)

truncate table t1;
-- split middle partition
alter table t1 split partition for (1000) into (partition y1 end(-500), partition y2 start(500) end (1000));
ERROR:  end value of partition "y1" MUST be greater than up-boundary of last partition.
alter table t1 split partition for (1000) into (partition y1 end(500), partition y2 start(500) end (1000));
ERROR:  end value of partition "y2" NOT EQUAL up-boundary of the partition to be splitted.
alter table t1 split partition for (1000) into (partition y1 start(500), partition y2 start(700) end (1000));
ERROR:  start value of partition "y1" NOT EQUAL up-boundary of last partition.
alter table t1 split partition for (1000) into (partition y1 start(0));
ERROR:  the number of resulting partitions must be more than one
alter table t1 split partition for (1000) into (partition y1 start(0), partition y2 start(500), partition y3 end(1500));
ERROR:  partition "y3" is an invalid definition clause.
HINT:  Do not use a single END after a single START.
alter table t1 split partition for (1000) into (partition y1 start(0), partition y2 start(500), partition y3 start(800) end (2000));
ERROR:  end value of partition "y3" NOT EQUAL up-boundary of the partition to be splitted.
alter table t1 split partition for (1000) into (partition y1 start(0), partition y2 start(500), partition y3 start(800) end (1500) every(300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q2      | p        | r            | {3000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_1    | p        | r            | {1100}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(11 rows)

insert into t1 values (800);
select c1 from t1;
 c1  
-----
 800
(1 row)

alter table t1 drop partition for (800);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q2      | p        | r            | {3000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(10 rows)

select c1 from t1;
 c1 
----
(0 rows)

truncate table t1;
-- split right-most partition
alter table t1 split partition for (2000) into (partition q3 start(1500), partition q4 start(2000) end (3000) every(30), partition q5 start(3000));
ERROR:  start value of partition "q5" MUST be less than up-boundary of the partition to be splitted.
alter table t1 split partition q2 into (partition q3 start(1500), partition q4 start(1600) end (2000) every(300), partition q5 end(2200), partition q6 start(2200));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q3      | p        | r            | {1600}
 q4_1    | p        | r            | {1900}
 q4_2    | p        | r            | {2000}
 q5      | p        | r            | {2200}
 q6      | p        | r            | {3000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(14 rows)

alter table t1 add partition q7 start(3000) end (4000) every(800);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q3      | p        | r            | {1600}
 q4_1    | p        | r            | {1900}
 q4_2    | p        | r            | {2000}
 q5      | p        | r            | {2200}
 q6      | p        | r            | {3000}
 q7_1    | p        | r            | {3800}
 q7_2    | p        | r            | {4000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(16 rows)

insert into t1 values (3666);
select c1 from t1;
  c1  
------
 3666
(1 row)

alter table t1 drop partition q7_1;
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q3      | p        | r            | {1600}
 q4_1    | p        | r            | {1900}
 q4_2    | p        | r            | {2000}
 q5      | p        | r            | {2200}
 q6      | p        | r            | {3000}
 q7_2    | p        | r            | {4000}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(15 rows)

select c1 from t1;
 c1 
----
(0 rows)

alter table t1 add partition q8 end (maxvalue);
alter table t1 split partition for (4000) into (partition q91 start(4000) end (4500) every(200), partition q92 end(5000));
ERROR:  end value of partition "q92" NOT EQUAL up-boundary of the partition to be splitted.
alter table t1 split partition for (4000) into (partition q91 start(4000) end (4500) every(200), partition q92 end(maxvalue));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q3      | p        | r            | {1600}
 q4_1    | p        | r            | {1900}
 q4_2    | p        | r            | {2000}
 q5      | p        | r            | {2200}
 q6      | p        | r            | {3000}
 q7_2    | p        | r            | {4000}
 q91_1   | p        | r            | {4200}
 q91_2   | p        | r            | {4400}
 q91_3   | p        | r            | {4500}
 q92     | p        | r            | {NULL}
 s3_1    | p        | r            | {-500}
 s4_1    | p        | r            | {-200}
 s5      | p        | r            | {0}
 s7      | p        | r            | {-1000}
 t1      | r        | r            | 
 y1      | p        | r            | {500}
 y2      | p        | r            | {800}
 y3_2    | p        | r            | {1400}
 y3_3    | p        | r            | {1500}
(19 rows)

truncate table t1;
-- drop table
drop table if exists t1;
---
-- Part-7: start/end vs less/than
---
create table t1 (c1 int) partition by range(c1) (
	partition p1 start(0) end(100), 
	partition p2 end (200), 
	partition p3 start(200) end (400) every (40), 
	partition p4 start(400)
	);
create table t2 (c1 int) partition by range(c1) (
	partition p1_0 values less than (0), 
	partition p1_1 values less than (100),
	partition p2 values less than (200),
	partition p3_1 values less than (240),
	partition p3_2 values less than (280),
	partition p3_3 values less than (320),
	partition p3_4 values less than (360),
	partition p3_5 values less than (400),
	partition p4 values less than (MAXVALUE)
	);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 p1_1    | p        | r            | {100}
 p2      | p        | r            | {200}
 p3_1    | p        | r            | {240}
 p3_2    | p        | r            | {280}
 p3_3    | p        | r            | {320}
 p3_4    | p        | r            | {360}
 p3_5    | p        | r            | {400}
 p4      | p        | r            | {NULL}
 t1      | r        | r            | 
(10 rows)

select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t2'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {0}
 p1_1    | p        | r            | {100}
 p2      | p        | r            | {200}
 p3_1    | p        | r            | {240}
 p3_2    | p        | r            | {280}
 p3_3    | p        | r            | {320}
 p3_4    | p        | r            | {360}
 p3_5    | p        | r            | {400}
 p4      | p        | r            | {NULL}
 t2      | r        | r            | 
(10 rows)

select count(*) from pg_partition a1 where a1.parentid='schema_start_end_s.t1'::regclass and a1.relname in (
	select relname from pg_partition a2 where a2.parentid='schema_start_end_s.t2'::regclass and a2.boundaries=a1.boundaries
	);
 count 
-------
     9
(1 row)

drop table if exists t1;
drop table if exists t2;
---
-- Part-8: test other cases(col-table, tablespace, etc.)
---
-- partition name
create table t1 (c1 int) partition by range(c1) (partition p12345678901234567890123456789012345678901234567890123456789012345 end (MAXVALUE));
NOTICE:  identifier "p12345678901234567890123456789012345678901234567890123456789012345" will be truncated to "p12345678901234567890123456789012345678901234567890123456789012"
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
                             relname                             | parttype | partstrategy | boundaries 
-----------------------------------------------------------------+----------+--------------+------------
 p12345678901234567890123456789012345678901234567890123456789012 | p        | r            | {NULL}
 t1                                                              | r        | r            | 
(2 rows)

drop table if exists t1;
create table t1 (c1 int) partition by range(c1) (partition p12345678901234567890123456789012345678901234567890123456789012345 start(1) end (100) every(20));
NOTICE:  identifier "p12345678901234567890123456789012345678901234567890123456789012345" will be truncated to "p12345678901234567890123456789012345678901234567890123456789012"
NOTICE:  Partition name's prefix "p12345678901234567890123456789012345678901234567890123456789012" will be truncated to "p12345678901234567890123456789012345678901234567890123456"
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
                           relname                           | parttype | partstrategy | boundaries 
-------------------------------------------------------------+----------+--------------+------------
 p12345678901234567890123456789012345678901234567890123456_0 | p        | r            | {1}
 p12345678901234567890123456789012345678901234567890123456_1 | p        | r            | {21}
 p12345678901234567890123456789012345678901234567890123456_2 | p        | r            | {41}
 p12345678901234567890123456789012345678901234567890123456_3 | p        | r            | {61}
 p12345678901234567890123456789012345678901234567890123456_4 | p        | r            | {81}
 p12345678901234567890123456789012345678901234567890123456_5 | p        | r            | {100}
 t1                                                          | r        | r            | 
(7 rows)

drop table if exists t1;
-- col-table
create table t1 (c1 int) with (orientation=column) partition by range(c1) (partition p1 start(1), partition p2 start(100) end(300), partition p3 start(300));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {100}
 p2      | p        | r            | {300}
 p3      | p        | r            | {NULL}
 t1      | r        | r            | 
(5 rows)

insert into t1 values (400);
alter table t1 add column c2 int;
alter table t1 drop partition p3;
select c1,c2 from t1;
 c1 | c2 
----+----
(0 rows)

alter table t1 add partition p3 end(500);
select c1,c2 from t1;
 c1 | c2 
----+----
(0 rows)

select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {100}
 p2      | p        | r            | {300}
 p3      | p        | r            | {500}
 t1      | r        | r            | 
(5 rows)

drop table if exists t1;
-- tablespace
create tablespace tblspc_se_x001 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_1';
create tablespace tblspc_se_x002 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_2';
create tablespace tblspc_se_x003 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_3';
create tablespace tblspc_se_x004 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_4';
create tablespace tblspc_se_x005 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_5';
create tablespace tblspc_se_x006 location '@abs_srcdir@/tmp_check/schema_start_end_s_tbs_6';
create table t1 (c1 int) partition by range(c1) (
	partition p1 start(0) tablespace tblspc_se_x001,
	partition p2 start(10) end (100) every(20) tablespace tblspc_se_x002,
	partition p3 end (400) tablespace tblspc_se_x003,
	partition p4 start(400) end(600) tablespace tblspc_se_x004
);
alter table t1 add partition p5 start (600) end(700) every(30) tablespace tblspc_se_x005;
alter table t1 split partition p4 into (
	partition q1 end (450), 
	partition q2 start (450) end(500) every(15) tablespace tblspc_se_x006, 
	partition q3 start(500) tablespace tblspc_se_x006
	);
select relname, parttype, partstrategy, boundaries, spcname from pg_partition join pg_tablespace b on b.oid=reltablespace
where parentid='schema_start_end_s.t1'::regclass order by relname;
 relname | parttype | partstrategy | boundaries |    spcname     
---------+----------+--------------+------------+----------------
 p1_0    | p        | r            | {0}        | tblspc_se_x001
 p1_1    | p        | r            | {10}       | tblspc_se_x001
 p2_1    | p        | r            | {30}       | tblspc_se_x002
 p2_2    | p        | r            | {50}       | tblspc_se_x002
 p2_3    | p        | r            | {70}       | tblspc_se_x002
 p2_4    | p        | r            | {90}       | tblspc_se_x002
 p2_5    | p        | r            | {100}      | tblspc_se_x002
 p3      | p        | r            | {400}      | tblspc_se_x003
 p5_1    | p        | r            | {630}      | tblspc_se_x005
 p5_2    | p        | r            | {660}      | tblspc_se_x005
 p5_3    | p        | r            | {690}      | tblspc_se_x005
 p5_4    | p        | r            | {700}      | tblspc_se_x005
 q2_1    | p        | r            | {465}      | tblspc_se_x006
 q2_2    | p        | r            | {480}      | tblspc_se_x006
 q2_3    | p        | r            | {495}      | tblspc_se_x006
 q2_4    | p        | r            | {500}      | tblspc_se_x006
 q3      | p        | r            | {600}      | tblspc_se_x006
(17 rows)

drop table if exists t1;
drop tablespace tblspc_se_x001;
drop tablespace tblspc_se_x002;
drop tablespace tblspc_se_x003;
drop tablespace tblspc_se_x004;
drop tablespace tblspc_se_x005;
drop tablespace tblspc_se_x006;
-- test table-like clause
create table t1 (c1 int);
create table t2 (c2 int) partition by range (c2) (partition p1 start (1) end (100) every (30));
create table t3 (like t1 including partition, c3 text);
ERROR:  could not specify "INCLUDING PARTITION" for non-partitioned-table relation:"t1"
drop table if exists t3;
NOTICE:  table "t3" does not exist, skipping
create table t3 (like t1, c3 text) partition by range (c1) (partition q1 start (20) end (80) every(40));
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t3'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 q1_0    | p        | r            | {20}
 q1_1    | p        | r            | {60}
 q1_2    | p        | r            | {80}
 t3      | r        | r            | 
(4 rows)

drop table if exists t3;
create table t3 (like t2 including partition, c3 text) partition by range (c1) (partition q1 start (20) end (80) every(40));
ERROR:  unsupport "like clause including partition" for partitioned table
DETAIL:  use either "like clause including partition" or "partition by" clause
drop table if exists t3;
NOTICE:  table "t3" does not exist, skipping
create table t3 (like t2 including partition, c3 text);
select relname, parttype, partstrategy, boundaries from pg_partition where parentid='schema_start_end_s.t3'::regclass order by relname;
 relname | parttype | partstrategy | boundaries 
---------+----------+--------------+------------
 p1_0    | p        | r            | {1}
 p1_1    | p        | r            | {31}
 p1_2    | p        | r            | {61}
 p1_3    | p        | r            | {91}
 p1_4    | p        | r            | {100}
 t3      | r        | r            | 
(6 rows)

drop table if exists t3;
drop table if exists t1;
drop table if exists t2;
-- test unsupported datatype
create table t1 (c1 smalldatetime) partition by range (c1) (partition p1 end (maxvalue));
ERROR:  datatype of column "c1" is unsupported for partition key in start/end clause.
HINT:  Valid datatypes are: smallint, int, bigint, float4/real, float8/double, numeric, date and timestamp [with time zone].
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 time) partition by range (c1) (partition p1 end (maxvalue));
ERROR:  datatype of column "c1" is unsupported for partition key in start/end clause.
HINT:  Valid datatypes are: smallint, int, bigint, float4/real, float8/double, numeric, date and timestamp [with time zone].
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 tinyint) partition by range (c1) (partition p1 end (maxvalue));
ERROR:  datatype of column "c1" is unsupported for partition key in start/end clause.
HINT:  Valid datatypes are: smallint, int, bigint, float4/real, float8/double, numeric, date and timestamp [with time zone].
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
create table t1 (c1 interval day to minute) partition by range (c1) (partition p1 end (maxvalue));
ERROR:  datatype of column "c1" is unsupported for partition key in start/end clause.
HINT:  Valid datatypes are: smallint, int, bigint, float4/real, float8/double, numeric, date and timestamp [with time zone].
drop table if exists t1;
NOTICE:  table "t1" does not exist, skipping
---
-- end test START/END
---
reset datestyle;
drop schema schema_start_end_s cascade;
reset current_schema;
