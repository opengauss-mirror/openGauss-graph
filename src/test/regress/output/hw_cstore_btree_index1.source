----
---case 4: different data type with index
----
create table row_index_tbl(
  id1 int1
 ,id2 int2
 ,id4 int4
 ,id8 int8
 ,int1 int
 ,bint bigint
 ,f1   float
 ,flag char
 ,name1 varchar(20)
 ,name2 varchar2(20)
 ,name3 nvarchar2(20)
 ,name4 text
 ,name5 bytea
 ,time1 date
 ,time2 timetz
 ,time3 time
 ,num1 float8
 ,num2 decimal
 ,serial1 int 
 ,interval1 interval
 ,interval2 tinterval) distribute by hash(id2);
insert into row_index_tbl values(10,400,2000,40000,1,111111,1.1,'a','aa','bb','cc','dd','ff','1996-02-12','1984-2-6 01:00:30+8','02:05:36',30.12,0.03,2147483647,'2 day 13:34:56','["Sep 4, 1983 23:59:12" "Oct 4, 1983 23:59:12"]');
insert into row_index_tbl values(20,300,3000,10000,2,222222,2.2,'b','ee','cc','dd','aa','hh','1998-03-24','1986-2-6 03:00:30+8','04:36:25',20.15,0.06,-2147483647,'1 day 18:34:56','["May 10, 1947 23:59:12" "Jan 14, 1973 03:14:21"]');
insert into row_index_tbl values(30,200,4000,30000,3,333333,3.3,'c','cc','bb','aa','ee','gg','1997-05-26','1987-2-6 08:00:30+8','06:36:18',34.36,0.07,2136483647,'18 day 14:34:56','["Feb 10, 1947 23:59:12" "Jan 14, 1973 03:14:21"]');
insert into row_index_tbl values(40,100,1000,20000,4,444444,4.4,'d','cc','bb','aa','ee','dd','1992-01-30','1989-2-6 06:00:30+8','08:21:56',25.12,0.05,-2136483647,'7 day 16:34:56','["epoch" "Mon May 1 00:30:30 1995"]');
create table cstore_index_tbl(
  id1 int1
 ,id2 int2
 ,id4 int4
 ,id8 int8
 ,int1 int
 ,bint bigint
 ,f1   float
 ,flag char
 ,name1 varchar(20)
 ,name2 varchar2(20)
 ,name3 nvarchar2(20)
 ,name4 text
 ,name5 bytea
 ,time1 date
 ,time2 timetz
 ,time3 time
 ,num1 float8
 ,num2 decimal
 ,serial1 int
 ,interval1 interval
 ,interval2 tinterval)with(orientation=column) distribute by hash(id2);
insert into cstore_index_tbl select * from row_index_tbl;
select ctid from cstore_index_tbl order by 1;
   ctid   
----------
 (1001,1)
 (1001,1)
 (1001,1)
 (1001,1)
(4 rows)

create index idx_int1 on cstore_index_tbl using btree(id1);
create index idx_int2 on cstore_index_tbl using btree(id2);
create index idx_int4 on cstore_index_tbl using btree(id4);
create index idx_int8 on cstore_index_tbl using btree(id8);
create index idx_int on cstore_index_tbl using btree(int1);
create index idx_bigint on cstore_index_tbl using btree(bint);
create index idx_float on cstore_index_tbl using btree(flag);
create index idx_varchar on cstore_index_tbl using btree(name1);
create index idx_varchar2 on cstore_index_tbl using btree(name2);
create index idx_nvarchar2 on cstore_index_tbl using btree(name3);
create index idx_text on cstore_index_tbl using btree(name4);
create index idx_date on cstore_index_tbl using btree(time1);
create index idx_timetz on cstore_index_tbl using btree(time2);
create index idx_time on cstore_index_tbl using btree(time3);
create index idx_float8 on cstore_index_tbl using btree(num1);
create index idx_decimal on cstore_index_tbl using btree(num2);
create index idx_serial on cstore_index_tbl using btree(serial1);
create index idx_interval on cstore_index_tbl using btree(interval1);
create index idx_tinterval on cstore_index_tbl using btree(interval2);
create index idx_id4_name1 on cstore_index_tbl using btree(id4,name1);
create index idx_id4_name2 on cstore_index_tbl using btree(id4,name2);
create index idx_id4_name3 on cstore_index_tbl using btree(id4,name3);
create index idx_id4_name4 on cstore_index_tbl using btree(id4,name4);
create index idx_bint_flag on cstore_index_tbl using btree(bint,flag);
create index idx_int1_time on cstore_index_tbl using btree(int1,time3);
create index idx_time1_name2 on cstore_index_tbl using btree(time1,name2);
create index idx_id4_time2 on cstore_index_tbl using btree(id4,time2);
create index idx_num1_time2 on cstore_index_tbl using btree(num1,time2);
create index idx_id4_num2 on cstore_index_tbl using btree(id4,num2);
create index idx_name1_name2 on cstore_index_tbl using btree(name1,name2);
create index idx_time1_interval1 on cstore_index_tbl using btree(time1,interval1);
set enable_seqscan=off;
explain (verbose on, costs off) select * from cstore_index_tbl where id2 > 100;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_int2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.id2 > 100)
(9 rows)

select * from cstore_index_tbl where id2 > 100 order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where id4 > 1000;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.id4) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_id4_num2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.id4 > 1000)
(9 rows)

select * from cstore_index_tbl where id4 > 1000 order by id4;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where id8 > 10000;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.id8) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_int8 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.id8 > 10000)
(9 rows)

select * from cstore_index_tbl where id8 > 10000 order by id8;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where name1 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_name1_name2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.name1)::text > 'aa'::text)
(9 rows)

select * from cstore_index_tbl where name1 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where name2 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_name1_name2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.name2)::text > 'aa'::text)
(9 rows)

select * from cstore_index_tbl where name2 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(4 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where name3 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_id4_name3 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.name3)::text > 'aa'::text)
(9 rows)

select * from cstore_index_tbl where name3 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1             |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+-----------------------------------+-----------------------------------------------------------------
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs  | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(2 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where name4 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name4) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_id4_name4 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.name4 > 'aa'::text)
(9 rows)

select * from cstore_index_tbl where name4 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where time1 > '1992-01-30';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.time1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_time1_interval1 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.time1 > 'Thu Jan 30 00:00:00 1992'::timestamp without time zone)
(9 rows)

select * from cstore_index_tbl where time1 > '1992-01-30' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where time2 > '1984-2-6 01:00:30+8';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.time2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_num1_time2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.time2 > '01:00:30+08'::time with time zone)
(9 rows)

select * from cstore_index_tbl where time2 > '1984-2-6 01:00:30+8' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where num1 > 20.20;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.num1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_num1_time2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.num1 > 20.2::double precision)
(9 rows)

select * from cstore_index_tbl where num1 > 20.20 order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where num2 > 0.05;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.num2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_id4_num2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.num2 > .05)
(9 rows)

select * from cstore_index_tbl where num2 > 0.05 order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(2 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where serial1 > -2136483647;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.serial1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_serial on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.serial1 > (-2136483647))
(9 rows)

select * from cstore_index_tbl where serial1 > -2136483647 order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |  serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 | 2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 | 2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(2 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where interval1 > '1 day 18:34:56';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.interval1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_time1_interval1 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.interval1 > '@ 1 day 18 hours 34 mins 56 secs'::interval)
(9 rows)

select * from cstore_index_tbl where interval1 > '1 day 18:34:56' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where interval2 > '["Sep 4, 1983 23:59:12" "Oct 4, 1983 23:59:12"]';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.interval2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_tinterval on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.interval2 > '["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]'::tinterval)
(9 rows)

select * from cstore_index_tbl where interval2 > '["Sep 4, 1983 23:59:12" "Oct 4, 1983 23:59:12"]' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 40  | 100 | 1000 | 20000 |    4 | 444444 | 4.4 | d    | cc    | bb    | aa    | ee    | \x6464 | Thu Jan 30 00:00:00 1992 | 06:00:30+08 | 08:21:56 | 25.12 |  .05 | -2136483647 | @ 7 days 16 hours 34 mins 56 secs  | ["Wed Dec 31 16:00:00 1969 PST" "Mon May 01 00:30:30 1995 PDT"]
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where id2 > 100 and name1 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_name1_name2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.name1)::text > 'aa'::text)
               Filter: (cstore_index_tbl.id2 > 100)
(10 rows)

select * from cstore_index_tbl where id2 > 100 and name1 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(2 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where id4 > 1000 and name2 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.id4, public.cstore_index_tbl.name2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_id4_name2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.id4 > 1000) AND ((cstore_index_tbl.name2)::text > 'aa'::text))
(9 rows)

select * from cstore_index_tbl where id4 > 1000 and name2 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where num1 > 20.5 and name3 > 'aa';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.num1, public.cstore_index_tbl.name3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_num1_time2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.num1 > 20.5::double precision)
               Filter: ((cstore_index_tbl.name3)::text > 'aa'::text)
(10 rows)

select * from cstore_index_tbl where num1 > 20.5 and name3 > 'aa' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |  serial1   |             interval1             |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+------------+-----------------------------------+-----------------------------------------------------------------
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 | 2147483647 | @ 2 days 13 hours 34 mins 56 secs | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(1 row)

explain (verbose on, costs off) select * from cstore_index_tbl where id4 > 1000 and time1 > '1992-01-30';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.id4, public.cstore_index_tbl.time1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_time1_interval1 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.time1 > 'Thu Jan 30 00:00:00 1992'::timestamp without time zone)
               Filter: (cstore_index_tbl.id4 > 1000)
(10 rows)

select * from cstore_index_tbl where id4 > 1000 and time1 > '1992-01-30' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 |  2147483647 | @ 2 days 13 hours 34 mins 56 secs  | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(3 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where flag > 'a' and time3 < '08:21:53' order by id2;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.flag, public.cstore_index_tbl.time3) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Merge Sort Key: cstore_index_tbl.id2
         Node/s: All datanodes
         ->  Vector Sort
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Sort Key: cstore_index_tbl.id2
               ->  CStore Index Scan using idx_int1_time on public.cstore_index_tbl
                     Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
                     Distribute Key: id2
                     Index Cond: (cstore_index_tbl.time3 < '08:21:53'::time without time zone)
                     Filter: (cstore_index_tbl.flag > 'a'::bpchar)
(14 rows)

select * from cstore_index_tbl where flag > 'a' and time3 < '08:21:53' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |             interval1              |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+------------------------------------+-----------------------------------------------------------------
 30  | 200 | 4000 | 30000 |    3 | 333333 | 3.3 | c    | cc    | bb    | aa    | ee    | \x6767 | Mon May 26 00:00:00 1997 | 08:00:30+08 | 06:36:18 | 34.36 |  .07 |  2136483647 | @ 18 days 14 hours 34 mins 56 secs | ["Mon Feb 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs   | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(2 rows)

explain (verbose on, costs off) select * from cstore_index_tbl where name1 > 'aa' and name2 > 'bb';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name1, public.cstore_index_tbl.name2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_name1_name2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (((cstore_index_tbl.name1)::text > 'aa'::text) AND ((cstore_index_tbl.name2)::text > 'bb'::text))
(9 rows)

select * from cstore_index_tbl where name1 > 'aa' and name2 > 'bb' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |            interval1             |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+----------------------------------+-----------------------------------------------------------------
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(1 row)

explain (verbose on, costs off) select * from cstore_index_tbl where time1 > '1996-02-12' and interval1 < '2 day 13:34:56';
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.time1, public.cstore_index_tbl.interval1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_time1_interval1 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: ((cstore_index_tbl.time1 > 'Mon Feb 12 00:00:00 1996'::timestamp without time zone) AND (cstore_index_tbl.interval1 < '@ 2 days 13 hours 34 mins 56 secs'::interval))
(9 rows)

select * from cstore_index_tbl where time1 > '1996-02-12' and interval1 < '2 day 13:34:56' order by id2;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |   serial1   |            interval1             |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+-------------+----------------------------------+-----------------------------------------------------------------
 20  | 300 | 3000 | 10000 |    2 | 222222 | 2.2 | b    | ee    | cc    | dd    | aa    | \x6868 | Tue Mar 24 00:00:00 1998 | 03:00:30+08 | 04:36:25 | 20.15 |  .06 | -2147483647 | @ 1 day 18 hours 34 mins 56 secs | ["Sat May 10 23:59:12 1947 PST" "Sun Jan 14 03:14:21 1973 PST"]
(1 row)

----
---case 5: mix indexed and un-indexed(use the table in case 6)
----
drop index idx_int1;
drop index idx_int4;
drop index idx_int8;
drop index idx_int;
drop index idx_bigint;
drop index idx_float;
drop index idx_varchar;
drop index idx_varchar2;
drop index idx_nvarchar2;
drop index idx_text;
drop index idx_date;
drop index idx_timetz;
drop index idx_time;
drop index idx_float8;
drop index idx_decimal;
drop index idx_serial;
drop index idx_interval;
drop index idx_tinterval;
drop index idx_id4_name1;
drop index idx_id4_name2;
drop index idx_id4_name3;
drop index idx_id4_name4;
drop index idx_time1_name2;
drop index idx_id4_time2;
drop index idx_num1_time2;
drop index idx_id4_num2;
drop index idx_name1_name2;
drop index idx_time1_interval1;
drop index idx_bint_flag;
set enable_seqscan=off;
explain (verbose on, costs off) select * from cstore_index_tbl where id2 >100  and name1 < 'dd' and num1=30.12;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.id2, public.cstore_index_tbl.name1, public.cstore_index_tbl.num1) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Row Adapter
   Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
   ->  Vector Streaming (type: GATHER)
         Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
         Node/s: All datanodes
         ->  CStore Index Scan using idx_int2 on public.cstore_index_tbl
               Output: id1, id2, id4, id8, int1, bint, f1, flag, name1, name2, name3, name4, name5, time1, time2, time3, num1, num2, serial1, interval1, interval2
               Distribute Key: id2
               Index Cond: (cstore_index_tbl.id2 > 100)
               Filter: (((cstore_index_tbl.name1)::text < 'dd'::text) AND (cstore_index_tbl.num1 = 30.12::double precision))
(10 rows)

select * from cstore_index_tbl where id2 >100  and name1 < 'dd' and num1=30.12;
 id1 | id2 | id4  |  id8  | int1 |  bint  | f1  | flag | name1 | name2 | name3 | name4 | name5  |          time1           |    time2    |  time3   | num1  | num2 |  serial1   |             interval1             |                            interval2                            
-----+-----+------+-------+------+--------+-----+------+-------+-------+-------+-------+--------+--------------------------+-------------+----------+-------+------+------------+-----------------------------------+-----------------------------------------------------------------
 10  | 400 | 2000 | 40000 |    1 | 111111 | 1.1 | a    | aa    | bb    | cc    | dd    | \x6666 | Mon Feb 12 00:00:00 1996 | 01:00:30+08 | 02:05:36 | 30.12 |  .03 | 2147483647 | @ 2 days 13 hours 34 mins 56 secs | ["Sun Sep 04 23:59:12 1983 PDT" "Tue Oct 04 23:59:12 1983 PDT"]
(1 row)

drop index idx_int2;
drop table row_index_tbl;
drop table cstore_index_tbl;
-----
--- case 6: truncate and delete cstore relation with index
-----
create table IDEX_PARTITION_TABLE_001(COL_INT int) with(orientation=column);
CREATE INDEX STORAGE_IDEX_PARTITION_IDEX_001 ON IDEX_PARTITION_TABLE_001 using btree(COL_INT);
insert into IDEX_PARTITION_TABLE_001 values(1000);
truncate table IDEX_PARTITION_TABLE_001;
select * from IDEX_PARTITION_TABLE_001;
 col_int 
---------
(0 rows)

insert into IDEX_PARTITION_TABLE_001 values(1000);
delete from IDEX_PARTITION_TABLE_001 where col_int=1000;
select * from IDEX_PARTITION_TABLE_001 where col_int=1000;
 col_int 
---------
(0 rows)

drop table IDEX_PARTITION_TABLE_001;
----
--- case 7: two indexes with the same column
----
create table row_index_tbl(c1 int,c2 int,c3 int) distribute by hash(c1);
insert into row_index_tbl values(0,1,2);
insert into row_index_tbl values(3,4,5);
insert into row_index_tbl values(6,7,8);
insert into row_index_tbl values(9,10,11);
create table cstore_index_tbl(c1 int,c2 int,c3 int) with (orientation = column) distribute by hash(c1);
insert into cstore_index_tbl select * from row_index_tbl;
create index idx_c2 on cstore_index_tbl using btree(c2);
explain (verbose on, costs off) SELECT c2  FROM cstore_index_tbl WHERE c2 > 2 and  c2 < 9;
WARNING:  Statistics in some tables or columns(public.cstore_index_tbl.c1, public.cstore_index_tbl.c2) are not collected.
HINT:  Do analyze for them in order to generate optimized plan.
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 Row Adapter
   Output: c2
   ->  Vector Streaming (type: GATHER)
         Output: c2
         Node/s: All datanodes
         ->  CStore Index Only Scan using idx_c2 on public.cstore_index_tbl
               Output: c2
               Distribute Key: c1
               Index Cond: ((cstore_index_tbl.c2 > 2) AND (cstore_index_tbl.c2 < 9))
(9 rows)

SELECT c2  FROM cstore_index_tbl WHERE c2 > 2 and  c2 < 9 order by c2;
 c2 
----
  4
  7
(2 rows)

drop table row_index_tbl;
drop table cstore_index_tbl;
----
--- case 9: index scan with partition number be zero
----
CREATE TABLE COMPRESS_TABLE_INDEX(
c_int_1 BIGINT,
c_char_1 CHAR(50),
c_int_2 BIGINT,
c_dec_1 DECIMAL(10,4),
c_char_2 CHAR(50),
c_text_1 text,
c_date_1 DATE,
c_date_2 DATE,
c_text_2 text,
c_dec_2 DECIMAL(10,4)) with(orientation=column)
PARTITION BY RANGE(c_date_1)
(
    PARTITION COMPRESS_TABLE_INTEVAL_1  VALUES LESS THAN('2012-8-23')
);
CREATE INDEX INDEX_COMPRESS_1 ON COMPRESS_TABLE_INDEX using btree(C_INT_2) LOCAL;
CREATE INDEX INDEX_COMPRESS_2 ON COMPRESS_TABLE_INDEX using btree(C_DATE_1) LOCAL;
CREATE INDEX INDEX_COMPRESS_3 ON COMPRESS_TABLE_INDEX using btree(C_INT_1) LOCAL;
SELECT COUNT(*) FROM COMPRESS_TABLE_INDEX WHERE C_DATE_1>='2012-09-01' AND C_DATE_1<'2012-9-20';
 count 
-------
     0
(1 row)

drop table COMPRESS_TABLE_INDEX;
----
--- case 10:index scan with qual push down
----
set datestyle to iso;
SET IntervalStyle to postgres;
set time zone PRC;
CREATE TABLE PARTITION_SELECT_PICT_TABLE(
C_CHAR_3 CHAR(102400),
C_VARCHAR_3 VARCHAR(1024),
C_INT INTEGER,
C_NUMERIC numeric(10,5),
C_TS_WITHOUT TIMESTAMP WITHOUT TIME ZONE)
DISTRIBUTE BY HASH(C_CHAR_3)
partition by range (C_CHAR_3,C_VARCHAR_3,C_INT,C_TS_WITHOUT)
(
        partition PARTITION_SELECT_PICT_1 values less than ('DEFGHIJ', 'defghij', 444, '2000-04-04 04:04:04'),
        partition PARTITION_SELECT_PICT_2 values less than ('GHIJKLM', 'ghijklm', 777, '2000-07-07 07:07:07'),
        partition PARTITION_SELECT_PICT_3 values less than ('MJKLMNO', 'ijklmno', 999, '2000-09-09 09:09:09')
);
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('ABCDEFG','abcdefg',111,111.1,'2000-01-01 01:01:01');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('BCDEFGH','bcdefgh',222,222.2,'2000-02-02 02:02:02');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('CDEFGHI','cdefghi',333,333.3,'2000-03-03 03:03:03');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('DEFGHIJ','defghij',444,444.4,'2000-04-04 04:04:04');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('EFGHIJK','efghijk',555,555.5,'2000-05-05 05:05:05');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('FGHIJKL','fghijkl',666,666.6,'2000-06-06 06:06:06');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('ABCDEFG',null,111,111.1,'2000-01-01 01:01:01');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('ABCDEFG',null,null,null,null);
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('ABCDEFG','abcdefg',null,111.1,'2000-01-01 01:01:01');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('BCDEFGH','bcdefgh',null,null,'2000-02-02 02:02:02');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('BCDEFGH',null,222,null,'2000-02-02 02:02:02');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('CDEFGHI','cdefghi',333,null,'2000-03-03 03:03:03');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('EFGHIJK',null,null,555.5,'2000-05-05 05:05:05');
INSERT INTO PARTITION_SELECT_PICT_TABLE VALUES('FGHIJKL','fghijkl',null,null,null);
insert into PARTITION_SELECT_PICT_TABLE VALUES('A'||generate_series(1,5),'a'||generate_series(1,5),generate_series(1,5),cast( generate_series(1,5)||'.111' as numeric(10,5)),cast('2000-01-'||generate_series(1,5)||' 12:12:12' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('B'||generate_series(101,103),'b'||generate_series(101,103),generate_series(101,103),cast(generate_series(101,103)||'.111' as numeric(10,5)),cast('2000-02-'||generate_series(1,3)||' 12:12:12' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('C'||generate_series(201,205),'c'||generate_series(201,205),generate_series(201,205),cast(generate_series(201,205)||'.111' as numeric(10,5)),cast('2000-03-'||generate_series(1,5)||' 12:12:12' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('D'||generate_series(301,303),'d'||generate_series(301,303),generate_series(301,303),cast(generate_series(301,303)||'.111' as numeric(10,5)),cast('2000-04-'||generate_series(1,3)||' 12:12:12' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('DE'||generate_series(401,405),'de'||generate_series(401,405),generate_series(401,405),cast(generate_series(401,405)||'.111' as numeric(10,5)),cast('2000-05-'||generate_series(1,5)||' 12:12:12' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('E'||generate_series(501,504),'e'||generate_series(501,504),generate_series(501,504),cast( generate_series(501,504)||'.222' as numeric(10,5)),cast('2000-01-'||generate_series(1,4)||' 13:13:13' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('F'||generate_series(601,603),'f'||generate_series(601,603),generate_series(601,603),cast(generate_series(601,603)||'.222' as numeric(10,5)),cast('2000-02-'||generate_series(1,3)||' 13:13:13' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('G'||generate_series(701,705),'g'||generate_series(701,705),generate_series(701,705),cast(generate_series(701,705)||'.222' as numeric(10,5)),cast('2000-03-'||generate_series(1,5)||' 13:13:13' as TIMESTAMP WITHOUT TIME ZONE));
insert into PARTITION_SELECT_PICT_TABLE VALUES('GH'||generate_series(801,803),'gh'||generate_series(801,803),generate_series(801,803),cast(generate_series(801,803)||'.222' as numeric(10,5)),cast('2000-04-'||generate_series(1,3)||' 13:13:13' as TIMESTAMP WITHOUT TIME ZONE));
CREATE TABLE VECTOR_PARTITION_SELECT_PICT_TABLE(
C_CHAR_3 CHAR(102400),
C_VARCHAR_3 VARCHAR(1024),
C_INT INTEGER,
C_NUMERIC numeric(10,5),
C_TS_WITHOUT TIMESTAMP WITHOUT TIME ZONE) with (orientation = column)
DISTRIBUTE BY HASH(C_CHAR_3)
partition by range (C_CHAR_3,C_VARCHAR_3,C_INT,C_TS_WITHOUT)
(
        partition PARTITION_SELECT_PICT_1 values less than ('DEFGHIJ', 'defghij', 444, '2000-04-04 04:04:04'),
        partition PARTITION_SELECT_PICT_2 values less than ('GHIJKLM', 'ghijklm', 777, '2000-07-07 07:07:07'),
        partition PARTITION_SELECT_PICT_3 values less than ('MJKLMNO', 'ijklmno', 999, '2000-09-09 09:09:09')
);
insert into VECTOR_PARTITION_SELECT_PICT_TABLE select * from PARTITION_SELECT_PICT_TABLE;
create index PARTITION_SELECT_PICT_INDEX_1 ON VECTOR_PARTITION_SELECT_PICT_TABLE using btree(C_CHAR_3,C_VARCHAR_3,C_INT,C_NUMERIC,C_TS_WITHOUT) local(PARTITION PARTITION_SELECT_PICT_1, PARTITION PARTITION_SELECT_PICT_2, PARTITION PARTITION_SELECT_PICT_3);
create index PARTITION_SELECT_PICT_INDEX_2 ON VECTOR_PARTITION_SELECT_PICT_TABLE using btree(C_CHAR_3,C_VARCHAR_3,C_INT,C_TS_WITHOUT) local(PARTITION PARTITION_SELECT_PICT_1, PARTITION PARTITION_SELECT_PICT_2, PARTITION PARTITION_SELECT_PICT_3);
create index PARTITION_SELECT_PICT_INDEX_3 ON VECTOR_PARTITION_SELECT_PICT_TABLE using btree(C_CHAR_3,C_INT,C_TS_WITHOUT) local(PARTITION PARTITION_SELECT_PICT_1, PARTITION PARTITION_SELECT_PICT_2, PARTITION PARTITION_SELECT_PICT_3);
SELECT trim(C_CHAR_3) , trim(C_VARCHAR_3) , C_INT , C_NUMERIC , C_TS_WITHOUT , lower(trim(C_CHAR_3)) , initcap(trim(C_VARCHAR_3)) , abs(C_INT) , abs(C_NUMERIC) , extract(year from C_TS_WITHOUT) FROM VECTOR_PARTITION_SELECT_PICT_TABLE partition(PARTITION_SELECT_PICT_1) where 'a' not like C_VARCHAR_3 and 1000 != C_INT and C_NUMERIC is not null and (C_TS_WITHOUT >= '2000-01-01 01:01:01' and C_TS_WITHOUT <= '2000-09-09 09:09:09') ORDER BY 1 , 2 , 3 , 4 , 5 ;
  btrim  |  btrim  | c_int | c_numeric |    c_ts_without     |  lower  | initcap | abs |    abs    | date_part 
---------+---------+-------+-----------+---------------------+---------+---------+-----+-----------+-----------
 A1      | a1      |     1 |   1.11100 | 2000-01-01 12:12:12 | a1      | A1      |   1 |   1.11100 |      2000
 A2      | a2      |     2 |   2.11100 | 2000-01-02 12:12:12 | a2      | A2      |   2 |   2.11100 |      2000
 A3      | a3      |     3 |   3.11100 | 2000-01-03 12:12:12 | a3      | A3      |   3 |   3.11100 |      2000
 A4      | a4      |     4 |   4.11100 | 2000-01-04 12:12:12 | a4      | A4      |   4 |   4.11100 |      2000
 A5      | a5      |     5 |   5.11100 | 2000-01-05 12:12:12 | a5      | A5      |   5 |   5.11100 |      2000
 ABCDEFG | abcdefg |   111 | 111.10000 | 2000-01-01 01:01:01 | abcdefg | Abcdefg | 111 | 111.10000 |      2000
 B101    | b101    |   101 | 101.11100 | 2000-02-01 12:12:12 | b101    | B101    | 101 | 101.11100 |      2000
 B102    | b102    |   102 | 102.11100 | 2000-02-02 12:12:12 | b102    | B102    | 102 | 102.11100 |      2000
 B103    | b103    |   103 | 103.11100 | 2000-02-03 12:12:12 | b103    | B103    | 103 | 103.11100 |      2000
 BCDEFGH | bcdefgh |   222 | 222.20000 | 2000-02-02 02:02:02 | bcdefgh | Bcdefgh | 222 | 222.20000 |      2000
 C201    | c201    |   201 | 201.11100 | 2000-03-01 12:12:12 | c201    | C201    | 201 | 201.11100 |      2000
 C202    | c202    |   202 | 202.11100 | 2000-03-02 12:12:12 | c202    | C202    | 202 | 202.11100 |      2000
 C203    | c203    |   203 | 203.11100 | 2000-03-03 12:12:12 | c203    | C203    | 203 | 203.11100 |      2000
 C204    | c204    |   204 | 204.11100 | 2000-03-04 12:12:12 | c204    | C204    | 204 | 204.11100 |      2000
 C205    | c205    |   205 | 205.11100 | 2000-03-05 12:12:12 | c205    | C205    | 205 | 205.11100 |      2000
 CDEFGHI | cdefghi |   333 | 333.30000 | 2000-03-03 03:03:03 | cdefghi | Cdefghi | 333 | 333.30000 |      2000
 D301    | d301    |   301 | 301.11100 | 2000-04-01 12:12:12 | d301    | D301    | 301 | 301.11100 |      2000
 D302    | d302    |   302 | 302.11100 | 2000-04-02 12:12:12 | d302    | D302    | 302 | 302.11100 |      2000
 D303    | d303    |   303 | 303.11100 | 2000-04-03 12:12:12 | d303    | D303    | 303 | 303.11100 |      2000
 DE401   | de401   |   401 | 401.11100 | 2000-05-01 12:12:12 | de401   | De401   | 401 | 401.11100 |      2000
 DE402   | de402   |   402 | 402.11100 | 2000-05-02 12:12:12 | de402   | De402   | 402 | 402.11100 |      2000
 DE403   | de403   |   403 | 403.11100 | 2000-05-03 12:12:12 | de403   | De403   | 403 | 403.11100 |      2000
 DE404   | de404   |   404 | 404.11100 | 2000-05-04 12:12:12 | de404   | De404   | 404 | 404.11100 |      2000
 DE405   | de405   |   405 | 405.11100 | 2000-05-05 12:12:12 | de405   | De405   | 405 | 405.11100 |      2000
(24 rows)

drop table PARTITION_SELECT_PICT_TABLE;
drop table VECTOR_PARTITION_SELECT_PICT_TABLE;
